<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&amp;emsp;">
<meta property="og:type" content="article">
<meta property="og:title" content="零基础入门nlp-新闻文本分类实战">
<meta property="og:url" content="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Yakult">
<meta property="og:description" content="&amp;emsp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714203836905.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714203929296.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714204856589.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714204249463.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210354729.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210458879.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210519939.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205344406.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210458879.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205456898.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205545327.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205932720.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210806492.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211046668.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211115945.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211153687.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211232716.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211955713.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211316167.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211348456.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714211409582.png">
<meta property="article:published_time" content="2020-07-20T14:20:02.000Z">
<meta property="article:modified_time" content="2020-09-07T08:12:51.940Z">
<meta property="article:author" content="养乐多">
<meta property="article:tag" content="nlp，入门，datawhale">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>零基础入门nlp-新闻文本分类实战 | Yakult</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yakult</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="养乐多">
      <meta itemprop="description" content="从现在开始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yakult">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          零基础入门nlp-新闻文本分类实战
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-20 22:20:02" itemprop="dateCreated datePublished" datetime="2020-07-20T22:20:02+08:00">2020-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-07 16:12:51" itemprop="dateModified" datetime="2020-09-07T16:12:51+08:00">2020-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&emsp;<a id="more"></a></p>
<h3 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h3><p>&emsp;&emsp;首先要理解赛题的背景及描述——赛题以新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。通过描述，我们可以知道这道题是要==通过给定的一段文本来判断是属于哪一种类别的==。</p>
<p>&emsp;&emsp;赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。处理后的赛题训练数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">label</th>
<th style="text-align:center">text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td>
</tr>
</tbody>
</table>
</div>
<p>标签的对应关系为：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;'科技': <span class="number">0</span>, '股票': <span class="number">1</span>, '体育': <span class="number">2</span>, '娱乐': <span class="number">3</span>, '时政': <span class="number">4</span>, '社会': <span class="number">5</span>, '教育': <span class="number">6</span>, '财经': <span class="number">7</span>, '家居': <span class="number">8</span>, '游戏': <span class="number">9</span>, '房产': <span class="number">10</span>, '时尚': <span class="number">11</span>, '彩票': <span class="number">12</span>, '星座': <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在接触赛题初时，对于这次比赛的评判标准要很清楚！！！</p>
<script type="math/tex; mode=display">
计算公式：2\times \frac{precision \times recall}{precision + recall}</script><p>上述公式也就是F1_score,是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的<strong>精确(precision)</strong>和<strong>召回率(recall)</strong>。F1分数可以看作是模型精确率和召回率的一种调和平均，它的最大值是1，最小值是0。这里提到了精确率和召回率，要想理解这两个还得先知道<strong>TP、FP、TN、FN</strong>这四个概念</p>
<ul>
<li>TP：True Positive ：做出Positive的判定，而且判定是正确的</li>
<li>FP：False Positive ：做出Positive的判定，而且判定是错误的</li>
<li>TN：True Negative ：做出Negative的判定，而且判定是正确的</li>
<li>FN：False Negative：错误的Negative判定，而且判断是错误的</li>
</ul>
<script type="math/tex; mode=display">
precision = \frac{TP}{TP+FP} \\
recall = \frac{TP}{TP+FN}</script><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>出题者提到数据集文件用<code>&#39;\t&#39;</code>分割，因此这样读取数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_df = pd.read_csv(<span class="string">'../input/train_set.csv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>上面图中显示的数据，进行了脱敏处理的。</p>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>我们希望通过训练集的数据，通过数据分析得出下列的结论：</p>
<ul>
<li>赛题数据中，新闻文本的长度是多少？</li>
<li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li>
<li>赛题数据中，字符分布是怎么样的？</li>
</ul>
<h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%pylab inline</span><br><span class="line">train_df[<span class="string">'text_len'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: len(x.split(<span class="string">' '</span>)))</span><br><span class="line">print(train_df[<span class="string">'text_len'</span>].describe())</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Populating the interactive namespace <span class="keyword">from</span> numpy <span class="keyword">and</span> matplotlib</span><br><span class="line">count    <span class="number">200000.000000</span></span><br><span class="line">mean        <span class="number">907.207110</span></span><br><span class="line">std         <span class="number">996.029036</span></span><br><span class="line">min           <span class="number">2.000000</span></span><br><span class="line"><span class="number">25</span>%         <span class="number">374.000000</span></span><br><span class="line"><span class="number">50</span>%         <span class="number">676.000000</span></span><br><span class="line"><span class="number">75</span>%        <span class="number">1131.000000</span></span><br><span class="line">max       <span class="number">57921.000000</span></span><br><span class="line">Name: text_len, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过上面的结果，可以看出200000个句子，每个句子平局由907个字符组成，最短的由两个字符组成，最长的达到57921个字符。</p>
<p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_ = plt.hist(train_df[<span class="string">'text_len'</span>], bins=<span class="number">200</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Text char count'</span>)</span><br><span class="line">plt.title(<span class="string">"Histogram of char count"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203836905.png" alt="task2_char_hist" style="zoom:50%;" /></p>
<h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_df[<span class="string">'label'</span>].value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">'News class count'</span>)</span><br><span class="line">plt.xlabel(<span class="string">"category"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203929296.png" alt="task2_class_hist" style="zoom:50%;" /></p>
<p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p>
<p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p>
<h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(len(word_count))</span><br><span class="line"><span class="comment"># 6869</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 7482224)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># ('3133', 1)</span></span><br></pre></td></tr></table></figure>
<p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p>
<p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">train_df[<span class="string">'text_unique'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: <span class="string">' '</span>.join(list(set(x.split(<span class="string">' '</span>)))))</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text_unique'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:int(d[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 197997)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># ('900', 197653)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># ('648', 191975)</span></span><br></pre></td></tr></table></figure>
<p>通过上述分析的总结：</p>
<ol>
<li>赛题中每个新闻包含的字符个数平均为900个，还有一些新闻字符较长；</li>
<li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li>
<li>赛题总共包括7000左右个字符；</li>
</ol>
<p>因此得出的结论：</p>
<ol>
<li><p>每个新闻平均字符个数较多，可能需要截断；</p>
</li>
<li><p>由于类别不均衡，会严重影响模型的精度；</p>
</li>
</ol>
<h3 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>&emsp;&emsp;在自然语言领域，文本的长度是不确定的。文本表示成计算机能够运算的数字或向量的方法一般为词嵌入(Word Embedding)方法。词嵌入将不定长的文本转换到定长的空间去，是文本分类的第一步。</p>
<h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p>
<p>One-hot表示方法的例子如下：假设有两个句子如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">句子<span class="number">1</span>：我 爱 北 京 天 安 门</span><br><span class="line">句子<span class="number">2</span>：我 喜 欢 上 海</span><br></pre></td></tr></table></figure>
<p>首先对所有的句子的字进行编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">'我'</span>: <span class="number">1</span>, <span class="string">'爱'</span>: <span class="number">2</span>, <span class="string">'北'</span>: <span class="number">3</span>, <span class="string">'京'</span>: <span class="number">4</span>, <span class="string">'天'</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">'安'</span>: <span class="number">6</span>, <span class="string">'门'</span>: <span class="number">7</span>, <span class="string">'喜'</span>: <span class="number">8</span>, <span class="string">'欢'</span>: <span class="number">9</span>, <span class="string">'上'</span>: <span class="number">10</span>, <span class="string">'海'</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我：[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">爱：[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">...</span><br><span class="line">海：[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p>
<p>直接统计每个字出现的次数，并进行赋值：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">句子<span class="number">1</span>：我 爱 北 京 天 安 门</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">句子<span class="number">2</span>：我 喜 欢 上 海</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>再看两句英语的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">句子<span class="number">1</span>：John likes to watch movies. Mary likes too.</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">句子<span class="number">2</span>：John also likes to watch football games.</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>不过这种表示方法有个缺点，<strong>在构造文档向量的过程中可以看到，我们并没有表达单词在原来句子中出现的顺序。</strong></p>
<p>下面来看一个用sklearn实现的例子：</p>
<p>安装sklearn库一句话就搞定了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># array([[0, 1, 1, 1, 0, 0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [0, 2, 0, 1, 0, 1, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [1, 0, 0, 1, 1, 0, 1, 1, 1],</span></span><br><span class="line"><span class="comment">#        [0, 1, 1, 1, 0, 0, 1, 0, 1]], dtype=int64)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountVectorizer(*, input=<span class="string">'content'</span>, encoding=<span class="string">'utf-8'</span>, decode_error=<span class="string">'strict'</span>, strip_accents=<span class="literal">None</span>, lowercase=<span class="literal">True</span>, preprocessor=<span class="literal">None</span>, tokenizer=<span class="literal">None</span>, stop_words=<span class="literal">None</span>, token_pattern=<span class="string">'(?u)\b\w\w+\b'</span>, ngram_range=(<span class="number">1</span>, <span class="number">1</span>), analyzer=<span class="string">'word'</span>, max_df=<span class="number">1.0</span>, min_df=<span class="number">1</span>, max_features=<span class="literal">None</span>, vocabulary=<span class="literal">None</span>, binary=<span class="literal">False</span>, dtype=&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">int64</span>'&gt;)</span></span><br></pre></td></tr></table></figure>
<p>其实上面的代码也是sklearn中一贯的套路了，<strong>先创建一个类，然后把数据扔进fit_transform()</strong>，就得到结果了，只不过这里还多了一步，把结果转成了ndarray。</p>
<h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>F-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p>
<script type="math/tex; mode=display">
TF=\frac{在某一类中词条w出现的次数}{该类中所有的词条数目} \\
IDF=\log{\frac{语料库的文档总数}{包含词条w的文档数+1}}\\
TF-IDF=TF\times IDF</script><p>分母之所以要加1，是为了避免分母为0。</p>
<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line"><span class="comment"># array([[0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.6876236 , 0.        , 0.28108867, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.53864762, 0.28108867, 0.        , 0.28108867],</span></span><br><span class="line"><span class="comment">#        [0.51184851, 0.        , 0.        , 0.26710379, 0.51184851,</span></span><br><span class="line"><span class="comment">#         0.        , 0.26710379, 0.51184851, 0.26710379],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524]])</span></span><br></pre></td></tr></table></figure>
<p>跟CountVectors的代码几乎一样就是CountVectorizer()变成了TfidfVectorizer()。</p>
<h4 id="RidgeClassifier-岭回归分类器"><a href="#RidgeClassifier-岭回归分类器" class="headerlink" title="RidgeClassifier(岭回归分类器)"></a>RidgeClassifier(岭回归分类器)</h4><p>&emsp;&emsp;简单介绍下，因为后面有用到分类。简单理解就跟LogisticRegression差不太多，把他们看成相似的作用就行了，细节就不过多说。</p>
<p>&emsp;&emsp;这个分类器有时被称为带有线性核的最小二乘支持向量机。该分类器首先将二进制目标转换为{- 1,1}，然后将该问题视为回归任务，优化与上面相同的目标。预测类对应于回归预测的符号，对于多类分类，将问题视为多输出回归，预测类对应的输出值最大。该分类器使用(惩罚)最小二乘损失来适应分类模型，而不是使用更传统的逻辑或铰链损失(最大边界损失)，在实践中，所有这些模型在准确性或精度/召回率方面都可能导致类似的交叉验证分数，而RidgeClassifier使用的惩罚最小二乘损失允许对具有不同计算性能概要的数值求解器进行各自不同的选择。</p>
<p>接下来我们将对比不同文本表示算法的精度，通过代码本地构建验证集计算F1得分。使用sklearn库中的函数实现。</p>
<p><strong>Count Vectors + RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">vectorizer = CountVectorizer(max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = vectorizer.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.74</span></span><br></pre></td></tr></table></figure>
<p><strong>TF-IDF +  RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">tfidf = TfidfVectorizer(ngram_range=(<span class="number">1</span>,<span class="number">3</span>), max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = tfidf.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.87</span></span><br></pre></td></tr></table></figure>
<h3 id="基于深度学习的文本分类1"><a href="#基于深度学习的文本分类1" class="headerlink" title="基于深度学习的文本分类1"></a>基于深度学习的文本分类1</h3><p><strong>FastText</strong></p>
<p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p>
<p>优点：使用Embedding能提高计算的效率。</p>
<p>如下图所示，FastText是一个三层的神经网络，输入层、隐藏层和输出层。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204856589.png" alt="fast_text" style="zoom: 25%;" /></p>
<p>下图是使用keras实现的FastText网络结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204249463.jpg" alt="keras_fasttext"  /></p>
<p>FastText安装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、pip安装</span></span><br><span class="line">pip install fasttext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、源码安装</span></span><br><span class="line">git clone https://github.com/facebookresearch/fastText.git</span><br><span class="line">cd fastText</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>python代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为FastText需要的格式</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line">model = fastfasttext.train_supervised(<span class="string">'train.csv'</span>, lr=<span class="number">1.0</span>, wordNgrams=<span class="number">2</span>, </span><br><span class="line">                                  verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line"></span><br><span class="line">val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.82</span></span><br></pre></td></tr></table></figure>
<p><code>fastfasttext.train_supervised</code>中的参数含义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input             <span class="comment"># training file path (required) 文件路径</span></span><br><span class="line">lr                <span class="comment"># learning rate [0.1]	学习率</span></span><br><span class="line">dim               <span class="comment"># size of word vectors [100] 向量维度</span></span><br><span class="line">ws                <span class="comment"># size of the context window [5] 上下文窗口的大小</span></span><br><span class="line">epoch             <span class="comment"># number of epochs [5] 迭代次数</span></span><br><span class="line">minCount          <span class="comment"># minimal number of word occurences [1] 词出现的最少次数</span></span><br><span class="line">minCountLabel     <span class="comment"># minimal number of label occurences [1] 标签出现的最少次数</span></span><br><span class="line">minn              <span class="comment"># min length of char ngram [0] char ngram的最小长度</span></span><br><span class="line">maxn              <span class="comment"># max length of char ngram [0] char ngram的最大长度</span></span><br><span class="line">neg               <span class="comment"># number of negatives sampled [5] 负样本的个数</span></span><br><span class="line">wordNgrams        <span class="comment"># max length of word ngram [1] ngram的最大长度</span></span><br><span class="line">loss              <span class="comment"># loss function &#123;ns, hs, softmax, ova&#125; [softmax] 损失函数</span></span><br><span class="line">bucket            <span class="comment"># number of buckets [2000000] 桶的个数</span></span><br><span class="line">thread            <span class="comment"># number of threads [number of cpus] 线程个数</span></span><br><span class="line">lrUpdateRate      <span class="comment"># change the rate of updates for the learning rate [100] 更改学习速率的更新速率</span></span><br><span class="line">t                 <span class="comment"># sampling threshold [0.0001] 抽样阈值</span></span><br><span class="line">label             <span class="comment"># label prefix ['__label__'] 标签前缀</span></span><br><span class="line">verbose           <span class="comment"># verbose [2]</span></span><br><span class="line">pretrainedVectors <span class="comment"># pretrained word vectors (.vec file) for supervised learning []</span></span><br></pre></td></tr></table></figure>
<p>下面稍微调整了下参数，学习率取[1.1, 1.2, 1.3, 1.4, ,1.5]，wordNgrams取[1,2,3]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>]:</span><br><span class="line">    print(<span class="string">"Current lr is: "</span>, lr)</span><br><span class="line">    <span class="keyword">for</span> wordNGram <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">"Current wordNgrams is:"</span>, wordNGram)</span><br><span class="line">        model = fasttext.train_supervised(<span class="string">'train.csv'</span>, lr=lr, wordNgrams=wordNGram, </span><br><span class="line">                              verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line">        val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">        print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>
<p>通过简单的调参，发现wordNgrams=3，lr=(1.4，1.5)效果比较好。</p>
<h3 id="基于深度学习的文本分类2"><a href="#基于深度学习的文本分类2" class="headerlink" title="基于深度学习的文本分类2"></a>基于深度学习的文本分类2</h3><p><strong>Word2Vec</strong></p>
<p>主要思路：通过单词和上下文彼此预测，对应的两个算法分布为：</p>
<ul>
<li><p>Skip-grams (SG)：通过给定Input word来预测上下文</p>
</li>
<li><p>Continuous Bag of Words (CBOW)：通过给定上下文来预测目标单词</p>
</li>
</ul>
<h5 id="1、Skip-grams原理和网络结构"><a href="#1、Skip-grams原理和网络结构" class="headerlink" title="1、Skip-grams原理和网络结构"></a>1、Skip-grams原理和网络结构</h5><p><img src="https://img-blog.csdnimg.cn/20200714210354729.png" alt="skip_grams" style="zoom: 33%;" /></p>
<p>Word2Vec模型实际上分为了两个部分，第一部分为建立模型，第二部分是通过模型获取嵌入词向量。</p>
<p>Word2Vec的整个建模过程实际上与自编码器（auto-encoder）的思想很相似，即先基于训练数据构建一个神经网络，当这个模型训练好以后，我们并不会用这个训练好的模型处理新的任务，我们真正需要的是这个模型通过训练数据所学得的参数，例如隐层的权重矩阵——后面我们将会看到这些权重在Word2Vec中实际上就是我们试图去学习的“word vectors”。</p>
<p>Skip-grams过程</p>
<p>假如我们有一个句子“The dog barked at the mailman”。</p>
<ol>
<li><p>首先我们选句子中间的一个词作为我们的输入词，例如我们选取“dog”作为input word；</p>
</li>
<li><p>有了input word以后，我们再定义一个叫做skip_window的参数，它代表着我们从当前input word的一侧（左边或右边）选取词的数量。如果我们设置skip_window=2，那么我们最终获得窗口中的词（包括input word在内）就是[‘The’, ‘dog’，’barked’, ‘at’]。skip_window=2代表着选取左input word左侧2个词和右侧2个词进入我们的窗口，所以整个窗口大小span=2x2=4。另一个参数叫num_skips，它代表着我们从整个窗口中选取多少个不同的词作为我们的output word，当skip_window=2，num_skips=2时，我们将会得到两组 (input word, output word) 形式的训练数据，即 (‘dog’, ‘barked’)，(‘dog’, ‘the’)。</p>
</li>
<li><p>神经网络基于这些训练数据将会输出一个概率分布，这个概率代表着我们的词典中的每个词作为input word的output word的可能性。这句话有点绕，我们来看个例子。第二步中我们在设置skip_window和num_skips=2的情况下获得了两组训练数据。假如我们先拿一组数据 (‘dog’, ‘barked’) 来训练神经网络，那么模型通过学习这个训练样本，会告诉我们词汇表中每个单词当’dog’作为input word时，其作为output word的可能性。</p>
</li>
</ol>
<p>也就是说模型的输出概率代表着到我们词典中每个词有多大可能性跟input word同时出现。例如：如果我们向神经网络模型中输入一个单词“Soviet“，那么最终模型的输出概率中，像“Union”， ”Russia“这种相关词的概率将远高于像”watermelon“，”kangaroo“非相关词的概率。因为”Union“，”Russia“在文本中更大可能在”Soviet“的窗口中出现。</p>
<p>我们将通过给神经网络输入文本中成对的单词来训练它完成上面所说的概率计算。下面的图中给出了一些我们训练样本的例子。我们选定句子“The quick brown fox jumps over lazy dog”，设定我们的窗口大小为2（window_size=2），也就是说我们仅选输入词前后各两个词和输入词进行组合。下图中，蓝色代表input word，方框内代表位于窗口内的单词。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom:40%;" /></p>
<p><img src="https://img-blog.csdnimg.cn/20200714210519939.png" alt="2" style="zoom: 40%;" /></p>
<p>我们的模型将会从每对单词出现的次数中习得统计结果。例如，我们的神经网络可能会得到更多类似（“Soviet“，”Union“）这样的训练样本对，而对于（”Soviet“，”Sasquatch“）这样的组合却看到的很少。因此，当我们的模型完成训练后，给定一个单词”Soviet“作为输入，输出的结果中”Union“或者”Russia“要比”Sasquatch“被赋予更高的概率。</p>
<p>PS：input word和output word都会被我们进行one-hot编码。仔细想一下，我们的输入被one-hot编码以后大多数维度上都是0（实际上仅有一个位置为1），所以这个向量相当稀疏，那么会造成什么结果呢。如果我们将一个1 x 10000的向量和10000 x 300的矩阵相乘，它会消耗相当大的计算资源，为了高效计算，它仅仅会选择矩阵中对应的向量中维度值为1的索引行：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205344406.png" alt=""></p>
<p><strong>2. Skip-grams训练</strong></p>
<p>由上部分可知，Word2Vec模型是一个超级大的神经网络（权重矩阵规模非常大）。例如：我们拥有10000个单词的词汇表，我们如果想嵌入300维的词向量，那么我们的输入-隐层权重矩阵和隐层-输出层的权重矩阵都会有 10000 x 300 = 300万个权重，在如此庞大的神经网络中进行梯度下降是相当慢的。更糟糕的是，你需要大量的训练数据来调整这些权重并且避免过拟合。百万数量级的权重矩阵和亿万数量级的训练样本意味着训练这个模型将会是个灾难</p>
<p>解决方案：</p>
<ul>
<li><p>将常见的单词组合（word pairs）或者词组作为单个“words”来处理</p>
</li>
<li><p>对高频次单词进行抽样来减少训练样本的个数</p>
</li>
<li><p>对优化目标采用“negative sampling”方法，这样每个训练样本的训练只会更新一小部分的模型权重，从而降低计算负担</p>
</li>
</ul>
<p><em>2.1 Word pairs and “phases”</em></p>
<p>一些单词组合（或者词组）的含义和拆开以后具有完全不同的意义。比如“Boston Globe”是一种报刊的名字，而单独的“Boston”和“Globe”这样单个的单词却表达不出这样的含义。因此，在文章中只要出现“Boston Globe”，我们就应该把它作为一个单独的词来生成其词向量，而不是将其拆开。同样的例子还有“New York”，“United Stated”等。</p>
<p>在Google发布的模型中，它本身的训练样本中有来自Google News数据集中的1000亿的单词，但是除了单个单词以外，单词组合（或词组）又有3百万之多。</p>
<p><em>2.2 对高频词抽样</em></p>
<p>在上一部分中，对于原始文本为“The quick brown fox jumps over the laze dog”，如果使用大小为2的窗口，那么我们可以得到图中展示的那些训练样本。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom: 50%;" /></p>
<p>但是对于“the”这种常用高频单词，这样的处理方式会存在下面两个问题：</p>
<ol>
<li><p>当我们得到成对的单词训练样本时，(“fox”, “the”) 这样的训练样本并不会给我们提供关于“fox”更多的语义信息，因为“the”在每个单词的上下文中几乎都会出现</p>
</li>
<li><p>由于在文本中“the”这样的常用词出现概率很大，因此我们将会有大量的（”the“，…）这样的训练样本，而这些样本数量远远超过了我们学习“the”这个词向量所需的训练样本数</p>
</li>
</ol>
<p>Word2Vec通过“抽样”模式来解决这种高频词问题。它的基本思想如下：对于我们在训练原始文本中遇到的每一个单词，它们都有一定概率被我们从文本中删掉，而这个被删除的概率与单词的频率有关。</p>
<p>ωi 是一个单词，Z(ωi) 是 ωi 这个单词在所有语料中出现的频次，例如：如果单词“peanut”在10亿规模大小的语料中出现了1000次，那么 Z(peanut) = 1000/1000000000 = 1e - 6。</p>
<p>P(ωi) 代表着保留某个单词的概率：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205456898.png" alt=""></p>
<p><em>2.3 Negative sampling</em></p>
<p>训练一个神经网络意味着要输入训练样本并且不断调整神经元的权重，从而不断提高对目标的准确预测。每当神经网络经过一个训练样本的训练，它的权重就会进行一次调整。</p>
<p>所以，词典的大小决定了我们的Skip-Gram神经网络将会拥有大规模的权重矩阵，所有的这些权重需要通过数以亿计的训练样本来进行调整，这是非常消耗计算资源的，并且实际中训练起来会非常慢。</p>
<p>负采样（negative sampling）解决了这个问题，它是用来提高训练速度并且改善所得到词向量的质量的一种方法。不同于原本每个训练样本更新所有的权重，负采样每次让一个训练样本仅仅更新一小部分的权重，这样就会降低梯度下降过程中的计算量。</p>
<p>当我们用训练样本 ( input word: “fox”，output word: “quick”) 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的词典大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们期望输出为0的神经元结点所对应的单词我们称为“negative” word。</p>
<p>当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重。我们也会对我们的“positive” word进行权重更新（在我们上面的例子中，这个单词指的是”quick“）。</p>
<p>PS: 在论文中，作者指出指出对于小规模数据集，选择5-20个negative words会比较好，对于大规模数据集可以仅选择2-5个negative words。</p>
<p>我们使用“一元模型分布（unigram distribution）”来选择“negative words”。个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words。</p>
<p>每个单词被选为“negative words”的概率计算公式：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205545327.png" alt=""></p>
<p>其中 f(ωi)代表着单词出现的频次，而公式中开3/4的根号完全是基于经验的。</p>
<p>在代码负采样的代码实现中，unigram table有一个包含了一亿个元素的数组，这个数组是由词汇表中每个单词的索引号填充的，并且这个数组中有重复，也就是说有些单词会出现多次。那么每个单词的索引在这个数组中出现的次数该如何决定呢，有公式，也就是说计算出的负采样概率*1亿=单词在表中出现的次数。</p>
<p>有了这张表以后，每次去我们进行负采样时，只需要在0-1亿范围内生成一个随机数，然后选择表中索引号为这个随机数的那个单词作为我们的negative word即可。一个单词的负采样概率越大，那么它在这个表中出现的次数就越多，它被选中的概率就越大。</p>
<p><strong>使用gensim训练word2vec</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gensim</span>.<span class="title">models</span>.<span class="title">word2vec</span>.<span class="title">Word2Vec</span><span class="params">(sentences=None, corpus_file=None, size=<span class="number">100</span>, alpha=<span class="number">0.025</span>, window=<span class="number">5</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">min_count=<span class="number">5</span>,  max_vocab_size=None, sample=<span class="number">0.001</span>, seed=<span class="number">1</span>, workers=<span class="number">3</span>, min_alpha=<span class="number">0.0001</span>, sg=<span class="number">0</span>, hs=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">negative=<span class="number">5</span>, ns_exponent=<span class="number">0.75</span>, cbow_mean=<span class="number">1</span>, hashfxn=&lt;built-in function hash&gt;, iter=<span class="number">5</span>, null_word=<span class="number">0</span>, trim_rule=None, </span></span></span><br><span class="line"><span class="class"><span class="params">sorted_vocab=<span class="number">1</span>, batch_words=<span class="number">10000</span>, compute_loss=False, callbacks=<span class="params">()</span>, max_final_vocab=None)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>sentences</strong> (iterable of iterables, optional) – 供训练的句子，可以使用简单的列表，但是对于大语料库，建议直接从磁盘/网络流迭代传输句子。参阅word2vec模块中的BrownCorpus，Text8Corpus或LineSentence。</li>
<li><strong>corpus_file</strong> (str, optional) – LineSentence格式的语料库文件路径。</li>
<li><strong>size</strong> (int, optional) – word向量的维度。</li>
<li><strong>window</strong> (int, optional) – 一个句子中当前单词和被预测单词的最大距离。</li>
<li><strong>min_count</strong> (int, optional) – 忽略词频小于此值的单词。</li>
<li><strong>workers</strong> (int, optional) – 训练模型时使用的线程数。</li>
<li><strong>sg</strong> ({0, 1}, optional) – 模型的训练算法: 1: skip-gram; 0: CBOW.</li>
<li><strong>hs</strong> ({0, 1}, optional) – 1: 采用hierarchical softmax训练模型; 0: 使用负采样。</li>
<li><strong>negative</strong> (int, optional) – &gt; 0: 使用负采样，设置多个负采样(通常在5-20之间)。</li>
<li><strong>ns_exponent</strong> (float, optional) – 负采样分布指数。1.0样本值与频率成正比，0.0样本所有单词均等，负值更多地采样低频词。</li>
<li><strong>cbow_mean</strong> ({0, 1}, optional) – 0: 使用上下文单词向量的总和; 1: 使用均值，适用于使用CBOW。</li>
<li><strong>alpha</strong> (float, optional) – 初始学习率。</li>
<li><strong>min_alpha</strong> (float, optional) – 随着训练的进行，学习率线性下降到min_alpha。</li>
<li><strong>seed</strong> (int, optional) – 随机数发生器种子。</li>
<li><strong>max_vocab_size</strong> (int, optional) – 词汇构建期间RAM的限制; 如果有更多的独特单词，则修剪不常见的单词。 每1000万个类型的字需要大约1GB的RAM。</li>
<li><strong>max_final_vocab</strong> (int, optional) – 自动选择匹配的min_count将词汇限制为目标词汇大小。</li>
<li><strong>sample</strong> (float, optional) – 高频词随机下采样的配置阈值，范围是(0,1e-5)。</li>
<li><strong>hashfxn</strong> (function, optional) – 哈希函数用于随机初始化权重，以提高训练的可重复性。</li>
<li><strong>iter</strong> (int, optional) – 迭代次数。</li>
<li><strong>trim_rule</strong> (function, optional) – 词汇修剪规则，指定某些词语是否应保留在词汇表中，修剪掉或使用默认值处理。</li>
<li><strong>sorted_vocab</strong> ({0, 1}, optional) – 如果为1，则在分配单词索引前按降序对词汇表进行排序。</li>
<li><strong>batch_words</strong> (int, optional) – 每一个batch传递给线程单词的数量。</li>
<li><strong>compute_loss</strong> (bool, optional) – 如果为True，则计算并存储可使用get_latest_training_loss()检索的损失值。</li>
<li><strong>callbacks</strong> (iterable of CallbackAny2Vec, optional) – 在训练中特定阶段执行回调序列。</li>
</ul>
<p><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="noopener">官方文档链接</a></p>
<h5 id="2、TextCNN"><a href="#2、TextCNN" class="headerlink" title="2、TextCNN"></a>2、TextCNN</h5><p>TextCNN利用CNN（卷积神经网络）进行文本特征抽取，不同大小的卷积核分别抽取n-gram特征，卷积计算出的特征图经过MaxPooling保留最大的特征值，然后将拼接成一个向量作为文本的表示。</p>
<p>这里我们基于TextCNN原始论文的设定，分别采用了100个大小为2,3,4的卷积核，最后得到的文本向量大小为100*3=300维。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205932720.jpeg" alt=""></p>
<h5 id="3、TextRNN"><a href="#3、TextRNN" class="headerlink" title="3、TextRNN"></a>3、TextRNN</h5><p>extRNN利用RNN（循环神经网络）进行文本特征抽取，由于文本本身是一种序列，而LSTM天然适合建模序列数据。TextRNN将句子中每个词的词向量依次输入到双向双层LSTM，分别将两个方向最后一个有效位置的隐藏层拼接成一个向量作为文本的表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210806492.png" alt="5" style="zoom: 40%;" /></p>
<p>代码实现(Pytorch)：</p>
<p><strong>TextCNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">self.filter_sizes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># n-gram window</span></span><br><span class="line">self.out_channel = <span class="number">100</span></span><br><span class="line">self.convs = nn.ModuleList([nn.Conv2d(<span class="number">1</span>, self.out_channel, (filter_size, input_size), bias=<span class="literal">True</span>) <span class="keyword">for</span> filter_size <span class="keyword">in</span> self.filter_sizes])</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pooled_outputs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.filter_sizes)):</span><br><span class="line">    filter_height = sent_len - self.filter_sizes[i] + <span class="number">1</span></span><br><span class="line">    conv = self.convs[i](batch_embed)</span><br><span class="line">    hidden = F.relu(conv)  <span class="comment"># sen_num x out_channel x filter_height x 1</span></span><br><span class="line"></span><br><span class="line">    mp = nn.MaxPool2d((filter_height, <span class="number">1</span>))  <span class="comment"># (filter_height, filter_width)</span></span><br><span class="line">    <span class="comment"># sen_num x out_channel x 1 x 1 -&gt; sen_num x out_channel</span></span><br><span class="line">    pooled = mp(hidden).reshape(sen_num, self.out_channel)</span><br><span class="line">    </span><br><span class="line">    pooled_outputs.append(pooled)</span><br></pre></td></tr></table></figure>
<p><strong>TextRNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_size = config.word_dims</span><br><span class="line"></span><br><span class="line">self.word_lstm = LSTM(</span><br><span class="line">    input_size=input_size,</span><br><span class="line">    hidden_size=config.word_hidden_size,</span><br><span class="line">    num_layers=config.word_num_layers,</span><br><span class="line">    batch_first=<span class="literal">True</span>,</span><br><span class="line">    bidirectional=<span class="literal">True</span>,</span><br><span class="line">    dropout_in=config.dropout_input,</span><br><span class="line">    dropout_out=config.dropout_hidden,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hiddens, _ = self.word_lstm(batch_embed, batch_masks)  <span class="comment"># sent_len x sen_num x hidden*2</span></span><br><span class="line">hiddens.transpose_(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># sen_num x sent_len x hidden*2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.training:</span><br><span class="line">    hiddens = drop_sequence_sharedmask(hiddens, self.dropout_mlp)</span><br></pre></td></tr></table></figure>
<h3 id="基于深度学习的文本分类3"><a href="#基于深度学习的文本分类3" class="headerlink" title="基于深度学习的文本分类3"></a>基于深度学习的文本分类3</h3><h4 id="Transformer原理"><a href="#Transformer原理" class="headerlink" title="Transformer原理"></a>Transformer原理</h4><p>Transformer是在”<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is All You Need</a>“中提出的，模型的编码部分是一组编码器的堆叠（论文中依次堆叠六个编码器），模型的解码部分是由相同数量的解码器的堆叠。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211046668.png" alt=""></p>
<p>我们重点关注编码部分。他们结构完全相同，但是并不共享参数，每一个编码器都可以拆解成两部分。在对输入序列做词的向量化之后，它们首先流过一个self-attention层，该层帮助编码器在它编码单词的时候能够看到输入序列中的其他单词。self-attention的输出流向一个前向网络（Feed Forward Neural Network），每个输入位置对应的前向网络是独立互不干扰的。最后将输出传入下一个编码器。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211115945.png" alt=""></p>
<p>这里能看到Transformer的一个关键特性，每个位置的词仅仅流过它自己的编码器路径。在self-attention层中，这些路径两两之间是相互依赖的。<strong>前向网络层则没有这些依赖性</strong>，但这些路径在流经前向网络时可以并行执行。</p>
<p>Self-Attention中使用多头机制，使得不同的attention heads所关注的的部分不同。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211153687.png" alt=""></p>
<p>编码”it”时，一个attention head集中于”the animal”，另一个head集中于“tired”，某种意义上讲，模型对“it”的表达合成了的“animal”和“tired”两者。</p>
<p>对于自注意力的详细计算，欢迎大家参考<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">Jay Alammar</a>关于Transformer的博客，这里不再展开。</p>
<p>除此之外，为了使模型保持单词的语序，模型中添加了位置编码向量。如下图所示，每行对应一个向量的位置编码。因此，第一行将是我们要添加到输入序列中第一个单词的嵌入的向量。每行包含512个值—每个值都在1到-1之间。因为左侧是用sine函数生成，右侧是用cosine生成，所以可以观察到中间显著的分隔。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211232716.png" alt=""></p>
<p>编码器结构中值得提出注意的一个细节是，在每个子层中（Self-attention, FFNN），都有残差连接，并且紧跟着<a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">layer-normalization</a>。如果我们可视化向量和LayerNorm操作，将如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211955713.png" alt=""></p>
<h4 id="基于预训练语言模型的词表示"><a href="#基于预训练语言模型的词表示" class="headerlink" title="基于预训练语言模型的词表示"></a>基于预训练语言模型的词表示</h4><p>基于预训练语言模型的词表示由于可以建模上下文信息，进而解决传统静态词向量不能建模“一词多义”语言现象的问题。最早提出的ELMo基于两个单向LSTM，将从左到右和从右到左两个方向的隐藏层向量表示拼接学习上下文词嵌入。而GPT用Transformer代替LSTM作为编码器，首先进行了语言模型预训练，然后在下游任务微调模型参数。但GPT由于仅使用了单向语言模型，因此难以建模上下文信息。为了解决以上问题，研究者们提出了BERT，BERT模型结构如下图所示，它是一个基于Transformer的多层Encoder，通过执行一系列预训练，进而得到深层的上下文表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211316167.png" alt="bert_elmo"></p>
<p>ELMo论文题目中Deep是指双向双层LSTM，而更关键的在于context。传统方法生成的单词映射表的形式，即先为每个单词生成一个静态的词向量，之后这个单词的表示就被固定住了，不会跟着上下文的变化而做出改变。事实上，由于一词多义的语言现象，静态词向量是有很大的弊端的。以bank为例，如果训练语料的足够大，事先学好的词向量中混杂着所有的语义。而当下游应用时，即使在新句子中，bank的上下文里包含money等词，我们基本可以确定bank是“银行”的语义而不是在其他上下文中的“河床”的语义，但是由于静态词向量不能跟随上下文而进行变化，所以bank的表示中还是混杂着多种语义。为了解决这一问题，ELMo首先进行了语言模型预训练，然后在下游任务中动态调整Word Embedding，因此最后输出的词表示能够充分表达单词在上下文中的特定语义，进而解决一词多义的问题。</p>
<p>GPT来自于openai，是一种生成式预训练模型。GPT 除了将ELMo中的LSTM替换为Transformer 的Encoder外，更开创了NLP界基于预训练-微调的新范式。尽管GPT采用的也是和ELMo相同的两阶段模式，但GPT在第一个阶段并没有采取ELMo中使用两个单向双层LSTM拼接的结构，而是采用基于自回归式的单向语言模型。</p>
<p>Google在NAACL 2018发表的论文中提出了BERT，与GPT相同，BERT也采用了预训练-微调这一两阶段模式。但在模型结构方面，BERT采用了ELMO的范式，即使用双向语言模型代替GPT中的单向语言模型，但是BERT的作者认为ELMo使用两个单向语言模型拼接的方式太粗暴，因此在第一阶段的预训练过程中，BERT提出掩码语言模型，即类似完形填空的方式，通过上下文来预测单词本身，而不是从右到左或从左到右建模，这允许模型能够自由地编码每个层中来自两个方向的信息。而为了学习句子的词序关系，BERT将Transformer中的三角函数位置表示替换为可学习的参数，其次为了区别单句和双句输入，BERT还引入了句子类型表征。BERT的输入如图所示。此外，为了充分学习句子间的关系，BERT提出了下一个句子预测任务。具体来说，在训练时，句子对中的第二个句子有50％来自与原有的连续句子，而其余50%的句子则是通过在其他句子中随机采样。同时，消融实验也证明，这一预训练任务对句间关系判断任务具有很大的贡献。除了模型结构不同之外，BERT在预训练时使用的无标签数据规模要比GPT大的多。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211348456.png" alt="bert_input"></p>
<p>在第二阶段，与GPT相同，BERT也使用Fine-Tuning模式来微调下游任务。如下图所示，BERT与GPT不同，它极大的减少了改造下游任务的要求，只需在BERT模型的基础上，通过额外添加Linear分类器，就可以完成下游任务。具体来说，对于句间关系判断任务，与GPT类似，只需在句子之间加个分隔符，然后在两端分别加上起始和终止符号。在进行输出时，只需把句子的起始符号[CLS]在BERT最后一层中对应的位置接一个Softmax+Linear分类层即可；对于单句分类问题，也与GPT类似，只需要在句子两段分别增加起始和终止符号，输出部分和句间关系判断任务保持一致即可；对于问答任务，由于需要输出答案在给定段落的起始和终止位置，因此需要先将问题和段落按照句间关系判断任务构造输入，输出只需要在BERT最后一层中第二个句子，即段落的每个单词对应的位置上分别接判断起始和终止位置的分类器；最后，对于NLP中的序列标注问题，输入与单句分类任务一致，不同的是在BERT最后一层中每个单词对应的位置上接分类器即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211409582.png" alt="bert_task"></p>
<p>更重要的是，BERT开启了NLP领域“预训练-微调”这种两阶段的全新范式。在第一阶段首先在海量无标注文本上预训练一个双向语言模型，这里特别值得注意的是，将Transformer作为特征提取器在解决并行性和长距离依赖问题上都要领先于传统的RNN或者CNN，通过预训练的方式，可以将训练数据中的词法、句法、语法知识以网络参数的形式提炼到模型当中，在第二阶段使用下游任务的数据Fine-tuning不同层数的BERT模型参数，或者把BERT当作特征提取器生成BERT Embedding，作为新特征引入下游任务。这种两阶段的全新范式尽管是来自于计算机视觉领域，但是在自然语言处理领域一直没有得到很好的运用，而BERT作为近些年NLP突破性进展的集大成者，最大的亮点可以说不仅在于模型性能好，并且几乎所有NLP任务都可以很方便地基于BERT进行改造，进而将预训练学到的语言学知识引入下游任务，进一步提升模型的性能。</p>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA</a></li>
<li><a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/nlp%EF%BC%8C%E5%85%A5%E9%97%A8%EF%BC%8Cdatawhale/" rel="tag"># nlp，入门，datawhale</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/20/python-%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="prev" title="python-变量、运算符、数据类型及位运算">
      <i class="fa fa-chevron-left"></i> python-变量、运算符、数据类型及位运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/21/python-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" rel="next" title="条件循环结构">
      条件循环结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#赛题理解"><span class="nav-number">1.</span> <span class="nav-text">赛题理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据读取"><span class="nav-number">2.</span> <span class="nav-text">数据读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分析"><span class="nav-number">3.</span> <span class="nav-text">数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#句子长度分析"><span class="nav-number">3.1.</span> <span class="nav-text">句子长度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新闻类别分布"><span class="nav-number">3.2.</span> <span class="nav-text">新闻类别分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符分布统计"><span class="nav-number">3.3.</span> <span class="nav-text">字符分布统计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于机器学习的文本分类"><span class="nav-number">4.</span> <span class="nav-text">基于机器学习的文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#One-hot"><span class="nav-number">4.1.</span> <span class="nav-text">One-hot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bag-of-Words"><span class="nav-number">4.2.</span> <span class="nav-text">Bag of Words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TF-IDF"><span class="nav-number">4.3.</span> <span class="nav-text">TF-IDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RidgeClassifier-岭回归分类器"><span class="nav-number">4.4.</span> <span class="nav-text">RidgeClassifier(岭回归分类器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于深度学习的文本分类1"><span class="nav-number">5.</span> <span class="nav-text">基于深度学习的文本分类1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于深度学习的文本分类2"><span class="nav-number">6.</span> <span class="nav-text">基于深度学习的文本分类2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Skip-grams原理和网络结构"><span class="nav-number">6.0.1.</span> <span class="nav-text">1、Skip-grams原理和网络结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、TextCNN"><span class="nav-number">6.0.2.</span> <span class="nav-text">2、TextCNN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、TextRNN"><span class="nav-number">6.0.3.</span> <span class="nav-text">3、TextRNN</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于深度学习的文本分类3"><span class="nav-number">7.</span> <span class="nav-text">基于深度学习的文本分类3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Transformer原理"><span class="nav-number">7.1.</span> <span class="nav-text">Transformer原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于预训练语言模型的词表示"><span class="nav-number">7.2.</span> <span class="nav-text">基于预训练语言模型的词表示</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">养乐多</p>
  <div class="site-description" itemprop="description">从现在开始</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">养乐多</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">105k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

