<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="赛题理解">
<meta property="og:type" content="article">
<meta property="og:title" content="零基础入门nlp-新闻文本分类实战">
<meta property="og:url" content="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Yakult">
<meta property="og:description" content="赛题理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714203836905.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714203929296.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714204856589.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714204249463.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210354729.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210458879.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210519939.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205344406.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210458879.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205456898.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205545327.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714205932720.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200714210806492.png">
<meta property="article:published_time" content="2020-07-20T14:20:02.000Z">
<meta property="article:modified_time" content="2020-07-29T07:14:43.820Z">
<meta property="article:author" content="养乐多">
<meta property="article:tag" content="nlp，入门，datawhale">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>零基础入门nlp-新闻文本分类实战 | Yakult</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yakult</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="养乐多">
      <meta itemprop="description" content="从现在开始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yakult">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          零基础入门nlp-新闻文本分类实战
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-20 22:20:02" itemprop="dateCreated datePublished" datetime="2020-07-20T22:20:02+08:00">2020-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-29 15:14:43" itemprop="dateModified" datetime="2020-07-29T15:14:43+08:00">2020-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index"><span itemprop="name">nlp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h3><a id="more"></a>
<p>&emsp;&emsp;首先要理解赛题的背景及描述——赛题以新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。通过描述，我们可以知道这道题是要==通过给定的一段文本来判断是属于哪一种类别的==。</p>
<p>&emsp;&emsp;赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。处理后的赛题训练数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">label</th>
<th style="text-align:center">text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td>
</tr>
</tbody>
</table>
</div>
<p>标签的对应关系为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;科技&#39;: 0, &#39;股票&#39;: 1, &#39;体育&#39;: 2, &#39;娱乐&#39;: 3, &#39;时政&#39;: 4, &#39;社会&#39;: 5, &#39;教育&#39;: 6, &#39;财经&#39;: 7, &#39;家居&#39;: 8, &#39;游戏&#39;: 9, &#39;房产&#39;: 10, &#39;时尚&#39;: 11, &#39;彩票&#39;: 12, &#39;星座&#39;: 13&#125;</span><br></pre></td></tr></table></figure>
<p>在接触赛题初时，对于这次比赛的评判标准要很清楚！！！</p>
<script type="math/tex; mode=display">
计算公式：2\times \frac{precision \times recall}{precision + recall}</script><p>上述公式也就是F1_score,是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的<strong>精确(precision)</strong>和<strong>召回率(recall)</strong>。F1分数可以看作是模型精确率和召回率的一种调和平均，它的最大值是1，最小值是0。这里提到了精确率和召回率，要想理解这两个还得先知道<strong>TP、FP、TN、FN</strong>这四个概念</p>
<ul>
<li>TP：True Positive ：做出Positive的判定，而且判定是正确的</li>
<li>FP：False Positive ：做出Positive的判定，而且判定是错误的</li>
<li>TN：True Negative ：做出Negative的判定，而且判定是正确的</li>
<li>FN：False Negative：错误的Negative判定，而且判断是错误的</li>
</ul>
<script type="math/tex; mode=display">
precision = \frac{TP}{TP+FP} \\
recall = \frac{TP}{TP+FN}</script><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>出题者提到数据集文件用<code>&#39;\t&#39;</code>分割，因此这样读取数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_df = pd.read_csv(<span class="string">'../input/train_set.csv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>上面图中显示的数据，进行了脱敏处理的。</p>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>我们希望通过训练集的数据，通过数据分析得出下列的结论：</p>
<ul>
<li>赛题数据中，新闻文本的长度是多少？</li>
<li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li>
<li>赛题数据中，字符分布是怎么样的？</li>
</ul>
<h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%pylab inline</span><br><span class="line">train_df[<span class="string">'text_len'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: len(x.split(<span class="string">' '</span>)))</span><br><span class="line">print(train_df[<span class="string">'text_len'</span>].describe())</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Populating the interactive namespace <span class="keyword">from</span> numpy <span class="keyword">and</span> matplotlib</span><br><span class="line">count    <span class="number">200000.000000</span></span><br><span class="line">mean        <span class="number">907.207110</span></span><br><span class="line">std         <span class="number">996.029036</span></span><br><span class="line">min           <span class="number">2.000000</span></span><br><span class="line"><span class="number">25</span>%         <span class="number">374.000000</span></span><br><span class="line"><span class="number">50</span>%         <span class="number">676.000000</span></span><br><span class="line"><span class="number">75</span>%        <span class="number">1131.000000</span></span><br><span class="line">max       <span class="number">57921.000000</span></span><br><span class="line">Name: text_len, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过上面的结果，可以看出200000个句子，每个句子平局由907个字符组成，最短的由两个字符组成，最长的达到57921个字符。</p>
<p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_ = plt.hist(train_df[<span class="string">'text_len'</span>], bins=<span class="number">200</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Text char count'</span>)</span><br><span class="line">plt.title(<span class="string">"Histogram of char count"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203836905.png" alt="task2_char_hist" style="zoom:50%;" /></p>
<h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_df[<span class="string">'label'</span>].value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">'News class count'</span>)</span><br><span class="line">plt.xlabel(<span class="string">"category"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203929296.png" alt="task2_class_hist" style="zoom:50%;" /></p>
<p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p>
<p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p>
<h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(len(word_count))</span><br><span class="line"><span class="comment"># 6869</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 7482224)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># ('3133', 1)</span></span><br></pre></td></tr></table></figure>
<p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p>
<p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">train_df[<span class="string">'text_unique'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: <span class="string">' '</span>.join(list(set(x.split(<span class="string">' '</span>)))))</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text_unique'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:int(d[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 197997)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># ('900', 197653)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># ('648', 191975)</span></span><br></pre></td></tr></table></figure>
<p>通过上述分析的总结：</p>
<ol>
<li>赛题中每个新闻包含的字符个数平均为900个，还有一些新闻字符较长；</li>
<li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li>
<li>赛题总共包括7000左右个字符；</li>
</ol>
<p>因此得出的结论：</p>
<ol>
<li><p>每个新闻平均字符个数较多，可能需要截断；</p>
</li>
<li><p>由于类别不均衡，会严重影响模型的精度；</p>
</li>
</ol>
<h3 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>&emsp;&emsp;在自然语言领域，文本的长度是不确定的。文本表示成计算机能够运算的数字或向量的方法一般为词嵌入(Word Embedding)方法。词嵌入将不定长的文本转换到定长的空间去，是文本分类的第一步。</p>
<h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p>
<p>One-hot表示方法的例子如下：假设有两个句子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">句子1：我 爱 北 京 天 安 门</span><br><span class="line">句子2：我 喜 欢 上 海</span><br></pre></td></tr></table></figure>
<p>首先对所有的句子的字进行编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">'我'</span>: <span class="number">1</span>, <span class="string">'爱'</span>: <span class="number">2</span>, <span class="string">'北'</span>: <span class="number">3</span>, <span class="string">'京'</span>: <span class="number">4</span>, <span class="string">'天'</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">'安'</span>: <span class="number">6</span>, <span class="string">'门'</span>: <span class="number">7</span>, <span class="string">'喜'</span>: <span class="number">8</span>, <span class="string">'欢'</span>: <span class="number">9</span>, <span class="string">'上'</span>: <span class="number">10</span>, <span class="string">'海'</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我：[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">爱：[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">...</span><br><span class="line">海：[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</span><br></pre></td></tr></table></figure>
<h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p>
<p>直接统计每个字出现的次数，并进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">句子1：我 爱 北 京 天 安 门</span><br><span class="line">转换为 [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">句子2：我 喜 欢 上 海</span><br><span class="line">转换为 [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure>
<p>再看两句英语的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">句子1：John likes to watch movies. Mary likes too.</span><br><span class="line">转换为 [1, 2, 1, 1, 1, 0, 0, 0, 1, 1]</span><br><span class="line"></span><br><span class="line">句子2：John also likes to watch football games.</span><br><span class="line">转换为 [1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>
<p>不过这种表示方法有个缺点，<strong>在构造文档向量的过程中可以看到，我们并没有表达单词在原来句子中出现的顺序。</strong></p>
<p>下面来看一个用sklearn实现的例子：</p>
<p>安装sklearn库一句话就搞定了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># array([[0, 1, 1, 1, 0, 0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [0, 2, 0, 1, 0, 1, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [1, 0, 0, 1, 1, 0, 1, 1, 1],</span></span><br><span class="line"><span class="comment">#        [0, 1, 1, 1, 0, 0, 1, 0, 1]], dtype=int64)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountVectorizer(*, input=<span class="string">'content'</span>, encoding=<span class="string">'utf-8'</span>, decode_error=<span class="string">'strict'</span>, strip_accents=<span class="literal">None</span>, lowercase=<span class="literal">True</span>, preprocessor=<span class="literal">None</span>, tokenizer=<span class="literal">None</span>, stop_words=<span class="literal">None</span>, token_pattern=<span class="string">'(?u)\b\w\w+\b'</span>, ngram_range=(<span class="number">1</span>, <span class="number">1</span>), analyzer=<span class="string">'word'</span>, max_df=<span class="number">1.0</span>, min_df=<span class="number">1</span>, max_features=<span class="literal">None</span>, vocabulary=<span class="literal">None</span>, binary=<span class="literal">False</span>, dtype=&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">int64</span>'&gt;)</span></span><br></pre></td></tr></table></figure>
<p>其实上面的代码也是sklearn中一贯的套路了，<strong>先创建一个类，然后把数据扔进fit_transform()</strong>，就得到结果了，只不过这里还多了一步，把结果转成了ndarray。</p>
<h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>F-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p>
<script type="math/tex; mode=display">
TF=\frac{在某一类中词条w出现的次数}{该类中所有的词条数目} \\
IDF=\log{\frac{语料库的文档总数}{包含词条w的文档数+1}}\\
TF-IDF=TF\times IDF</script><p>分母之所以要加1，是为了避免分母为0。</p>
<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line"><span class="comment"># array([[0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.6876236 , 0.        , 0.28108867, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.53864762, 0.28108867, 0.        , 0.28108867],</span></span><br><span class="line"><span class="comment">#        [0.51184851, 0.        , 0.        , 0.26710379, 0.51184851,</span></span><br><span class="line"><span class="comment">#         0.        , 0.26710379, 0.51184851, 0.26710379],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524]])</span></span><br></pre></td></tr></table></figure>
<p>跟CountVectors的代码几乎一样就是CountVectorizer()变成了TfidfVectorizer()。</p>
<h4 id="RidgeClassifier-岭回归分类器"><a href="#RidgeClassifier-岭回归分类器" class="headerlink" title="RidgeClassifier(岭回归分类器)"></a>RidgeClassifier(岭回归分类器)</h4><p>&emsp;&emsp;简单介绍下，因为后面有用到分类。简单理解就跟LogisticRegression差不太多，把他们看成相似的作用就行了，细节就不过多说。</p>
<p>&emsp;&emsp;这个分类器有时被称为带有线性核的最小二乘支持向量机。该分类器首先将二进制目标转换为{- 1,1}，然后将该问题视为回归任务，优化与上面相同的目标。预测类对应于回归预测的符号，对于多类分类，将问题视为多输出回归，预测类对应的输出值最大。该分类器使用(惩罚)最小二乘损失来适应分类模型，而不是使用更传统的逻辑或铰链损失(最大边界损失)，在实践中，所有这些模型在准确性或精度/召回率方面都可能导致类似的交叉验证分数，而RidgeClassifier使用的惩罚最小二乘损失允许对具有不同计算性能概要的数值求解器进行各自不同的选择。</p>
<p>接下来我们将对比不同文本表示算法的精度，通过代码本地构建验证集计算F1得分。使用sklearn库中的函数实现。</p>
<p><strong>Count Vectors + RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">vectorizer = CountVectorizer(max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = vectorizer.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.74</span></span><br></pre></td></tr></table></figure>
<p><strong>TF-IDF +  RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">tfidf = TfidfVectorizer(ngram_range=(<span class="number">1</span>,<span class="number">3</span>), max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = tfidf.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.87</span></span><br></pre></td></tr></table></figure>
<h3 id="基于深度学习的文本分类1"><a href="#基于深度学习的文本分类1" class="headerlink" title="基于深度学习的文本分类1"></a>基于深度学习的文本分类1</h3><p><strong>FastText</strong></p>
<p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p>
<p>优点：使用Embedding能提高计算的效率。</p>
<p>如下图所示，FastText是一个三层的神经网络，输入层、隐藏层和输出层。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204856589.png" alt="fast_text" style="zoom: 25%;" /></p>
<p>下图是使用keras实现的FastText网络结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204249463.jpg" alt="keras_fasttext"  /></p>
<p>FastText安装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、pip安装</span></span><br><span class="line">pip install fasttext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、源码安装</span></span><br><span class="line">git clone https://github.com/facebookresearch/fastText.git</span><br><span class="line">cd fastText</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>python代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为FastText需要的格式</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line">model = fastfasttext.train_supervised(<span class="string">'train.csv'</span>, lr=<span class="number">1.0</span>, wordNgrams=<span class="number">2</span>, </span><br><span class="line">                                  verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line"></span><br><span class="line">val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.82</span></span><br></pre></td></tr></table></figure>
<p><code>fastfasttext.train_supervised</code>中的参数含义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input             <span class="comment"># training file path (required) 文件路径</span></span><br><span class="line">lr                <span class="comment"># learning rate [0.1]	学习率</span></span><br><span class="line">dim               <span class="comment"># size of word vectors [100] 向量维度</span></span><br><span class="line">ws                <span class="comment"># size of the context window [5] 上下文窗口的大小</span></span><br><span class="line">epoch             <span class="comment"># number of epochs [5] 迭代次数</span></span><br><span class="line">minCount          <span class="comment"># minimal number of word occurences [1] 词出现的最少次数</span></span><br><span class="line">minCountLabel     <span class="comment"># minimal number of label occurences [1] 标签出现的最少次数</span></span><br><span class="line">minn              <span class="comment"># min length of char ngram [0] char ngram的最小长度</span></span><br><span class="line">maxn              <span class="comment"># max length of char ngram [0] char ngram的最大长度</span></span><br><span class="line">neg               <span class="comment"># number of negatives sampled [5] 负样本的个数</span></span><br><span class="line">wordNgrams        <span class="comment"># max length of word ngram [1] ngram的最大长度</span></span><br><span class="line">loss              <span class="comment"># loss function &#123;ns, hs, softmax, ova&#125; [softmax] 损失函数</span></span><br><span class="line">bucket            <span class="comment"># number of buckets [2000000] 桶的个数</span></span><br><span class="line">thread            <span class="comment"># number of threads [number of cpus] 线程个数</span></span><br><span class="line">lrUpdateRate      <span class="comment"># change the rate of updates for the learning rate [100] 更改学习速率的更新速率</span></span><br><span class="line">t                 <span class="comment"># sampling threshold [0.0001] 抽样阈值</span></span><br><span class="line">label             <span class="comment"># label prefix ['__label__'] 标签前缀</span></span><br><span class="line">verbose           <span class="comment"># verbose [2]</span></span><br><span class="line">pretrainedVectors <span class="comment"># pretrained word vectors (.vec file) for supervised learning []</span></span><br></pre></td></tr></table></figure>
<p>下面稍微调整了下参数，学习率取[1.1, 1.2, 1.3, 1.4, ,1.5]，wordNgrams取[1,2,3]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>]:</span><br><span class="line">    print(<span class="string">"Current lr is: "</span>, lr)</span><br><span class="line">    <span class="keyword">for</span> wordNGram <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">"Current wordNgrams is:"</span>, wordNGram)</span><br><span class="line">        model = fasttext.train_supervised(<span class="string">'train.csv'</span>, lr=lr, wordNgrams=wordNGram, </span><br><span class="line">                              verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line">        val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">        print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>
<p>通过简单的调参，发现wordNgrams=3，lr=(1.4，1.5)效果比较好。</p>
<h3 id="基于深度学习的文本分类2"><a href="#基于深度学习的文本分类2" class="headerlink" title="基于深度学习的文本分类2"></a>基于深度学习的文本分类2</h3><p><strong>Word2Vec</strong></p>
<p>主要思路：通过单词和上下文彼此预测，对应的两个算法分布为：</p>
<ul>
<li><p>Skip-grams (SG)：通过给定Input word来预测上下文</p>
</li>
<li><p>Continuous Bag of Words (CBOW)：通过给定上下文来预测目标单词</p>
</li>
</ul>
<h5 id="1、Skip-grams原理和网络结构"><a href="#1、Skip-grams原理和网络结构" class="headerlink" title="1、Skip-grams原理和网络结构"></a>1、Skip-grams原理和网络结构</h5><p><img src="https://img-blog.csdnimg.cn/20200714210354729.png" alt="skip_grams" style="zoom: 33%;" /></p>
<p>Word2Vec模型实际上分为了两个部分，第一部分为建立模型，第二部分是通过模型获取嵌入词向量。</p>
<p>Word2Vec的整个建模过程实际上与自编码器（auto-encoder）的思想很相似，即先基于训练数据构建一个神经网络，当这个模型训练好以后，我们并不会用这个训练好的模型处理新的任务，我们真正需要的是这个模型通过训练数据所学得的参数，例如隐层的权重矩阵——后面我们将会看到这些权重在Word2Vec中实际上就是我们试图去学习的“word vectors”。</p>
<p>Skip-grams过程</p>
<p>假如我们有一个句子“The dog barked at the mailman”。</p>
<ol>
<li><p>首先我们选句子中间的一个词作为我们的输入词，例如我们选取“dog”作为input word；</p>
</li>
<li><p>有了input word以后，我们再定义一个叫做skip_window的参数，它代表着我们从当前input word的一侧（左边或右边）选取词的数量。如果我们设置skip_window=2，那么我们最终获得窗口中的词（包括input word在内）就是[‘The’, ‘dog’，’barked’, ‘at’]。skip_window=2代表着选取左input word左侧2个词和右侧2个词进入我们的窗口，所以整个窗口大小span=2x2=4。另一个参数叫num_skips，它代表着我们从整个窗口中选取多少个不同的词作为我们的output word，当skip_window=2，num_skips=2时，我们将会得到两组 (input word, output word) 形式的训练数据，即 (‘dog’, ‘barked’)，(‘dog’, ‘the’)。</p>
</li>
<li><p>神经网络基于这些训练数据将会输出一个概率分布，这个概率代表着我们的词典中的每个词作为input word的output word的可能性。这句话有点绕，我们来看个例子。第二步中我们在设置skip_window和num_skips=2的情况下获得了两组训练数据。假如我们先拿一组数据 (‘dog’, ‘barked’) 来训练神经网络，那么模型通过学习这个训练样本，会告诉我们词汇表中每个单词当’dog’作为input word时，其作为output word的可能性。</p>
</li>
</ol>
<p>也就是说模型的输出概率代表着到我们词典中每个词有多大可能性跟input word同时出现。例如：如果我们向神经网络模型中输入一个单词“Soviet“，那么最终模型的输出概率中，像“Union”， ”Russia“这种相关词的概率将远高于像”watermelon“，”kangaroo“非相关词的概率。因为”Union“，”Russia“在文本中更大可能在”Soviet“的窗口中出现。</p>
<p>我们将通过给神经网络输入文本中成对的单词来训练它完成上面所说的概率计算。下面的图中给出了一些我们训练样本的例子。我们选定句子“The quick brown fox jumps over lazy dog”，设定我们的窗口大小为2（window_size=2），也就是说我们仅选输入词前后各两个词和输入词进行组合。下图中，蓝色代表input word，方框内代表位于窗口内的单词。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom:40%;" /></p>
<p><img src="https://img-blog.csdnimg.cn/20200714210519939.png" alt="2" style="zoom: 40%;" /></p>
<p>我们的模型将会从每对单词出现的次数中习得统计结果。例如，我们的神经网络可能会得到更多类似（“Soviet“，”Union“）这样的训练样本对，而对于（”Soviet“，”Sasquatch“）这样的组合却看到的很少。因此，当我们的模型完成训练后，给定一个单词”Soviet“作为输入，输出的结果中”Union“或者”Russia“要比”Sasquatch“被赋予更高的概率。</p>
<p>PS：input word和output word都会被我们进行one-hot编码。仔细想一下，我们的输入被one-hot编码以后大多数维度上都是0（实际上仅有一个位置为1），所以这个向量相当稀疏，那么会造成什么结果呢。如果我们将一个1 x 10000的向量和10000 x 300的矩阵相乘，它会消耗相当大的计算资源，为了高效计算，它仅仅会选择矩阵中对应的向量中维度值为1的索引行：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205344406.png" alt=""></p>
<p><strong>2. Skip-grams训练</strong></p>
<p>由上部分可知，Word2Vec模型是一个超级大的神经网络（权重矩阵规模非常大）。例如：我们拥有10000个单词的词汇表，我们如果想嵌入300维的词向量，那么我们的输入-隐层权重矩阵和隐层-输出层的权重矩阵都会有 10000 x 300 = 300万个权重，在如此庞大的神经网络中进行梯度下降是相当慢的。更糟糕的是，你需要大量的训练数据来调整这些权重并且避免过拟合。百万数量级的权重矩阵和亿万数量级的训练样本意味着训练这个模型将会是个灾难</p>
<p>解决方案：</p>
<ul>
<li><p>将常见的单词组合（word pairs）或者词组作为单个“words”来处理</p>
</li>
<li><p>对高频次单词进行抽样来减少训练样本的个数</p>
</li>
<li><p>对优化目标采用“negative sampling”方法，这样每个训练样本的训练只会更新一小部分的模型权重，从而降低计算负担</p>
</li>
</ul>
<p><em>2.1 Word pairs and “phases”</em></p>
<p>一些单词组合（或者词组）的含义和拆开以后具有完全不同的意义。比如“Boston Globe”是一种报刊的名字，而单独的“Boston”和“Globe”这样单个的单词却表达不出这样的含义。因此，在文章中只要出现“Boston Globe”，我们就应该把它作为一个单独的词来生成其词向量，而不是将其拆开。同样的例子还有“New York”，“United Stated”等。</p>
<p>在Google发布的模型中，它本身的训练样本中有来自Google News数据集中的1000亿的单词，但是除了单个单词以外，单词组合（或词组）又有3百万之多。</p>
<p><em>2.2 对高频词抽样</em></p>
<p>在上一部分中，对于原始文本为“The quick brown fox jumps over the laze dog”，如果使用大小为2的窗口，那么我们可以得到图中展示的那些训练样本。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom: 50%;" /></p>
<p>但是对于“the”这种常用高频单词，这样的处理方式会存在下面两个问题：</p>
<ol>
<li><p>当我们得到成对的单词训练样本时，(“fox”, “the”) 这样的训练样本并不会给我们提供关于“fox”更多的语义信息，因为“the”在每个单词的上下文中几乎都会出现</p>
</li>
<li><p>由于在文本中“the”这样的常用词出现概率很大，因此我们将会有大量的（”the“，…）这样的训练样本，而这些样本数量远远超过了我们学习“the”这个词向量所需的训练样本数</p>
</li>
</ol>
<p>Word2Vec通过“抽样”模式来解决这种高频词问题。它的基本思想如下：对于我们在训练原始文本中遇到的每一个单词，它们都有一定概率被我们从文本中删掉，而这个被删除的概率与单词的频率有关。</p>
<p>ωi 是一个单词，Z(ωi) 是 ωi 这个单词在所有语料中出现的频次，例如：如果单词“peanut”在10亿规模大小的语料中出现了1000次，那么 Z(peanut) = 1000/1000000000 = 1e - 6。</p>
<p>P(ωi) 代表着保留某个单词的概率：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205456898.png" alt=""></p>
<p><em>2.3 Negative sampling</em></p>
<p>训练一个神经网络意味着要输入训练样本并且不断调整神经元的权重，从而不断提高对目标的准确预测。每当神经网络经过一个训练样本的训练，它的权重就会进行一次调整。</p>
<p>所以，词典的大小决定了我们的Skip-Gram神经网络将会拥有大规模的权重矩阵，所有的这些权重需要通过数以亿计的训练样本来进行调整，这是非常消耗计算资源的，并且实际中训练起来会非常慢。</p>
<p>负采样（negative sampling）解决了这个问题，它是用来提高训练速度并且改善所得到词向量的质量的一种方法。不同于原本每个训练样本更新所有的权重，负采样每次让一个训练样本仅仅更新一小部分的权重，这样就会降低梯度下降过程中的计算量。</p>
<p>当我们用训练样本 ( input word: “fox”，output word: “quick”) 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的词典大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们期望输出为0的神经元结点所对应的单词我们称为“negative” word。</p>
<p>当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重。我们也会对我们的“positive” word进行权重更新（在我们上面的例子中，这个单词指的是”quick“）。</p>
<p>PS: 在论文中，作者指出指出对于小规模数据集，选择5-20个negative words会比较好，对于大规模数据集可以仅选择2-5个negative words。</p>
<p>我们使用“一元模型分布（unigram distribution）”来选择“negative words”。个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words。</p>
<p>每个单词被选为“negative words”的概率计算公式：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205545327.png" alt=""></p>
<p>其中 f(ωi)代表着单词出现的频次，而公式中开3/4的根号完全是基于经验的。</p>
<p>在代码负采样的代码实现中，unigram table有一个包含了一亿个元素的数组，这个数组是由词汇表中每个单词的索引号填充的，并且这个数组中有重复，也就是说有些单词会出现多次。那么每个单词的索引在这个数组中出现的次数该如何决定呢，有公式，也就是说计算出的负采样概率*1亿=单词在表中出现的次数。</p>
<p>有了这张表以后，每次去我们进行负采样时，只需要在0-1亿范围内生成一个随机数，然后选择表中索引号为这个随机数的那个单词作为我们的negative word即可。一个单词的负采样概率越大，那么它在这个表中出现的次数就越多，它被选中的概率就越大。</p>
<p><strong>使用gensim训练word2vec</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gensim</span>.<span class="title">models</span>.<span class="title">word2vec</span>.<span class="title">Word2Vec</span><span class="params">(sentences=None, corpus_file=None, size=<span class="number">100</span>, alpha=<span class="number">0.025</span>, window=<span class="number">5</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">min_count=<span class="number">5</span>,  max_vocab_size=None, sample=<span class="number">0.001</span>, seed=<span class="number">1</span>, workers=<span class="number">3</span>, min_alpha=<span class="number">0.0001</span>, sg=<span class="number">0</span>, hs=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">negative=<span class="number">5</span>, ns_exponent=<span class="number">0.75</span>, cbow_mean=<span class="number">1</span>, hashfxn=&lt;built-in function hash&gt;, iter=<span class="number">5</span>, null_word=<span class="number">0</span>, trim_rule=None, </span></span></span><br><span class="line"><span class="class"><span class="params">sorted_vocab=<span class="number">1</span>, batch_words=<span class="number">10000</span>, compute_loss=False, callbacks=<span class="params">()</span>, max_final_vocab=None)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>sentences</strong> (iterable of iterables, optional) – 供训练的句子，可以使用简单的列表，但是对于大语料库，建议直接从磁盘/网络流迭代传输句子。参阅word2vec模块中的BrownCorpus，Text8Corpus或LineSentence。</li>
<li><strong>corpus_file</strong> (str, optional) – LineSentence格式的语料库文件路径。</li>
<li><strong>size</strong> (int, optional) – word向量的维度。</li>
<li><strong>window</strong> (int, optional) – 一个句子中当前单词和被预测单词的最大距离。</li>
<li><strong>min_count</strong> (int, optional) – 忽略词频小于此值的单词。</li>
<li><strong>workers</strong> (int, optional) – 训练模型时使用的线程数。</li>
<li><strong>sg</strong> ({0, 1}, optional) – 模型的训练算法: 1: skip-gram; 0: CBOW.</li>
<li><strong>hs</strong> ({0, 1}, optional) – 1: 采用hierarchical softmax训练模型; 0: 使用负采样。</li>
<li><strong>negative</strong> (int, optional) – &gt; 0: 使用负采样，设置多个负采样(通常在5-20之间)。</li>
<li><strong>ns_exponent</strong> (float, optional) – 负采样分布指数。1.0样本值与频率成正比，0.0样本所有单词均等，负值更多地采样低频词。</li>
<li><strong>cbow_mean</strong> ({0, 1}, optional) – 0: 使用上下文单词向量的总和; 1: 使用均值，适用于使用CBOW。</li>
<li><strong>alpha</strong> (float, optional) – 初始学习率。</li>
<li><strong>min_alpha</strong> (float, optional) – 随着训练的进行，学习率线性下降到min_alpha。</li>
<li><strong>seed</strong> (int, optional) – 随机数发生器种子。</li>
<li><strong>max_vocab_size</strong> (int, optional) – 词汇构建期间RAM的限制; 如果有更多的独特单词，则修剪不常见的单词。 每1000万个类型的字需要大约1GB的RAM。</li>
<li><strong>max_final_vocab</strong> (int, optional) – 自动选择匹配的min_count将词汇限制为目标词汇大小。</li>
<li><strong>sample</strong> (float, optional) – 高频词随机下采样的配置阈值，范围是(0,1e-5)。</li>
<li><strong>hashfxn</strong> (function, optional) – 哈希函数用于随机初始化权重，以提高训练的可重复性。</li>
<li><strong>iter</strong> (int, optional) – 迭代次数。</li>
<li><strong>trim_rule</strong> (function, optional) – 词汇修剪规则，指定某些词语是否应保留在词汇表中，修剪掉或使用默认值处理。</li>
<li><strong>sorted_vocab</strong> ({0, 1}, optional) – 如果为1，则在分配单词索引前按降序对词汇表进行排序。</li>
<li><strong>batch_words</strong> (int, optional) – 每一个batch传递给线程单词的数量。</li>
<li><strong>compute_loss</strong> (bool, optional) – 如果为True，则计算并存储可使用get_latest_training_loss()检索的损失值。</li>
<li><strong>callbacks</strong> (iterable of CallbackAny2Vec, optional) – 在训练中特定阶段执行回调序列。</li>
</ul>
<p><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="noopener">官方文档链接</a></p>
<h5 id="2、TextCNN"><a href="#2、TextCNN" class="headerlink" title="2、TextCNN"></a>2、TextCNN</h5><p>TextCNN利用CNN（卷积神经网络）进行文本特征抽取，不同大小的卷积核分别抽取n-gram特征，卷积计算出的特征图经过MaxPooling保留最大的特征值，然后将拼接成一个向量作为文本的表示。</p>
<p>这里我们基于TextCNN原始论文的设定，分别采用了100个大小为2,3,4的卷积核，最后得到的文本向量大小为100*3=300维。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205932720.jpeg" alt=""></p>
<h5 id="3、TextRNN"><a href="#3、TextRNN" class="headerlink" title="3、TextRNN"></a>3、TextRNN</h5><p>extRNN利用RNN（循环神经网络）进行文本特征抽取，由于文本本身是一种序列，而LSTM天然适合建模序列数据。TextRNN将句子中每个词的词向量依次输入到双向双层LSTM，分别将两个方向最后一个有效位置的隐藏层拼接成一个向量作为文本的表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210806492.png" alt="5" style="zoom: 40%;" /></p>
<p>代码实现(Pytorch)：</p>
<p><strong>TextCNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">self.filter_sizes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># n-gram window</span></span><br><span class="line">self.out_channel = <span class="number">100</span></span><br><span class="line">self.convs = nn.ModuleList([nn.Conv2d(<span class="number">1</span>, self.out_channel, (filter_size, input_size), bias=<span class="literal">True</span>) <span class="keyword">for</span> filter_size <span class="keyword">in</span> self.filter_sizes])</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pooled_outputs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.filter_sizes)):</span><br><span class="line">    filter_height = sent_len - self.filter_sizes[i] + <span class="number">1</span></span><br><span class="line">    conv = self.convs[i](batch_embed)</span><br><span class="line">    hidden = F.relu(conv)  <span class="comment"># sen_num x out_channel x filter_height x 1</span></span><br><span class="line"></span><br><span class="line">    mp = nn.MaxPool2d((filter_height, <span class="number">1</span>))  <span class="comment"># (filter_height, filter_width)</span></span><br><span class="line">    <span class="comment"># sen_num x out_channel x 1 x 1 -&gt; sen_num x out_channel</span></span><br><span class="line">    pooled = mp(hidden).reshape(sen_num, self.out_channel)</span><br><span class="line">    </span><br><span class="line">    pooled_outputs.append(pooled)</span><br></pre></td></tr></table></figure>
<p><strong>TextRNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_size = config.word_dims</span><br><span class="line"></span><br><span class="line">self.word_lstm = LSTM(</span><br><span class="line">    input_size=input_size,</span><br><span class="line">    hidden_size=config.word_hidden_size,</span><br><span class="line">    num_layers=config.word_num_layers,</span><br><span class="line">    batch_first=<span class="literal">True</span>,</span><br><span class="line">    bidirectional=<span class="literal">True</span>,</span><br><span class="line">    dropout_in=config.dropout_input,</span><br><span class="line">    dropout_out=config.dropout_hidden,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hiddens, _ = self.word_lstm(batch_embed, batch_masks)  <span class="comment"># sent_len x sen_num x hidden*2</span></span><br><span class="line">hiddens.transpose_(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># sen_num x sent_len x hidden*2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.training:</span><br><span class="line">    hiddens = drop_sequence_sharedmask(hiddens, self.dropout_mlp)</span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA</a></li>
<li><a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/nlp%EF%BC%8C%E5%85%A5%E9%97%A8%EF%BC%8Cdatawhale/" rel="tag"># nlp，入门，datawhale</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/20/python-%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="prev" title="python-变量、运算符、数据类型及位运算">
      <i class="fa fa-chevron-left"></i> python-变量、运算符、数据类型及位运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/21/python-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" rel="next" title="条件循环结构">
      条件循环结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#赛题理解"><span class="nav-number">1.</span> <span class="nav-text">赛题理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据读取"><span class="nav-number">2.</span> <span class="nav-text">数据读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分析"><span class="nav-number">3.</span> <span class="nav-text">数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#句子长度分析"><span class="nav-number">3.1.</span> <span class="nav-text">句子长度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新闻类别分布"><span class="nav-number">3.2.</span> <span class="nav-text">新闻类别分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符分布统计"><span class="nav-number">3.3.</span> <span class="nav-text">字符分布统计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于机器学习的文本分类"><span class="nav-number">4.</span> <span class="nav-text">基于机器学习的文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#One-hot"><span class="nav-number">4.1.</span> <span class="nav-text">One-hot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bag-of-Words"><span class="nav-number">4.2.</span> <span class="nav-text">Bag of Words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TF-IDF"><span class="nav-number">4.3.</span> <span class="nav-text">TF-IDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RidgeClassifier-岭回归分类器"><span class="nav-number">4.4.</span> <span class="nav-text">RidgeClassifier(岭回归分类器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于深度学习的文本分类1"><span class="nav-number">5.</span> <span class="nav-text">基于深度学习的文本分类1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于深度学习的文本分类2"><span class="nav-number">6.</span> <span class="nav-text">基于深度学习的文本分类2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Skip-grams原理和网络结构"><span class="nav-number">6.0.1.</span> <span class="nav-text">1、Skip-grams原理和网络结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、TextCNN"><span class="nav-number">6.0.2.</span> <span class="nav-text">2、TextCNN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、TextRNN"><span class="nav-number">6.0.3.</span> <span class="nav-text">3、TextRNN</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">养乐多</p>
  <div class="site-description" itemprop="description">从现在开始</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">养乐多</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">42k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">38 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

