<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python-函数与Lambda表达式</title>
    <url>/2020/07/31/python-%E5%87%BD%E6%95%B0%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><p>Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下：</p>
<ul>
<li>位置参数 (positional argument)</li>
<li>默认参数 (default argument)</li>
<li>可变参数 (variable argument)</li>
<li>关键字参数 (keyword argument)</li>
<li>命名关键字参数 (name keyword argument)</li>
<li>参数组合</li>
</ul>
<p><strong>1. 位置参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    <span class="string">"函数_文档字符串"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arg1</code> - 位置参数 ，这些参数在调用函数 (call function) 时位置要固定。</li>
</ul>
<p><strong>2. 默认参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">(arg1, arg2=v)</span>:</span></span><br><span class="line">    <span class="string">"函数_文档字符串"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arg2 = v</code> - 默认参数 = 默认值，调用函数时，默认参数的值如果没有传入，则被认为是默认值。</li>
<li>默认参数一定要放在位置参数 <b>后面</b>，不然程序会报错。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(name, age=<span class="number">8</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Name:&#123;0&#125;,Age:&#123;1&#125;'</span>.format(name, age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="string">'小马'</span>)  <span class="comment"># Name:小马,Age:8</span></span><br><span class="line">printinfo(<span class="string">'小马'</span>, <span class="number">10</span>)  <span class="comment"># Name:小马,Age:10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python 允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'Name:&#123;0&#125;,Age:&#123;1&#125;'</span>.format(name, age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(age=<span class="number">8</span>, name=<span class="string">'小马'</span>)  <span class="comment"># Name:小马,Age:8</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 可变参数</strong></p>
<p>顾名思义，可变参数就是传入的参数个数是可变的，可以是 0, 1, 2 到任意个，是不定长的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">(arg1, arg2=v, *args)</span>:</span></span><br><span class="line">    <span class="string">"函数_文档字符串"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>*args</code> - 可变参数，可以是从零个到任意个，自动组装成元组。</li>
<li>加了星号（*）的变量名会存放所有未命名的变量参数。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(arg1, *args)</span>:</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> args:</span><br><span class="line">        print(var)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">10</span>)  <span class="comment"># 10</span></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># 60</span></span><br><span class="line"><span class="comment"># 50</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">(arg1, arg2=v, *args, **kw)</span>:</span></span><br><span class="line">    <span class="string">"函数_文档字符串"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>**kw</code> - 关键字参数，可以是从零个到任意个，自动组装成字典。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(arg1, *args, **kwargs)</span>:</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>「可变参数」和「关键字参数」的同异总结如下：</p>
<ul>
<li>可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。</li>
<li>关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。</li>
</ul>
<p><strong>5. 命名关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">(arg1, arg2=v, *args, *, nkw, **kw)</span>:</span></span><br><span class="line">    <span class="string">"函数_文档字符串"</span></span><br><span class="line">    function_suite</span><br><span class="line">    <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>*, nkw</code> - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *。</li>
<li>如果要限制关键字参数的名字，就可以用「命名关键字参数」</li>
<li>使用命名关键字参数时，要特别注意不能缺少参数名。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(arg1, *, nkw, **kwargs)</span>:</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    print(nkw)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">70</span>, nkw=<span class="number">10</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2&#125;</span></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">10</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># TypeError: printinfo() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure>
<ul>
<li>没有写参数名<code>nwk</code>，因此 10 被当成「位置参数」，而原函数只有 1 个位置函数，现在调用了 2 个，因此程序会报错。</li>
</ul>
<p><strong>变量作用域</strong></p>
<ul>
<li>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</li>
<li>定义在函数内部的变量拥有局部作用域，该变量称为局部变量。</li>
<li>定义在函数外部的变量拥有全局作用域，该变量称为全局变量。</li>
<li>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discounts</span><span class="params">(price, rate)</span>:</span></span><br><span class="line">    final_price = price * rate</span><br><span class="line">    <span class="keyword">return</span> final_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">old_price = float(input(<span class="string">'请输入原价:'</span>))  <span class="comment"># 98</span></span><br><span class="line">rate = float(input(<span class="string">'请输入折扣率:'</span>))  <span class="comment"># 0.9</span></span><br><span class="line">new_price = discounts(old_price, rate)</span><br><span class="line">print(<span class="string">'打折后价格是:%.2f'</span> % new_price)  <span class="comment"># 88.20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当内部作用域想修改外部作用域的变量时，就要用到<code>global</code>和<code>nonlocal</code>关键字了。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    print(num)  <span class="comment"># 1</span></span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    print(num)  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun1()</span><br><span class="line">print(num)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>
<p><strong>内嵌函数</strong></p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'outer函数在这被调用'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'inner函数在这被调用'</span>)</span><br><span class="line"></span><br><span class="line">    inner()  <span class="comment"># 该函数只能在outer函数内部被调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"><span class="comment"># outer函数在这被调用</span></span><br><span class="line"><span class="comment"># inner函数在这被调用</span></span><br></pre></td></tr></table></figure>
<p><strong>闭包</strong></p>
<ul>
<li>是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。</li>
<li>如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。</li>
<li>通过闭包可以访问外层非全局作用域的变量，这个作用域称为 <b>闭包作用域</b>。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funX</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funY</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> funY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = funX(<span class="number">8</span>)</span><br><span class="line">print(type(i))  <span class="comment"># &lt;class 'function'&gt;</span></span><br><span class="line">print(i(<span class="number">5</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>
<p>【例子】闭包的返回值通常是函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_counter</span><span class="params">(init)</span>:</span></span><br><span class="line">    counter = [init]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">()</span>:</span> counter[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">()</span>:</span> counter[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span> <span class="keyword">return</span> counter[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">()</span>:</span> counter[<span class="number">0</span>] = init</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inc, dec, get, reset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inc, dec, get, reset = make_counter(<span class="number">0</span>)</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">inc()</span><br><span class="line">print(get())  <span class="comment"># 3</span></span><br><span class="line">dec()</span><br><span class="line">print(get())  <span class="comment"># 2</span></span><br><span class="line">reset()</span><br><span class="line">print(get())  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<p>【例子】 如果要修改闭包作用域中的变量则需要 <code>nonlocal</code> 关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num  <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
<h3 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h3><p><strong>匿名函数的定义</strong></p>
<p>在 Python 里有两类函数：</p>
<ul>
<li>第一类：用 <code>def</code> 关键词定义的正规函数</li>
<li>第二类：用 <code>lambda</code> 关键词定义的匿名函数</li>
</ul>
<p>python 使用 <code>lambda</code> 关键词来创建匿名函数，而非<code>def</code>关键词，它没有函数名，其语法结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument_list: expression</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lambda</code> - 定义匿名函数的关键词。</li>
<li><code>argument_list</code> - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。</li>
<li><code>:</code>- 冒号，在函数参数和表达式中间要加个冒号。</li>
<li><code>expression</code> - 只是一个表达式，输入函数参数，输出一些值。</li>
</ul>
<p>注意：</p>
<ul>
<li><code>expression</code> 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。</li>
<li>匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqr</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sqr)</span><br><span class="line"><span class="comment"># &lt;function sqr at 0x000000BABD3A4400&gt;</span></span><br><span class="line"></span><br><span class="line">y = [sqr(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line">lbd_sqr = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line">print(lbd_sqr)</span><br><span class="line"><span class="comment"># &lt;function &lt;lambda&gt; at 0x000000BABB6AC1E0&gt;</span></span><br><span class="line"></span><br><span class="line">y = [lbd_sqr(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sumary = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line">print(sumary(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment"># 30</span></span><br><span class="line"></span><br><span class="line">func = <span class="keyword">lambda</span> *args: sum(args)</span><br><span class="line">print(func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<p><strong>匿名函数的应用</strong></p>
<p>函数式编程 是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p>
<p>【例子】非函数式编程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x)):</span><br><span class="line">        x[i] += <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">f(x)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [11, 12, 13]</span></span><br></pre></td></tr></table></figure>
<p>【例子】函数式编程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> x:</span><br><span class="line">        y.append(item + <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">f(x)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：</p>
<ul>
<li>参数是函数 (filter, map)</li>
<li>返回值是函数 (closure)</li>
</ul>
<p>如，在 <code>filter</code>和<code>map</code>函数中的应用：</p>
<ul>
<li><code>filter(function, iterable)</code> 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <code>list()</code> 来转换。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">odd = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">templist = filter(odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(list(templist))  <span class="comment"># [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>map(function, *iterables)</code> 根据提供的函数对指定序列做映射。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m1 = map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(list(m1))  </span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line">m2 = map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">print(list(m2))  </span><br><span class="line"><span class="comment"># [3, 7, 11, 15, 19]</span></span><br></pre></td></tr></table></figure>
<p>除了 Python 这些内置函数，我们也可以自己定义高阶函数。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(fun, some_list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fun(some_list)</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(apply_to_list(sum, lst))</span><br><span class="line"><span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">print(apply_to_list(len, lst))</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">print(apply_to_list(<span class="keyword">lambda</span> x: sum(x) / len(x), lst))</span><br><span class="line"><span class="comment"># 3.0</span></span><br></pre></td></tr></table></figure>
<h3 id="3、汉诺塔问题"><a href="#3、汉诺塔问题" class="headerlink" title="3、汉诺塔问题"></a>3、汉诺塔问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n,a,b,c)</span>:</span>   <span class="comment">#n为圆盘数，a代表初始位圆柱，b代表过渡位圆柱，c代表目标位圆柱</span></span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">		print(a,<span class="string">'--&gt;'</span>,c)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		move(n<span class="number">-1</span>,a,c,b)   <span class="comment">#将初始位的n-1个圆盘移动到过渡位，此时初始位为a，上一级函数的过渡位b即为本级的目标位，上级的目标位c为本级的过渡位</span></span><br><span class="line">		print(a,<span class="string">'--&gt;'</span>,c)</span><br><span class="line"> </span><br><span class="line">		move(n<span class="number">-1</span>,b,a,c)   <span class="comment">#将过渡位的n-1个圆盘移动到目标位，此时初始位为b，上一级函数的目标位c即为本级的目标位，上级的初始位a为本级的过渡位</span></span><br></pre></td></tr></table></figure>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://mp.weixin.qq.com/s/gKhXS8JVU8dZBHJF7sIFsw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gKhXS8JVU8dZBHJF7sIFsw</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>datime模块</title>
    <url>/2020/08/04/python-datime%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>datetime 是 Python 中处理日期的标准模块，它提供了 4 种对日期和时间进行处理的类：<strong>datetime</strong>、<strong>date</strong>、<strong>time</strong> 和 <strong>timedelta</strong>。</p>
<hr>
<h2 id="1-datetime类"><a href="#1-datetime类" class="headerlink" title="1. datetime类"></a>1. datetime类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">datetime</span><span class="params">(date)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day, hour, minute, second, microsecond, tzinfo)</span></span></span><br><span class="line"><span class="function">        <span class="title">pass</span></span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">now</span><span class="params">(cls, tz=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timestamp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fromtimestamp</span><span class="params">(cls, t, tz=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">date</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">time</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">year</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hour</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isoweekday</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strftime</span><span class="params">(self, fmt)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(cls, date, time, tzinfo=True)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>datetime.now(tz=None)</code> 获取当前的日期时间，输出顺序为：年、月、日、时、分、秒、微秒。</li>
<li><code>datetime.timestamp()</code> 获取以 1970年1月1日为起点记录的秒数。</li>
<li><code>datetime.fromtimestamp(tz=None)</code> 使用 unixtimestamp 创建一个 datetime。</li>
</ul>
<p>【例子】如何创建一个 datetime 对象？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime(year=<span class="number">2020</span>, month=<span class="number">6</span>, day=<span class="number">25</span>, hour=<span class="number">11</span>, minute=<span class="number">23</span>, second=<span class="number">59</span>)</span><br><span class="line">print(dt)  <span class="comment"># 2020-06-25 11:23:59</span></span><br><span class="line">print(dt.timestamp())  <span class="comment"># 1593055439.0</span></span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.fromtimestamp(<span class="number">1593055439.0</span>)</span><br><span class="line">print(dt)  <span class="comment"># 2020-06-25 11:23:59</span></span><br><span class="line">print(type(dt)) <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.now()</span><br><span class="line">print(dt)  <span class="comment"># 2020-06-25 11:11:03.877853</span></span><br><span class="line">print(type(dt))  <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>datetime.strftime(fmt)</code> 格式化 datetime 对象。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>%a</code></td>
<td>本地简化星期名称（如星期一，返回 Mon）</td>
</tr>
<tr>
<td style="text-align:center"><code>%A</code></td>
<td>本地完整星期名称（如星期一，返回 Monday）</td>
</tr>
<tr>
<td style="text-align:center"><code>%b</code></td>
<td>本地简化的月份名称（如一月，返回 Jan）</td>
</tr>
<tr>
<td style="text-align:center"><code>%B</code></td>
<td>本地完整的月份名称（如一月，返回 January）</td>
</tr>
<tr>
<td style="text-align:center"><code>%c</code></td>
<td>本地相应的日期表示和时间表示</td>
</tr>
<tr>
<td style="text-align:center"><code>%d</code></td>
<td>月内中的一天（0-31）</td>
</tr>
<tr>
<td style="text-align:center"><code>%H</code></td>
<td>24小时制小时数（0-23）</td>
</tr>
<tr>
<td style="text-align:center"><code>%I</code></td>
<td>12小时制小时数（01-12）</td>
</tr>
<tr>
<td style="text-align:center"><code>%j</code></td>
<td>年内的一天（001-366）</td>
</tr>
<tr>
<td style="text-align:center"><code>%m</code></td>
<td>月份（01-12）</td>
</tr>
<tr>
<td style="text-align:center"><code>%M</code></td>
<td>分钟数（00-59）</td>
</tr>
<tr>
<td style="text-align:center"><code>%p</code></td>
<td>本地A.M.或P.M.的等价符</td>
</tr>
<tr>
<td style="text-align:center"><code>%S</code></td>
<td>秒（00-59）</td>
</tr>
<tr>
<td style="text-align:center"><code>%U</code></td>
<td>一年中的星期数（00-53）星期天为星期的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>%w</code></td>
<td>星期（0-6），星期天为星期的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>%W</code></td>
<td>一年中的星期数（00-53）星期一为星期的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>%x</code></td>
<td>本地相应的日期表示</td>
</tr>
<tr>
<td style="text-align:center"><code>%X</code></td>
<td>本地相应的时间表示</td>
</tr>
<tr>
<td style="text-align:center"><code>%y</code></td>
<td>两位数的年份表示（00-99）</td>
</tr>
<tr>
<td style="text-align:center"><code>%Y</code></td>
<td>四位数的年份表示（0000-9999）</td>
</tr>
<tr>
<td style="text-align:center"><code>%Z</code></td>
<td>当前时区的名称（如果是本地时间，返回空字符串）</td>
</tr>
<tr>
<td style="text-align:center"><code>%%</code></td>
<td>%号本身</td>
</tr>
</tbody>
</table>
</div>
<p>【例子】如何将 datetime 对象转换为任何格式的日期？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime(year=<span class="number">2020</span>, month=<span class="number">6</span>, day=<span class="number">25</span>, hour=<span class="number">11</span>, minute=<span class="number">51</span>, second=<span class="number">49</span>)</span><br><span class="line">s = dt.strftime(<span class="string">"'%Y/%m/%d %H:%M:%S"</span>)</span><br><span class="line">print(s)  <span class="comment"># '2020/06/25 11:51:49</span></span><br><span class="line"></span><br><span class="line">s = dt.strftime(<span class="string">'%d %B, %Y, %A'</span>)</span><br><span class="line">print(s)  <span class="comment"># 25 June, 2020, Thursday</span></span><br></pre></td></tr></table></figure>
<p>【练习】如何将给定日期转换为 “mmm-dd, YYYY” 的格式？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">d1 = datetime.date(<span class="string">'2010-09-28'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">'Sep-28,2010'</span></span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">d1 = datetime.date(<span class="number">2010</span>, <span class="number">9</span>, <span class="number">28</span>)</span><br><span class="line">print(d1.strftime(<span class="string">'%b-%d,%Y'</span>))</span><br><span class="line"><span class="comment"># Sep-28,2010</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>datetime.date()</code> Return the date part.</li>
<li><code>datetime.time()</code> Return the time part, with tzinfo None.</li>
<li><code>datetime.year</code> 年</li>
<li><code>datetime.month</code> 月</li>
<li><code>datetime.day</code> 日</li>
<li><code>datetime.hour</code> 小时</li>
<li><code>datetime.minute</code> 分钟</li>
<li><code>datetime.second</code> 秒</li>
<li><code>datetime.isoweekday</code> 星期几</li>
</ul>
<p>【例子】datetime 对象包含很多与日期时间相关的实用功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime(year=<span class="number">2020</span>, month=<span class="number">6</span>, day=<span class="number">25</span>, hour=<span class="number">11</span>, minute=<span class="number">51</span>, second=<span class="number">49</span>)</span><br><span class="line">print(dt.date())  <span class="comment"># 2020-06-25</span></span><br><span class="line">print(type(dt.date()))  <span class="comment"># &lt;class 'datetime.date'&gt;</span></span><br><span class="line">print(dt.time())  <span class="comment"># 11:51:49</span></span><br><span class="line">print(type(dt.time()))  <span class="comment"># &lt;class 'datetime.time'&gt;</span></span><br><span class="line">print(dt.year)  <span class="comment"># 2020</span></span><br><span class="line">print(dt.month)  <span class="comment"># 6</span></span><br><span class="line">print(dt.day)  <span class="comment"># 25</span></span><br><span class="line">print(dt.hour)  <span class="comment"># 11</span></span><br><span class="line">print(dt.minute)  <span class="comment"># 51</span></span><br><span class="line">print(dt.second)  <span class="comment"># 49</span></span><br><span class="line">print(dt.isoweekday())  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<p>在处理含有字符串日期的数据集或表格时，我们需要一种自动解析字符串的方法，无论它是什么格式的，都可以将其转化为 datetime 对象。这时，就要使用到 dateutil 中的 parser 模块。</p>
<ul>
<li><code>parser.parse(timestr, parserinfo=None, **kwargs)</code> </li>
</ul>
<p>【例子】如何在 python 中将字符串解析为 datetime对象？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line"></span><br><span class="line">s = <span class="string">'2020-06-25'</span></span><br><span class="line">dt = parser.parse(s)</span><br><span class="line">print(dt)  <span class="comment"># 2020-06-25 00:00:00</span></span><br><span class="line">print(type(dt))  <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'March 31, 2010, 10:51pm'</span></span><br><span class="line">dt = parser.parse(s)</span><br><span class="line">print(dt)  <span class="comment"># 2010-03-31 22:51:00</span></span><br><span class="line">print(type(dt))  <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<p>【练习】如何将字符串日期解析为 datetime 对象？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">s1 = <span class="string">"2010 Jan 1"</span></span><br><span class="line">s2 = <span class="string">'31-1-2000'</span></span><br><span class="line">s3 = <span class="string">'October10, 1996, 10:40pm'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2010</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2000</span><span class="number">-01</span><span class="number">-31</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-10</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">"2010 Jan 1"</span></span><br><span class="line">s2 = <span class="string">'31-1-2000'</span></span><br><span class="line">s3 = <span class="string">'October10, 1996, 10:40pm'</span></span><br><span class="line"></span><br><span class="line">dt1 = parser.parse(s1)</span><br><span class="line">dt2 = parser.parse(s2)</span><br><span class="line">dt3 = parser.parse(s3)</span><br><span class="line"></span><br><span class="line">print(dt1)  <span class="comment"># 2010-01-01 00:00:00</span></span><br><span class="line">print(dt2)  <span class="comment"># 2000-01-31 00:00:00</span></span><br><span class="line">print(dt3)  <span class="comment"># 1996-10-10 22:40:00</span></span><br></pre></td></tr></table></figure>
<p>【练习】计算以下列表中连续的天数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">[<span class="string">'Oct, 2, 1869'</span>, <span class="string">'Oct, 10, 1869'</span>, <span class="string">'Oct, 15, 1869'</span>, <span class="string">'Oct, 20, 1869'</span>,<span class="string">'Oct, 23, 1869'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line"></span><br><span class="line">dateString = [<span class="string">'Oct, 2, 1869'</span>, <span class="string">'Oct, 10, 1869'</span>, <span class="string">'Oct, 15, 1869'</span>, <span class="string">'Oct, 20, 1869'</span>, <span class="string">'Oct, 23, 1869'</span>]</span><br><span class="line">dates = [parser.parse(i) <span class="keyword">for</span> i <span class="keyword">in</span> dateString]</span><br><span class="line">td = np.diff(dates)</span><br><span class="line">print(td)</span><br><span class="line"><span class="comment"># [datetime.timedelta(days=8) datetime.timedelta(days=5)</span></span><br><span class="line"><span class="comment">#  datetime.timedelta(days=5) datetime.timedelta(days=3)]</span></span><br><span class="line">d = [i.days <span class="keyword">for</span> i <span class="keyword">in</span> td]</span><br><span class="line">print(d)  <span class="comment"># [8, 5, 5, 3]</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-date类"><a href="#2-date类" class="headerlink" title="2. date类"></a>2. date类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">today</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>date.today()</code> 获取当前日期信息。</li>
</ul>
<p>【例子】如何在 Python 中获取当前日期和时间？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">d = datetime.date(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">25</span>)</span><br><span class="line">print(d)  <span class="comment"># 2020-06-25</span></span><br><span class="line">print(type(d))  <span class="comment"># &lt;class 'datetime.date'&gt;</span></span><br><span class="line"></span><br><span class="line">d = datetime.date.today()</span><br><span class="line">print(d)  <span class="comment"># 2020-06-25</span></span><br><span class="line">print(type(d))  <span class="comment"># &lt;class 'datetime.date'&gt;</span></span><br></pre></td></tr></table></figure>
<p>【练习】如何统计两个日期之间有多少个星期六？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">d1 = datetime.date(<span class="number">1869</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">d2 = datetime.date(<span class="number">1869</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">d1 = datetime.date(<span class="number">1869</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">d2 = datetime.date(<span class="number">1869</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">dt = (d2 - d1).days</span><br><span class="line">print(dt)</span><br><span class="line">print(d1.isoweekday())  <span class="comment"># 6</span></span><br><span class="line">print(dt // <span class="number">7</span> + <span class="number">1</span>)  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-time类"><a href="#3-time类" class="headerlink" title="3. time类"></a>3. time类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hour, minute, second, microsecond, tzinfo)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>【例子】如何使用 datetime.time() 类？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">t = datetime.time(<span class="number">12</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">12980</span>)</span><br><span class="line">print(t)  <span class="comment"># 12:09:23.012980</span></span><br><span class="line">print(type(t))  <span class="comment"># &lt;class 'datetime.time'&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>1秒 = 1000 毫秒（milliseconds）</li>
<li>1毫秒 = 1000 微妙（microseconds）</li>
</ul>
<p>【练习】如何将给定日期转换为当天开始的时间？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">date = datetime.date(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">date = datetime.date(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">dt = datetime.datetime(date.year, date.month, date.day)</span><br><span class="line">print(dt)  <span class="comment"># 2019-10-02 00:00:00</span></span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.combine(date, datetime.time.min)</span><br><span class="line">print(dt)  <span class="comment"># 2019-10-02 00:00:00</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-timedelta类"><a href="#4-timedelta类" class="headerlink" title="4. timedelta类"></a>4. timedelta类</h2><p><code>timedelta</code> 表示具体时间实例中的一段时间。你可以把它们简单想象成两个日期或时间之间的间隔。</p>
<p>它常常被用来从 <code>datetime</code> 对象中添加或移除一段特定的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timedelta</span><span class="params">(SupportsAbs[timedelta])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, days, seconds, microseconds, milliseconds, minutes, hours, weeks,)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">days</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_seconds</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>【例子】如何使用 datetime.timedelta() 类？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">td = datetime.timedelta(days=<span class="number">30</span>)</span><br><span class="line">print(td)  <span class="comment"># 30 days, 0:00:00</span></span><br><span class="line">print(type(td))  <span class="comment"># &lt;class 'datetime.timedelta'&gt;</span></span><br><span class="line">print(datetime.date.today())  <span class="comment"># 2020-07-01</span></span><br><span class="line">print(datetime.date.today() + td)  <span class="comment"># 2020-07-31</span></span><br><span class="line"></span><br><span class="line">dt1 = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">dt2 = datetime.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">td = dt1 - dt2</span><br><span class="line">print(td)  <span class="comment"># 365 days, 0:00:00</span></span><br><span class="line">print(type(td))  <span class="comment"># &lt;class 'datetime.timedelta'&gt;</span></span><br><span class="line"></span><br><span class="line">td1 = datetime.timedelta(days=<span class="number">30</span>)  <span class="comment"># 30 days</span></span><br><span class="line">td2 = datetime.timedelta(weeks=<span class="number">1</span>)  <span class="comment"># 1 week</span></span><br><span class="line">td = td1 - td2</span><br><span class="line">print(td)  <span class="comment"># 23 days, 0:00:00</span></span><br><span class="line">print(type(td))  <span class="comment"># &lt;class 'datetime.timedelta'&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果将两个 datetime 对象相减，就会得到表示该时间间隔的 timedelta 对象。</p>
<p>同样地，将两个时间间隔相减，可以得到另一个 timedelta 对象。</p>
<p>【练习】</p>
<ol>
<li>距离你出生那天过去多少天了？</li>
<li>距离你今年的下一个生日还有多少天？</li>
<li>将距离你今年的下一个生日的天数转换为秒数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入</span></span><br><span class="line">bday = <span class="string">'Oct 2, 1969'</span></span><br></pre></td></tr></table></figure>
<p>【参考答案】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">bDay = <span class="string">'Oct 2, 1969'</span></span><br><span class="line">dt1 = parser.parse(bDay).date()</span><br><span class="line">dt2 = datetime.date.today()</span><br><span class="line">dt3 = datetime.date(dt2.year, dt1.month, dt1.day)</span><br><span class="line">print(dt1)  <span class="comment"># 1969-10-02</span></span><br><span class="line">print(dt2)  <span class="comment"># 2020-07-01</span></span><br><span class="line">print(dt3)  <span class="comment"># 2020-10-02</span></span><br><span class="line"></span><br><span class="line">td = dt2 - dt1</span><br><span class="line">print(td.days)  <span class="comment"># 18535</span></span><br><span class="line">td = dt3 - dt2</span><br><span class="line">print(td.days)  <span class="comment"># 93</span></span><br><span class="line">print(td.days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>)  <span class="comment"># 8035200</span></span><br><span class="line">print(td.total_seconds())  <span class="comment"># 8035200.0</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>练习题</strong>：</p>
<p>1、假设你获取了用户输入的日期和时间如<code>2020-1-21 9:01:30</code>，以及一个时区信息如<code>UTC+5:00</code>，均是<code>str</code>，请编写一个函数将其转换为timestamp：</p>
<p>题目说明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Input file</span></span><br><span class="line"><span class="string">example1: dt_str='2020-6-1 08:10:30', tz_str='UTC+7:00'</span></span><br><span class="line"><span class="string">example2: dt_str='2020-5-31 16:10:30', tz_str='UTC-09:00'</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Output file</span></span><br><span class="line"><span class="string">result1: 1590973830.0</span></span><br><span class="line"><span class="string">result2: 1590973830.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_timestamp</span><span class="params">(dt_str, tz_str)</span>:</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>2、编写Python程序以选择指定年份的所有星期日。</p>
<p>题目说明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Input file</span></span><br><span class="line"><span class="string">   2020</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Output file</span></span><br><span class="line"><span class="string">   2020-01-05                         </span></span><br><span class="line"><span class="string">   2020-01-12              </span></span><br><span class="line"><span class="string">   2020-01-19                </span></span><br><span class="line"><span class="string">   2020-01-26               </span></span><br><span class="line"><span class="string">   2020-02-02     </span></span><br><span class="line"><span class="string">   -----</span></span><br><span class="line"><span class="string">   2020-12-06               </span></span><br><span class="line"><span class="string">   2020-12-13                </span></span><br><span class="line"><span class="string">   2020-12-20                </span></span><br><span class="line"><span class="string">   2020-12-27 </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_sundays</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>python-列表，元组，字符串</title>
    <url>/2020/07/22/python-%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="Python一些数据类型"><a href="#Python一些数据类型" class="headerlink" title="Python一些数据类型"></a>Python一些数据类型</h3><p>整型<code>&lt;class &#39;int&#39;&gt;</code>&emsp;浮点型<code>&lt;class &#39;float&#39;&gt;</code>&emsp;布尔型<code>&lt;class &#39;bool&#39;&gt;</code></p>
<p>列表<code>&lt;class &#39;list&#39;&gt;</code>&emsp;元组<code>&lt;class &#39;tuple&#39;&gt;</code>&emsp;字典<code>&lt;class &#39;dict&#39;&gt;</code>&emsp;集合<code>&lt;class &#39;set&#39;&gt;</code>&emsp;字符串<code>&lt;class &#39;str&#39;&gt;</code></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p>
<h4 id="创建一个列表"><a href="#创建一个列表" class="headerlink" title="创建一个列表"></a>创建一个列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</span><br><span class="line">print(x, type(x))</span><br><span class="line"><span class="comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">print(x, type(x))</span><br><span class="line"><span class="comment"># [2, 3, 4, 5, 6, 7] &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用`range()`创建列表</span></span><br><span class="line">x = list(range(<span class="number">10</span>))</span><br><span class="line">print(x, type(x))</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用推导式创建列表</span></span><br><span class="line">x = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"><span class="comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p>
<p>列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p>
<h4 id="向列表中添加元素"><a href="#向列表中添加元素" class="headerlink" title="向列表中添加元素"></a>向列表中添加元素</h4><ul>
<li><p><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</span><br><span class="line">x.append(<span class="string">'Thursday'</span>)</span><br><span class="line">print(x)  </span><br><span class="line"><span class="comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday']</span></span><br><span class="line"></span><br><span class="line">print(len(x))  <span class="comment"># 6此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意`append()`和`extend()`的区别。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</span><br><span class="line">x.append([<span class="string">'Thursday'</span>, <span class="string">'Sunday'</span>])</span><br><span class="line">print(x)  </span><br><span class="line"><span class="comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', ['Thursday', 'Sunday']]</span></span><br><span class="line"></span><br><span class="line">print(len(x))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</span><br><span class="line">x.extend([<span class="string">'Thursday'</span>, <span class="string">'Sunday'</span>])</span><br><span class="line">print(x)  </span><br><span class="line"><span class="comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday', 'Sunday']</span></span><br><span class="line"></span><br><span class="line">print(len(x))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p>
<ul>
<li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置前插入 <code>obj</code>。</li>
<li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li>
<li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li>
<li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li>
<li><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</li>
<li><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code> 反向列表中元素</li>
<li><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、列表操作练习</p>
<p>列表lst 内容如下</p>
<p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p>
<p>请写程序完成下列操作：</p>
<ol>
<li>在列表的末尾增加元素15</li>
<li>在列表的中间位置插入元素20</li>
<li>将列表[2, 5, 6]合并到lst中</li>
<li>移除列表中索引为3的元素</li>
<li>翻转列表里的所有元素</li>
<li>对列表里的元素进行排序，从小到大一次，从大到小一次</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line">lst.append(<span class="number">15</span>)</span><br><span class="line">lst.insert(len(lst)//<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">lst.extend([<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="keyword">del</span> lst[<span class="number">3</span>]</span><br><span class="line">lst.reverse()</span><br><span class="line">x.sort()</span><br><span class="line">x.sort(reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>2、修改列表</p>
<p>问题描述：</p>
<p>lst = [1, [4, 6], True]</p>
<p>请将列表里所有数字修改成原来的两倍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(lst):</span><br><span class="line">        <span class="keyword">if</span> isinstance(value, bool):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, (int, float)):</span><br><span class="line">            lst[index] =  lst[index] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, list):</span><br><span class="line">            fun(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    l = [<span class="number">1</span>, [<span class="number">4</span>, <span class="number">6</span>], <span class="literal">True</span>]</span><br><span class="line">    fun(l)</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure>
<p>3、leetcode 852题 <a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">山脉数组的峰顶索引</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线性查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        lo, hi = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (hi - lo) / <span class="number">2</span> + lo</span><br><span class="line">            <span class="keyword">if</span> A[mi] &lt; A[mi + <span class="number">1</span>]:</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<p>「元组」定义语法为：<code>(元素1, 元素2, ..., 元素n)</code></p>
<ul>
<li>小括号把所有元素绑在一起</li>
<li>逗号将每个元素一一分开</li>
</ul>
<h3 id="创建和访问一个元组"><a href="#创建和访问一个元组" class="headerlink" title="创建和访问一个元组"></a>创建和访问一个元组</h3><ul>
<li>Python 的元组与列表类似，不同之处在于tuple被创建后就不能对其进行修改</li>
<li>元组使用小括号，列表使用方括号。</li>
<li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没加逗号，被解释成了int类型</span></span><br><span class="line">temp = (<span class="number">1</span>)</span><br><span class="line">print(type(temp))  <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了逗号，解释成了元组</span></span><br><span class="line">temp = (<span class="number">1</span>,)</span><br><span class="line">print(type(temp))  <span class="comment"># &lt;class 'tuple'&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">8</span> * (<span class="number">8</span>))  <span class="comment"># 64</span></span><br><span class="line">print(<span class="number">8</span> * (<span class="number">8</span>,))  <span class="comment"># (8, 8, 8, 8, 8, 8, 8, 8)</span></span><br></pre></td></tr></table></figure>
<h3 id="更新和删除一个元组"><a href="#更新和删除一个元组" class="headerlink" title="更新和删除一个元组"></a>更新和删除一个元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">week = (<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>)</span><br><span class="line">week = week[:<span class="number">2</span>] + (<span class="string">'Wednesday'</span>,) + week[<span class="number">2</span>:]</span><br><span class="line">print(week)  <span class="comment"># ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday')</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(t1)  <span class="comment"># (1, 2, 3, [4, 5, 6])</span></span><br><span class="line"></span><br><span class="line">t1[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">print(t1)  <span class="comment"># (1, 2, 3, [9, 5, 6])</span></span><br></pre></td></tr></table></figure>
<h3 id="元组的相关操作符"><a href="#元组的相关操作符" class="headerlink" title="元组的相关操作符"></a>元组的相关操作符</h3><p>元组拼接有两种方式，用加号+，和乘号*。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = <span class="string">"Hello"</span></span><br><span class="line">t2 = <span class="string">"wordl!"</span></span><br><span class="line">t3 = t1 + t2</span><br><span class="line">print(t3)</span><br><span class="line"><span class="comment"># Hello world!</span></span><br><span class="line">t4 = t1 * <span class="number">2</span></span><br><span class="line">print(t4)</span><br><span class="line"><span class="comment"># Hello Hello</span></span><br></pre></td></tr></table></figure>
<h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><p>元组只有两种内置方法：</p>
<ul>
<li><code>count(x)</code> 是记录在元组 <code>t</code> 中该元素出现几次</li>
<li><code>index(x)</code> 是找到该元素在元组 <code>t</code> 的索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">10.31</span>, <span class="string">'python'</span>)</span><br><span class="line">print(t.count(<span class="string">'python'</span>))  <span class="comment"># 1</span></span><br><span class="line">print(t.index(<span class="number">10.31</span>))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h3 id="解压元组"><a href="#解压元组" class="headerlink" title="解压元组"></a>解压元组</h3><p>如果你只想要元组其中几个元素，用通配符「*」，英文叫 wildcard，在计算机语言中代表一个或多个元素。下例就是把多个元素丢给了 <code>rest</code> 变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, *rest, c = t</span><br><span class="line">print(a, b, c)  <span class="comment"># 1 2 5</span></span><br><span class="line">print(rest)  <span class="comment"># [3, 4]</span></span><br></pre></td></tr></table></figure>
<p>如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, *_ = t</span><br><span class="line">print(a, b)  <span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><ul>
<li>Python支持使用成对的单引号<code>&#39;&#39;</code>或者双引号<code>&quot;&quot;</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = <span class="string">'I love Python!'</span></span><br><span class="line">print(t1, type(t1))</span><br><span class="line"><span class="comment"># I love Python! &lt;class 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">t2 = <span class="string">"I love Python!"</span></span><br><span class="line">print(t2, type(t2))</span><br><span class="line"><span class="comment"># I love Python! &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果字符串中需要出现单引号或双引号，可以使用转义符号<code>\</code>对字符串中的符号进行转义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'let\'s go'</span>)  <span class="comment"># let's go</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python 的常用转义字符</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td>反斜杠符号</td>
</tr>
<tr>
<td style="text-align:center"><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td>横向制表符(TAB)</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td>回车</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>原始字符串只需要在字符串前边加一个英文字母 r 即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">r'C:\Program Files\Intel\Wifi\Help'</span>)  </span><br><span class="line"><span class="comment"># C:\Program Files\Intel\Wifi\Help</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的切片和拼接"><a href="#字符串的切片和拼接" class="headerlink" title="字符串的切片和拼接"></a>字符串的切片和拼接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'I Love LsgoGroup'</span></span><br><span class="line">print(str1[:<span class="number">6</span>])  <span class="comment"># I Love</span></span><br><span class="line">print(str1[<span class="number">5</span>])  <span class="comment"># e</span></span><br><span class="line">print(str1[:<span class="number">6</span>] + <span class="string">" 插入的字符串 "</span> + str1[<span class="number">6</span>:])  </span><br><span class="line"><span class="comment"># I Love 插入的字符串  LsgoGroup</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Python'</span></span><br><span class="line">print(s)  <span class="comment"># Python</span></span><br><span class="line">print(s[<span class="number">2</span>:<span class="number">4</span>])  <span class="comment"># th</span></span><br><span class="line">print(s[<span class="number">-5</span>:<span class="number">-2</span>])  <span class="comment"># yth</span></span><br><span class="line">print(s[<span class="number">2</span>])  <span class="comment"># t</span></span><br><span class="line">print(s[<span class="number">-1</span>])  <span class="comment"># n</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的常用内置方法"><a href="#字符串的常用内置方法" class="headerlink" title="字符串的常用内置方法"></a>字符串的常用内置方法</h3><ul>
<li><code>capitalize()</code> 将字符串的第一个字符转换为大写。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">'xiexie'</span></span><br><span class="line">print(str2.capitalize())  <span class="comment"># Xiexie</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>lower()</code> 转换字符串中所有大写字符为小写。</li>
<li><code>upper()</code> 转换字符串中的小写字母为大写。</li>
<li><code>swapcase()</code> 将字符串中大写转换为小写，小写转换为大写。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">"DAXIExiaoxie"</span></span><br><span class="line">print(str2.lower())  <span class="comment"># daxiexiaoxie</span></span><br><span class="line">print(str2.upper())  <span class="comment"># DAXIEXIAOXIE</span></span><br><span class="line">print(str2.swapcase())  <span class="comment"># daxieXIAOXIE</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>count(str, beg= 0,end=len(string))</code> 返回<code>str</code>在 string 里面出现的次数，如果<code>beg</code>或者<code>end</code>指定则返回指定范围内<code>str</code>出现的次数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">"DAXIExiaoxie"</span></span><br><span class="line">print(str2.count(<span class="string">'xi'</span>))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>endswith(suffix, beg=0, end=len(string))</code> 检查字符串是否以指定子字符串 <code>suffix</code> 结束，如果是，返回 True,否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li>
<li><code>startswith(substr, beg=0,end=len(string))</code> 检查字符串是否以指定子字符串 <code>substr</code> 开头，如果是，返回 True，否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">"DAXIExiaoxie"</span></span><br><span class="line">print(str2.endswith(<span class="string">'ie'</span>))  <span class="comment"># True</span></span><br><span class="line">print(str2.endswith(<span class="string">'xi'</span>))  <span class="comment"># False</span></span><br><span class="line">print(str2.startswith(<span class="string">'Da'</span>))  <span class="comment"># False</span></span><br><span class="line">print(str2.startswith(<span class="string">'DA'</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>find(str, beg=0, end=len(string))</code> 检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code>，则检查是否包含在指定范围内，如果包含，返回开始的索引值，否则返回 -1。</li>
<li><code>rfind(str, beg=0,end=len(string))</code> 类似于 <code>find()</code> 函数，不过是从右边开始查找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str2 = <span class="string">"DAXIExiaoxie"</span></span><br><span class="line">print(str2.find(<span class="string">'xi'</span>))  <span class="comment"># 5</span></span><br><span class="line">print(str2.find(<span class="string">'ix'</span>))  <span class="comment"># -1</span></span><br><span class="line">print(str2.rfind(<span class="string">'xi'</span>))  <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>isnumeric()</code> 如果字符串中只包含数字字符，则返回 True，否则返回 False。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str3 = <span class="string">'12345'</span></span><br><span class="line">print(str3.isnumeric())  <span class="comment"># True</span></span><br><span class="line">str3 += <span class="string">'a'</span></span><br><span class="line">print(str3.isnumeric())  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ljust(width[, fillchar])</code>返回一个原字符串左对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li>
<li><code>rjust(width[, fillchar])</code>返回一个原字符串右对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str4 = <span class="string">'1101'</span></span><br><span class="line">print(str4.ljust(<span class="number">8</span>, <span class="string">'0'</span>))  <span class="comment"># 11010000</span></span><br><span class="line">print(str4.rjust(<span class="number">8</span>, <span class="string">'0'</span>))  <span class="comment"># 00001101</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>lstrip([chars])</code> 截掉字符串左边的空格或指定字符。</li>
<li><code>rstrip([chars])</code> 删除字符串末尾的空格或指定字符。</li>
<li><code>strip([chars])</code> 在字符串上执行<code>lstrip()</code>和<code>rstrip()</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str5 = <span class="string">' I Love LsgoGroup '</span></span><br><span class="line">print(str5.lstrip())  <span class="comment"># 'I Love LsgoGroup '</span></span><br><span class="line">print(str5.lstrip().strip(<span class="string">'I'</span>))  <span class="comment"># ' Love LsgoGroup '</span></span><br><span class="line">print(str5.rstrip())  <span class="comment"># ' I Love LsgoGroup'</span></span><br><span class="line">print(str5.strip())  <span class="comment"># 'I Love LsgoGroup'</span></span><br><span class="line">print(str5.strip().strip(<span class="string">'p'</span>))  <span class="comment"># 'I Love LsgoGrou'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>partition(sub)</code> 找到子字符串sub，把字符串分为一个三元组<code>(pre_sub,sub,fol_sub)</code>，如果字符串中不包含sub则返回<code>(&#39;原字符串&#39;,&#39;&#39;,&#39;&#39;)</code>。</li>
<li><code>rpartition(sub)</code>类似于<code>partition()</code>方法，不过是从右边开始查找。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str5 = <span class="string">' I Love LsgoGroup '</span></span><br><span class="line">print(str5.strip().partition(<span class="string">'o'</span>))  <span class="comment"># ('I L', 'o', 've LsgoGroup')</span></span><br><span class="line">print(str5.strip().partition(<span class="string">'m'</span>))  <span class="comment"># ('I Love LsgoGroup', '', '')</span></span><br><span class="line">print(str5.strip().rpartition(<span class="string">'o'</span>))  <span class="comment"># ('I Love LsgoGr', 'o', 'up')</span></span><br></pre></td></tr></table></figure>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>1、实现isdigit函数</p>
<p>题目要求</p>
<p>实现函数isdigit， 判断字符串里是否只包含数字0~9</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isdigit</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断字符串只包含数字</span></span><br><span class="line"><span class="string">    :param string:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="string">'0'</span> <span class="keyword">and</span> i &lt;= <span class="string">'9'</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"> 	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>2、leetcode 5题 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 枚举子串的长度 l+1</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 枚举子串的起始位置 i，这样可以通过 j=i+l 得到子串的结束位置</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                j = i + l</span><br><span class="line">                <span class="keyword">if</span> j &gt;= len(s):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> l == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = (s[i] == s[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> s[i] == s[j])</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> l + <span class="number">1</span> &gt; len(ans):</span><br><span class="line">                    ans = s[i:j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>datawhale，python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-字典、集合和序列</title>
    <url>/2020/07/28/python-%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = (<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br><span class="line">dic1 = dict.fromkeys(seq)</span><br><span class="line">print(<span class="string">"新的字典为 : %s"</span> % str(dic1))  </span><br><span class="line"><span class="comment"># 新的字典为 : &#123;'name': None, 'age': None, 'sex': None&#125;</span></span><br><span class="line"></span><br><span class="line">dic2 = dict.fromkeys(seq, <span class="number">10</span>)</span><br><span class="line">print(<span class="string">"新的字典为 : %s"</span> % str(dic2))  </span><br><span class="line"><span class="comment"># 新的字典为 : &#123;'name': 10, 'age': 10, 'sex': 10&#125;</span></span><br><span class="line"></span><br><span class="line">dic3 = dict.fromkeys(seq, (<span class="string">'小马'</span>, <span class="string">'8'</span>, <span class="string">'男'</span>))</span><br><span class="line">print(<span class="string">"新的字典为 : %s"</span> % str(dic3))  </span><br><span class="line"><span class="comment"># 新的字典为 : &#123;'name': ('小马', '8', '男'), 'age': ('小马', '8', '男'), 'sex': ('小马', '8', '男')&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">'Name'</span>: <span class="string">'Lsgogroup'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">print(<span class="string">"Age 键的值为 : %s"</span> % dic.setdefault(<span class="string">'Age'</span>, <span class="literal">None</span>))  <span class="comment"># Age 键的值为 : 7</span></span><br><span class="line">print(<span class="string">"Sex 键的值为 : %s"</span> % dic.setdefault(<span class="string">'Sex'</span>, <span class="literal">None</span>))  <span class="comment"># Sex 键的值为 : None</span></span><br><span class="line">print(<span class="string">"新字典为："</span>, dic)  </span><br><span class="line"><span class="comment"># 新字典为： &#123;'Age': 7, 'Name': 'Lsgogroup', 'Sex': None&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><code>set.discard(value)</code> 用于移除指定的集合元素。<code>remove()</code> 方法在移除一个不存在的元素时会发生错误，而 <code>discard()</code> 方法不会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>&#125;</span><br><span class="line">fruits.discard(<span class="string">"banana"</span>)</span><br><span class="line">print(fruits)  <span class="comment"># &#123;'apple', 'cherry'&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>set.intersection(set1, set2 ...)</code> 返回两个集合的交集。</p>
<p><code>set1 &amp; set2</code> 返回两个集合的交集。两种写法都一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line">print(a)  <span class="comment"># &#123;'r', 'a', 'c', 'b', 'd'&#125;</span></span><br><span class="line">print(b)  <span class="comment"># &#123;'c', 'a', 'l', 'm', 'z'&#125;</span></span><br><span class="line"></span><br><span class="line">print(a &amp; b)  <span class="comment"># &#123;'c', 'a'&#125;</span></span><br><span class="line">c = a.intersection(b)</span><br><span class="line">print(c)  <span class="comment"># &#123;'a', 'c'&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>set1 | set2</code> 返回两个集合的并集。</p>
<p><code>set.union(set1, set2...)</code> 返回两个集合的并集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line">print(a)  <span class="comment"># &#123;'r', 'a', 'c', 'b', 'd'&#125;</span></span><br><span class="line">print(b)  <span class="comment"># &#123;'c', 'a', 'l', 'm', 'z'&#125;</span></span><br><span class="line"></span><br><span class="line">print(a | b)  <span class="comment"># &#123;'l', 'd', 'm', 'b', 'a', 'r', 'z', 'c'&#125;</span></span><br><span class="line">c = a.union(b)</span><br><span class="line">print(c)  <span class="comment"># &#123;'c', 'a', 'd', 'm', 'r', 'b', 'z', 'l'&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>set.difference(set)</code> 返回集合的差集。</p>
<p><code>set1 - set2</code> 返回集合的差集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line">print(a)  <span class="comment"># &#123;'r', 'a', 'c', 'b', 'd'&#125;</span></span><br><span class="line">print(b)  <span class="comment"># &#123;'c', 'a', 'l', 'm', 'z'&#125;</span></span><br><span class="line"></span><br><span class="line">c = a.difference(b)</span><br><span class="line">print(c)  <span class="comment"># &#123;'b', 'd', 'r'&#125;</span></span><br><span class="line">print(a - b)  <span class="comment"># &#123;'d', 'b', 'r'&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>set.symmetric_difference(set)</code>返回集合的异或。</p>
<p><code>set1 ^ set2</code> 返回集合的异或。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line">print(a)  <span class="comment"># &#123;'r', 'a', 'c', 'b', 'd'&#125;</span></span><br><span class="line">print(b)  <span class="comment"># &#123;'c', 'a', 'l', 'm', 'z'&#125;</span></span><br><span class="line"></span><br><span class="line">c = a.symmetric_difference(b)</span><br><span class="line">print(c)  <span class="comment"># &#123;'m', 'r', 'l', 'b', 'z', 'd'&#125;</span></span><br><span class="line">print(a ^ b)  <span class="comment"># &#123;'m', 'r', 'l', 'b', 'z', 'd'&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>set.issubset(set)</code>判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<p><code>set1 &lt;= set2</code> 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">y = &#123;<span class="string">"f"</span>, <span class="string">"e"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>&#125;</span><br><span class="line">z = x.issubset(y)</span><br><span class="line">print(z)  <span class="comment"># True</span></span><br><span class="line">print(x &lt;= y)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p><code>set.issuperset(set)</code>用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</p>
<p><code>set1 &gt;= set2</code> 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = &#123;<span class="string">"f"</span>, <span class="string">"e"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>&#125;</span><br><span class="line">y = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">z = x.issuperset(y)</span><br><span class="line">print(z)  <span class="comment"># True</span></span><br><span class="line">print(x &gt;= y)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p><code>set.isdisjoint(set)</code> 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = &#123;<span class="string">"f"</span>, <span class="string">"e"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>&#125;</span><br><span class="line">y = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">z = x.isdisjoint(y)</span><br><span class="line">print(z)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>文件与文件系统</title>
    <url>/2020/08/04/python-%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li><code>open(file, mode=&#39;r&#39;, buffering=None, encoding=None, errors=None, newline=None, closefd=True)</code> Open file and return a stream.  Raise OSError upon failure.<ul>
<li><code>file</code>: 必需，文件路径（相对或者绝对路径）。</li>
<li><code>mode</code>: 可选，文件打开模式</li>
<li><code>buffering</code>: 设置缓冲</li>
<li><code>encoding</code>: 一般使用utf8</li>
<li><code>errors</code>: 报错级别</li>
<li><code>newline</code>: 区分换行符</li>
</ul>
</li>
</ul>
<p>常见的<code>mode</code>如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">打开模式</th>
<th>执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘r’</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td style="text-align:center">‘w’</td>
<td>打开一个文件只用于写入。<br>如果该文件已存在则打开文件，并从开头开始编辑。<br>即原有内容会被删除。<br>如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td style="text-align:center">‘x’</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td style="text-align:center">‘a’</td>
<td>追加模式，打开一个文件用于追加。<br>如果该文件已存在，文件指针将会放在文件的结尾。<br>也就是说，新的内容将会被写入到已有内容之后。<br>如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td style="text-align:center">‘b’</td>
<td>以二进制模式打开文件。一般用于非文本文件，如：图片。</td>
</tr>
<tr>
<td style="text-align:center">‘t’</td>
<td>以文本模式打开（默认）。一般用于文本文件，如：txt。</td>
</tr>
<tr>
<td style="text-align:center">‘+’</td>
<td>可读写模式（可添加到其它模式中使用）</td>
</tr>
</tbody>
</table>
</div>
<p>【例】打开一个文件，并返回文件对象，如果该文件无法被打开，会抛出<code>OSError</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>)</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name='将进酒.txt' mode='r' encoding='cp936'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> f:</span><br><span class="line">    print(each)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line"><span class="comment"># 君不见，高堂明镜悲白发，朝如青丝暮成雪。</span></span><br><span class="line"><span class="comment"># 人生得意须尽欢，莫使金樽空对月。</span></span><br><span class="line"><span class="comment"># 天生我材必有用，千金散尽还复来。</span></span><br><span class="line"><span class="comment"># 烹羊宰牛且为乐，会须一饮三百杯。</span></span><br><span class="line"><span class="comment"># 岑夫子，丹丘生，将进酒，杯莫停。</span></span><br><span class="line"><span class="comment"># 与君歌一曲，请君为我倾耳听。</span></span><br><span class="line"><span class="comment"># 钟鼓馔玉不足贵，但愿长醉不复醒。</span></span><br><span class="line"><span class="comment"># 古来圣贤皆寂寞，惟有饮者留其名。</span></span><br><span class="line"><span class="comment"># 陈王昔时宴平乐，斗酒十千恣欢谑。</span></span><br><span class="line"><span class="comment"># 主人何为言少钱，径须沽取对君酌。</span></span><br><span class="line"><span class="comment"># 五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h2><ul>
<li><code>fileObject.close()</code> 用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作， 否则会触发<code>ValueError</code>错误。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">"将进酒.txt"</span>)</span><br><span class="line">print(<span class="string">'FileName:'</span>, f.name)  <span class="comment"># FileName: 将进酒.txt</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.read([size])</code> 用于从文件读取指定的<u>字符数</u>，如果未给定或为负则读取所有。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">line = f.read(<span class="number">20</span>)</span><br><span class="line">print(<span class="string">"读取的字符串: %s"</span> % line)</span><br><span class="line"><span class="comment"># 读取的字符串: 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.readline()</code>读取整行，包括 “\n” 字符。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(<span class="string">"读取的字符串: %s"</span> % line)</span><br><span class="line"><span class="comment"># 读取的字符串: 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.readlines()</code>用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 <code>for... in ...</code> 结构进行处理。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">lines = f.readlines()</span><br><span class="line">print(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> lines:</span><br><span class="line">    each.strip()</span><br><span class="line">    print(each)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line"><span class="comment"># 君不见，高堂明镜悲白发，朝如青丝暮成雪。</span></span><br><span class="line"><span class="comment"># 人生得意须尽欢，莫使金樽空对月。</span></span><br><span class="line"><span class="comment"># 天生我材必有用，千金散尽还复来。</span></span><br><span class="line"><span class="comment"># 烹羊宰牛且为乐，会须一饮三百杯。</span></span><br><span class="line"><span class="comment"># 岑夫子，丹丘生，将进酒，杯莫停。</span></span><br><span class="line"><span class="comment"># 与君歌一曲，请君为我倾耳听。</span></span><br><span class="line"><span class="comment"># 钟鼓馔玉不足贵，但愿长醉不复醒。</span></span><br><span class="line"><span class="comment"># 古来圣贤皆寂寞，惟有饮者留其名。</span></span><br><span class="line"><span class="comment"># 陈王昔时宴平乐，斗酒十千恣欢谑。</span></span><br><span class="line"><span class="comment"># 主人何为言少钱，径须沽取对君酌。</span></span><br><span class="line"><span class="comment"># 五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.tell()</code>返回文件的当前位置，即文件指针当前位置。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line">pos = f.tell()</span><br><span class="line">print(pos)  <span class="comment"># 42</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.seek(offset[, whence])</code>用于移动文件读取指针到指定位置。<ul>
<li><code>offset</code>：开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。</li>
<li><code>whence</code>：可选，默认值为 0。给 <code>offset</code> 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</li>
</ul>
</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line">line = f.readline()</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 君不见，高堂明镜悲白发，朝如青丝暮成雪。</span></span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">line = f.readline()</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.write(str)</code>用于向文件中写入指定字符串，返回的是写入的字符长度。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'workfile.txt'</span>, <span class="string">'wb+'</span>)</span><br><span class="line">print(f.write(<span class="string">b'0123456789abcdef'</span>))  <span class="comment"># 16</span></span><br><span class="line">print(f.seek(<span class="number">5</span>))  <span class="comment"># 5</span></span><br><span class="line">print(f.read(<span class="number">1</span>))  <span class="comment"># b'5'</span></span><br><span class="line">print(f.seek(<span class="number">-3</span>, <span class="number">2</span>))  <span class="comment"># 13</span></span><br><span class="line">print(f.read(<span class="number">1</span>))  <span class="comment"># b'd'</span></span><br></pre></td></tr></table></figure>
<p>在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的。</p>
<p>如果文件打开模式带<code>b</code>，那写入文件内容时，<code>str</code>（参数）要用<code>encode</code>方法转为<code>bytes</code>形式，否则报错：<code>TypeError: a bytes-like object is required, not &#39;str&#39;</code>。</p>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'...'</span></span><br><span class="line"><span class="comment"># 文本 = Unicode字符序列</span></span><br><span class="line"><span class="comment"># 相当于 string 类型</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">b'...'</span></span><br><span class="line"><span class="comment"># 文本 = 八位序列(0到255之间的整数)</span></span><br><span class="line"><span class="comment"># 字节文字总是以‘b’或‘B’作为前缀；它们产生一个字节类型的实例，而不是str类型。</span></span><br><span class="line"><span class="comment"># 相当于 byte[]</span></span><br></pre></td></tr></table></figure>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'将进酒.txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line">str = <span class="string">'\n作者：李白'</span></span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">line = f.write(str)</span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> f:</span><br><span class="line">    print(each)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 君不见，黄河之水天上来，奔流到海不复回。</span></span><br><span class="line"><span class="comment"># 君不见，高堂明镜悲白发，朝如青丝暮成雪。</span></span><br><span class="line"><span class="comment"># 人生得意须尽欢，莫使金樽空对月。</span></span><br><span class="line"><span class="comment"># 天生我材必有用，千金散尽还复来。</span></span><br><span class="line"><span class="comment"># 烹羊宰牛且为乐，会须一饮三百杯。</span></span><br><span class="line"><span class="comment"># 岑夫子，丹丘生，将进酒，杯莫停。</span></span><br><span class="line"><span class="comment"># 与君歌一曲，请君为我倾耳听。</span></span><br><span class="line"><span class="comment"># 钟鼓馔玉不足贵，但愿长醉不复醒。</span></span><br><span class="line"><span class="comment"># 古来圣贤皆寂寞，惟有饮者留其名。</span></span><br><span class="line"><span class="comment"># 陈王昔时宴平乐，斗酒十千恣欢谑。</span></span><br><span class="line"><span class="comment"># 主人何为言少钱，径须沽取对君酌。</span></span><br><span class="line"><span class="comment"># 五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</span></span><br><span class="line"><span class="comment"># 作者：李白</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fileObject.writelines(sequence)</code>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符<code>\n</code>。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w+'</span>)</span><br><span class="line">seq = [<span class="string">'小马的程序人生\n'</span>, <span class="string">'老马的程序人生'</span>]</span><br><span class="line">f.writelines(seq)</span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> f:</span><br><span class="line">    print(each)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 小马的程序人生</span></span><br><span class="line"><span class="comment"># 老马的程序人生</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="简洁的-with-语句"><a href="#简洁的-with-语句" class="headerlink" title="简洁的 with 语句"></a>简洁的 with 语句</h2><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p>
<p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行它的清理方法。</p>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'myfile.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line)</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">    print(<span class="string">'出错啦!%s'</span> % str(error))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出错啦!not readable</span></span><br></pre></td></tr></table></figure>
<p>这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'myfile.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            print(line)</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">    print(<span class="string">'出错啦!%s'</span> % str(error))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出错啦!not readable</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-OS-模块中关于文件-目录常用的函数"><a href="#2-OS-模块中关于文件-目录常用的函数" class="headerlink" title="2. OS 模块中关于文件/目录常用的函数"></a>2. OS 模块中关于文件/目录常用的函数</h1><p>我们所知道常用的操作系统就有：Windows，Mac OS，Linu，Unix等，这些操作系统底层对于文件系统的访问工作原理是不一样的，因此你可能就要针对不同的系统来考虑使用哪些文件系统模块……，这样的做法是非常不友好且麻烦的，因为这样就意味着当你的程序运行环境一改变，你就要相应的去修改大量的代码来应对。</p>
<p>有了OS（Operation System）模块，我们不需要关心什么操作系统下使用什么模块，OS模块会帮你选择正确的模块并调用。</p>
<ul>
<li><code>os.getcwd()</code>用于返回当前工作目录。</li>
<li><code>os.chdir(path)</code>用于改变当前工作目录到指定的路径。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'C:\\'</span></span><br><span class="line">print(<span class="string">"当前工作目录 : %s"</span> % os.getcwd())</span><br><span class="line"><span class="comment"># 当前工作目录 : C:\Users\Administrator\PycharmProjects\untitled1</span></span><br><span class="line">os.chdir(path)</span><br><span class="line">print(<span class="string">"目录修改成功 : %s"</span> % os.getcwd())</span><br><span class="line"><span class="comment"># 目录修改成功 : C:\</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>listdir (path=&#39;.&#39;)</code>返回<code>path</code>指定的文件夹包含的文件或文件夹的名字的列表。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dirs = os.listdir()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dirs:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.mkdir(path)</code>创建单层目录，如果该目录已存在抛出异常。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.isdir(<span class="string">r'.\b'</span>) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">    os.mkdir(<span class="string">r'.\B'</span>)</span><br><span class="line">    os.mkdir(<span class="string">r'.\B\A'</span>)</span><br><span class="line"></span><br><span class="line">os.mkdir(<span class="string">r'.\C\A'</span>) <span class="comment"># FileNotFoundError</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.makedirs(path)</code>用于递归创建多层目录，如果该目录已存在抛出异常。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">r'.\E\A'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.remove(path)</code>用于删除指定路径的文件。如果指定的路径是一个目录，将抛出 <code>OSError</code>。</li>
</ul>
<p>【例】首先创建<code>.\E\A\text.txt</code>文件，然后进行删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(<span class="string">r'.\E\A'</span>))</span><br><span class="line">os.remove(<span class="string">r'.\E\A\test.txt'</span>)</span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(<span class="string">r'.\E\A'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.rmdir(path)</code>用于删除单层目录。仅当这文件夹是空的才可以, 否则, 抛出 <code>OSError</code>。</li>
</ul>
<p>【例】首先创建<code>.\E\A</code>目录，然后进行删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(<span class="string">r'.\E'</span>))</span><br><span class="line">os.rmdir(<span class="string">r'.\E\A'</span>)</span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(<span class="string">r'.\E'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.removedirs(path)</code>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常。</li>
</ul>
<p>【例】首先创建<code>.\E\A</code>目录，然后进行删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(os.getcwd()))</span><br><span class="line">os.removedirs(<span class="string">r'.\E\A'</span>)  <span class="comment"># 先删除A 然后删除E</span></span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(os.getcwd()))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.rename(src, dst)</code>方法用于命名文件或目录，从 <code>src</code> 到 <code>dst</code>，如果 <code>dst</code> 是一个存在的目录, 将抛出 <code>OSError</code>。</li>
</ul>
<p>【例】把test.txt文件重命名为test2.txt。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(os.getcwd()))</span><br><span class="line">os.rename(<span class="string">"test.txt"</span>, <span class="string">"test2.txt"</span>)</span><br><span class="line">print(<span class="string">"重命名成功。"</span>)</span><br><span class="line">print(<span class="string">"目录为: %s"</span> % os.listdir(os.getcwd()))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.system(command)</code>运行系统的shell命令（将字符串转化成命令）</li>
</ul>
<p>【例】先自行创建一个a.py的文件，然后由shell命令打开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = os.getcwd() + <span class="string">'\\a.py'</span></span><br><span class="line">a = os.system(<span class="string">r'python %s'</span> % path)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'calc'</span>)  <span class="comment"># 打开计算器</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.curdir</code>指代当前目录（<code>.</code>）</li>
<li><code>os.pardir</code>指代上一级目录（<code>..</code>）</li>
<li><code>os.sep</code>输出操作系统特定的路径分隔符（win下为<code>\\</code>，Linux下为<code>/</code>）</li>
<li><code>os.linesep</code>当前平台使用的行终止符（win下为<code>\r\n</code>，Linux下为<code>\n</code>）</li>
<li><code>os.name</code>指代当前使用的操作系统（包括：’mac’，’nt’）</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.curdir)  <span class="comment"># .</span></span><br><span class="line">print(os.pardir)  <span class="comment"># ..</span></span><br><span class="line">print(os.sep)  <span class="comment"># \</span></span><br><span class="line">print(os.linesep)</span><br><span class="line">print(os.name)  <span class="comment"># nt</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.path.basename(path)</code>去掉目录路径，单独返回文件名</li>
<li><code>os.path.dirname(path)</code>去掉文件名，单独返回目录路径</li>
<li><code>os.path.join(path1[, path2[, ...]])</code>将 <code>path1</code>，<code>path2</code> 各部分组合成一个路径名</li>
<li><code>os.path.split(path)</code>分割文件名与路径，返回<code>(f_path,f_name)</code>元组。如果完全使用目录，它会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在。</li>
<li><code>os.path.splitext(path)</code>分离文件名与扩展名，返回<code>(f_path,f_name)</code>元组。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回文件名</span></span><br><span class="line">print(os.path.basename(<span class="string">r'C:\test\lsgo.txt'</span>))  <span class="comment"># lsgo.txt</span></span><br><span class="line"><span class="comment"># 返回目录路径</span></span><br><span class="line">print(os.path.dirname(<span class="string">r'C:\test\lsgo.txt'</span>))  <span class="comment"># C:\test</span></span><br><span class="line"><span class="comment"># 将目录和文件名合成一个路径</span></span><br><span class="line">print(os.path.join(<span class="string">'C:\\'</span>, <span class="string">'test'</span>, <span class="string">'lsgo.txt'</span>))  <span class="comment"># C:\test\lsgo.txt</span></span><br><span class="line"><span class="comment"># 分割文件名与路径</span></span><br><span class="line">print(os.path.split(<span class="string">r'C:\test\lsgo.txt'</span>))  <span class="comment"># ('C:\\test', 'lsgo.txt')</span></span><br><span class="line"><span class="comment"># 分离文件名与扩展名</span></span><br><span class="line">print(os.path.splitext(<span class="string">r'C:\test\lsgo.txt'</span>))  <span class="comment"># ('C:\\test\\lsgo', '.txt')</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.path.getsize(file)</code>返回指定文件大小，单位是字节。</li>
<li><code>os.path.getatime(file)</code>返回指定文件最近的访问时间</li>
<li><code>os.path.getctime(file)</code>返回指定文件的创建时间</li>
<li><code>os.path.getmtime(file)</code>返回指定文件的最新的修改时间</li>
<li>浮点型秒数，可用time模块的<code>gmtime()</code>或<code>localtime()</code>函数换算</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">file = <span class="string">r'.\lsgo.txt'</span></span><br><span class="line">print(os.path.getsize(file))  <span class="comment"># 30</span></span><br><span class="line">print(os.path.getatime(file))  <span class="comment"># 1565593737.347196</span></span><br><span class="line">print(os.path.getctime(file))  <span class="comment"># 1565593737.347196</span></span><br><span class="line">print(os.path.getmtime(file))  <span class="comment"># 1565593797.9298275</span></span><br><span class="line">print(time.gmtime(os.path.getctime(file)))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=8, tm_mday=12, tm_hour=7, tm_min=8, tm_sec=57, tm_wday=0, tm_yday=224, tm_isdst=0)</span></span><br><span class="line">print(time.localtime(os.path.getctime(file)))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=8, tm_mday=12, tm_hour=15, tm_min=8, tm_sec=57, tm_wday=0, tm_yday=224, tm_isdst=0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>os.path.exists(path)</code>判断指定路径（目录或文件）是否存在</li>
<li><code>os.path.isabs(path)</code>判断指定路径是否为绝对路径</li>
<li><code>os.path.isdir(path)</code>判断指定路径是否存在且是一个目录</li>
<li><code>os.path.isfile(path)</code>判断指定路径是否存在且是一个文件</li>
<li><code>os.path.islink(path)</code>判断指定路径是否存在且是一个符号链接</li>
<li><code>os.path.ismount(path)</code>判断指定路径是否存在且是一个悬挂点</li>
<li><code>os.path.samefile(path1,path2)</code>判断path1和path2两个路径是否指向同一个文件</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.path.ismount(<span class="string">'D:\\'</span>))  <span class="comment"># True</span></span><br><span class="line">print(os.path.ismount(<span class="string">'D:\\Test'</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-序列化与反序列化"><a href="#3-序列化与反序列化" class="headerlink" title="3. 序列化与反序列化"></a>3. 序列化与反序列化</h1><p>Python 的 pickle 模块实现了基本的数据序列和反序列化。</p>
<ul>
<li>通过 pickle 模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</li>
<li>通过 pickle 模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</li>
</ul>
<p>pickle模块中最常用的函数为：</p>
<p><code>pickle.dump(obj, file, [,protocol])</code> 将<code>obj</code>对象序列化存入已经打开的<code>file</code>中。</p>
<ul>
<li><code>obj</code>：想要序列化的<code>obj</code>对象。</li>
<li><code>file</code>:文件名称。</li>
<li><code>protocol</code>：序列化使用的协议。如果该项省略，则默认为0。如果为负值或<code>HIGHEST_PROTOCOL</code>，则使用最高的协议版本。</li>
</ul>
<p><code>pickle.load(file)</code> 将<code>file</code>中的对象序列化读出。</p>
<ul>
<li><code>file</code>：文件名称。</li>
</ul>
<p>【例】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">dataList = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">dataDic = &#123;<span class="number">0</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">           <span class="number">1</span>: (<span class="string">'a'</span>, <span class="string">'b'</span>),</span><br><span class="line">           <span class="number">2</span>: &#123;<span class="string">'c'</span>: <span class="string">'yes'</span>, <span class="string">'d'</span>: <span class="string">'no'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dump()将数据序列化到文件中</span></span><br><span class="line">fw = open(<span class="string">r'.\dataFile.pkl'</span>, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle the list using the highest protocol available.</span></span><br><span class="line">pickle.dump(dataList, fw, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></span><br><span class="line">pickle.dump(dataDic, fw)</span><br><span class="line">fw.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用load()将数据从文件中序列化读出</span></span><br><span class="line">fr = open(<span class="string">'dataFile.pkl'</span>, <span class="string">'rb'</span>)</span><br><span class="line">data1 = pickle.load(fr)</span><br><span class="line">print(data1)</span><br><span class="line">data2 = pickle.load(fr)</span><br><span class="line">print(data2)</span><br><span class="line">fr.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]</span></span><br><span class="line"><span class="comment"># &#123;0: [1, 2, 3, 4], 1: ('a', 'b'), 2: &#123;'c': 'yes', 'd': 'no'&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>python-变量、运算符、数据类型及位运算</title>
    <url>/2020/07/20/python-%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="1-1-Python简介"><a href="#1-1-Python简介" class="headerlink" title="1.1 Python简介"></a>1.1 Python简介</h3><p>&emsp;&emsp;Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。Python 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。</p>
<h3 id="1-2-学习目标"><a href="#1-2-学习目标" class="headerlink" title="1.2 学习目标"></a>1.2 学习目标</h3><p>1、变量、运算符与数据类型</p>
<ul>
<li>注释</li>
<li>运算符</li>
<li>变量和赋值</li>
<li>数据类型转换</li>
<li>print()函数</li>
</ul>
<p>2、位运算</p>
<h3 id="1-3-变量、运算符与数据类型"><a href="#1-3-变量、运算符与数据类型" class="headerlink" title="1.3 变量、运算符与数据类型"></a>1.3 变量、运算符与数据类型</h3><h4 id="1-3-1-注释"><a href="#1-3-1-注释" class="headerlink" title="1.3.1 注释"></a>1.3.1 注释</h4><p>&emsp;&emsp;学过编程语言的应该都知道每种编程语言都会有注释，当然了python也会有注释，只不过和C++/JAVA的注释不太一样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">注释类型</th>
<th style="text-align:center">python</th>
<th style="text-align:center">C++/JAVA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单行注释</td>
<td style="text-align:center">#</td>
<td style="text-align:center">//</td>
</tr>
<tr>
<td style="text-align:center">多行注释</td>
<td style="text-align:center"><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code></td>
<td style="text-align:center">/<em> </em>/</td>
</tr>
</tbody>
</table>
</div>
<p>上面的单引号或者双引号不够明显，下面还是通过代码来演示一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是单行注释</span></span><br><span class="line">print(<span class="string">'Hello world'</span>)  <span class="comment">#输出的就是Hello world</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这是夹在6个单引号之间的多行注释。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">当然也可以将单引号换成双引号，但是两者不要混着用，要么就全部单引号，要么就全部双引号。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><code>&#39;&#39;&#39;    &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot;     &quot;&quot;&quot;</code> 表示区间注释，在三引号之间的所有内容被注释。<br><br/></p>
<h4 id="1-3-2-运算符"><a href="#1-3-2-运算符" class="headerlink" title="1.3.2 运算符"></a>1.3.2 运算符</h4><h5 id="1-3-2-1-算术运算符"><a href="#1-3-2-1-算术运算符" class="headerlink" title="1.3.2.1 算术运算符"></a>1.3.2.1 算术运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">加</td>
<td style="text-align:center"><code>1 + 1 = 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">减</td>
<td style="text-align:center"><code>2 - 1 = 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">乘</td>
<td style="text-align:center"><code>3 * 4 = 12</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">除</td>
<td style="text-align:center"><code>3 / 4 = 0.75</code></td>
</tr>
<tr>
<td style="text-align:center"><code>//</code></td>
<td style="text-align:center">整除</td>
<td style="text-align:center"><code>3 // 4 = 0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">取余</td>
<td style="text-align:center"><code>3 % 4 = 3</code></td>
</tr>
<tr>
<td style="text-align:center"><code>**</code></td>
<td style="text-align:center">幂</td>
<td style="text-align:center"><code>2 ** 3 = 8</code></td>
</tr>
</tbody>
</table>
</div>
<p><br/></p>
<p>将上述例子输入的python当中进行验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span> + <span class="number">1</span>)  <span class="comment"># 2</span></span><br><span class="line">print(<span class="number">2</span> - <span class="number">1</span>)  <span class="comment"># 1</span></span><br><span class="line">print(<span class="number">3</span> * <span class="number">4</span>)  <span class="comment"># 12</span></span><br><span class="line">print(<span class="number">3</span> / <span class="number">4</span>)  <span class="comment"># 0.75</span></span><br><span class="line">print(<span class="number">3</span> // <span class="number">4</span>)  <span class="comment"># 0</span></span><br><span class="line">print(<span class="number">3</span> % <span class="number">4</span>)  <span class="comment"># 3</span></span><br><span class="line">print(<span class="number">2</span> ** <span class="number">3</span>)  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;面的 <code>%</code>是要特别注意的。在不同编程语言中，它的计算公式可能是不一样的，意思就是说用这个符号在不同的编程语言中可能一样的式子最后得出的结果不一样。例如，(-11)%5在<strong>python</strong>中计算的结果是4，而在<strong>C</strong>中计算的结果则是-1。
　　</p>
<ol>
<li>C/Java语言除法采用的是趋零截尾(事实上，C89对于除数或被除数之一为负数情况的结果是未定义的;C99才正式确定了趋零截尾)，即truncate除法。它们的取模运算符是%，并且此运算符只接受整型操作数。一个规律是，取模运算的结果的符号与第一个操作数的符号相同(或为0)。因此(-11)%5=-11-[(-11)/5]<em>5=-11-(-2)</em>5=-1。</li>
<li>Python语言除法采用的是趋负无穷截尾，即floor除法。它的取模运算符也是%，并且此运算符可以接受浮点操作数。一个类似的规律是，取模运算的结果的符号与第二个操作数的符号相同。因此(-11)%5=-11-[(-11)/5]<em>5=-11-(-3)</em>5=4。这里需要注意的是，Python 3.x中”/“运算符的意义发生了变化，”/“产生的结果将不会再进行截尾;相应的”//“运算符的结果才会进行截尾。</li>
</ol>
<p>这边就不解释太多了，感兴趣的可以自己去百度<strong>不同编程语言中取模运算符的差异</strong>。<br><br></p>
<h5 id="1-3-2-2-比较运算符"><a href="#1-3-2-2-比较运算符" class="headerlink" title="1.3.2.2 比较运算符"></a>1.3.2.2 比较运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">大于</td>
<td style="text-align:center"><code>2 &gt; 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center"><code>2 &gt;= 4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">小于</td>
<td style="text-align:center"><code>1 &lt; 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center"><code>5&lt;= 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">等于</td>
<td style="text-align:center"><code>3 == 4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">不等于</td>
<td style="text-align:center"><code>3 != 5</code></td>
</tr>
</tbody>
</table>
</div>
<p>同样将上述例子带入python中进行验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">2</span> &gt; <span class="number">1</span>)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">2</span> &gt;= <span class="number">4</span>)  <span class="comment"># False</span></span><br><span class="line">print(<span class="number">1</span> &lt; <span class="number">2</span>)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">5</span> &lt;= <span class="number">2</span>)  <span class="comment"># False</span></span><br><span class="line">print(<span class="number">3</span> == <span class="number">4</span>)  <span class="comment"># False</span></span><br><span class="line">print(<span class="number">3</span> != <span class="number">5</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-3-逻辑运算符"><a href="#1-3-2-3-逻辑运算符" class="headerlink" title="1.3.2.3 逻辑运算符"></a>1.3.2.3 逻辑运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>and</code></td>
<td style="text-align:center">与</td>
<td style="text-align:center"><code>(3 &gt; 2) and (3 &lt; 5)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>or</code></td>
<td style="text-align:center">或</td>
<td style="text-align:center"><code>(1 &gt; 3) or (9 &lt; 2)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>not</code></td>
<td style="text-align:center">非</td>
<td style="text-align:center"><code>not (2 &gt; 1)</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print((<span class="number">3</span> &gt; <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">3</span> &lt; <span class="number">5</span>))  <span class="comment"># True</span></span><br><span class="line">print((<span class="number">1</span> &gt; <span class="number">3</span>) <span class="keyword">or</span> (<span class="number">9</span> &lt; <span class="number">2</span>))  <span class="comment"># False</span></span><br><span class="line">print(<span class="keyword">not</span> (<span class="number">2</span> &gt; <span class="number">1</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这边可能有些人会把 <strong>与 或 非</strong> 以为是  <strong>&amp;&amp; || !</strong>，这三个是C++/JAVA当中的写法，要注意一下。</p>
<h5 id="1-3-2-4-位运算符"><a href="#1-3-2-4-位运算符" class="headerlink" title="1.3.2.4 位运算符"></a>1.3.2.4 位运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位取反</td>
<td style="text-align:center"><code>~4</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与</td>
<td style="text-align:center"><code>4 &amp; 5</code></td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td style="text-align:center">`</td>
<td style="text-align:center">按位或</td>
<td>`4</td>
<td>5`</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center"><code>4 ^ 5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">左移</td>
<td style="text-align:center"><code>4 &lt;&lt; 2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center"><code>4 &gt;&gt; 2</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;这边需要点二进制相关的知识了。等会在后面会讲到位运算的相关知识。在这里就先将上述例子带入到python当中运行查看效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(bin(<span class="number">4</span>))  <span class="comment"># 0b100</span></span><br><span class="line">print(bin(<span class="number">5</span>))  <span class="comment"># 0b101</span></span><br><span class="line">print(bin(~<span class="number">4</span>), ~<span class="number">4</span>)  <span class="comment"># -0b101 -5</span></span><br><span class="line">print(bin(<span class="number">4</span> &amp; <span class="number">5</span>), <span class="number">4</span> &amp; <span class="number">5</span>)  <span class="comment"># 0b100 4</span></span><br><span class="line">print(bin(<span class="number">4</span> | <span class="number">5</span>), <span class="number">4</span> | <span class="number">5</span>)  <span class="comment"># 0b101 5</span></span><br><span class="line">print(bin(<span class="number">4</span> ^ <span class="number">5</span>), <span class="number">4</span> ^ <span class="number">5</span>)  <span class="comment"># 0b1 1</span></span><br><span class="line">print(bin(<span class="number">4</span> &lt;&lt; <span class="number">2</span>), <span class="number">4</span> &lt;&lt; <span class="number">2</span>)  <span class="comment"># 0b10000 16</span></span><br><span class="line">print(bin(<span class="number">4</span> &gt;&gt; <span class="number">2</span>), <span class="number">4</span> &gt;&gt; <span class="number">2</span>)  <span class="comment"># 0b1 1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这边数字前面的<strong>0b</strong>只是一种标记符，表示这是一个二级制数值。当然也有100B，这种写在最后面的。这边也扩展下，十六进制就是<strong>0x</strong>，或者是在最后面加<strong>H</strong>。上述代码中的<strong>bin()</strong> 函数表示将某个10进制数表示成二进制数。<br><br></p>
<h5 id="1-3-2-5-三元运算符"><a href="#1-3-2-5-三元运算符" class="headerlink" title="1.3.2.5 三元运算符"></a>1.3.2.5 三元运算符</h5><p>&emsp;&emsp;说到三元运算符，可能大部分人会想到 <strong>?  :</strong> 不过python当中没有这个运算符，不过有一个类似的。<strong>small = x if x &lt; y else y</strong>，它的意思就是如果x &lt; y 那么small = x，否则small = y。就是取x和y中的较小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">small = x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y</span><br><span class="line">print(small)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-6-其它运算符"><a href="#1-3-2-6-其它运算符" class="headerlink" title="1.3.2.6 其它运算符"></a>1.3.2.6 其它运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>in</code></td>
<td style="text-align:center">存在</td>
<td style="text-align:center"><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>not in</code></td>
<td style="text-align:center">不存在</td>
<td style="text-align:center"><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>is</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>&quot;hello&quot; is &quot;hello&quot;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>is not</code></td>
<td style="text-align:center">不是</td>
<td style="text-align:center"><code>&quot;hello&quot; is not &quot;hello&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<p>这些运算符也是挺实用的，举两个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letters = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">'A'</span> <span class="keyword">in</span> letters:</span><br><span class="line">    print(<span class="string">'A'</span> + <span class="string">' exists'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'h'</span> <span class="keyword">not</span> <span class="keyword">in</span> letters:</span><br><span class="line">    print(<span class="string">'h'</span> + <span class="string">' not exists'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A exists</span></span><br><span class="line"><span class="comment"># h not exists</span></span><br></pre></td></tr></table></figure>
<p>其实 <code>in</code>和<code>not in</code>倒是挺容易理解的，那么可能会有人疑惑了， <code>is</code>和<code>not is</code>为什么需要呢，不是有  <code>=</code> 和 <code>!=</code> 吗。其实这两个是有区别的。这边来简单解释下。</p>
<ul>
<li><code>is</code>和<code>is not</code>是地址比较</li>
<li><code>=</code> 和 <code>!=</code> 是值比较</li>
</ul>
<p>说到地址比较就要先引出python中<code>id()</code>这个函数，这个函数就是取出变量的地址的。接下来看一些例子</p>
<p>当比较的两个变量均指向可变类型时。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a == b  <span class="comment"># 输出的肯定是true，因为值是一模一样的</span></span><br><span class="line">a <span class="keyword">is</span> b <span class="comment"># 可能有人也会觉得输出的是true，但结果是false</span></span><br><span class="line">id(a) <span class="comment"># 3076010508L</span></span><br><span class="line">id(b) <span class="comment"># 3076166636L</span></span><br><span class="line"><span class="comment"># 用id()这个函数看出了 这两个值的地址是不一样的，因此是false</span></span><br></pre></td></tr></table></figure><br>当比较的两个变量均指向不可变类型时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">b = <span class="string">"hello"</span></span><br><span class="line">print(a <span class="keyword">is</span> b, a == b)  <span class="comment"># True True</span></span><br><span class="line">print(a <span class="keyword">is</span> <span class="keyword">not</span> b, a != b)  <span class="comment"># False False</span></span><br><span class="line"><span class="comment"># 那为什么这里用 is 也是相等的呢，其实很好证明，我们用id()函数输出一下地址就知道了。</span></span><br><span class="line">id(a) <span class="comment"># 2536490040752</span></span><br><span class="line">id(b) <span class="comment"># 2536490040752</span></span><br><span class="line"><span class="comment"># 所以知道为什么在这里是相等的了吧。</span></span><br></pre></td></tr></table></figure>
<p><strong>至于为什么上面 当两个类型不一样的时候，结果也不一样，这里就涉及到python的内存分配了。python为了提高内存利用效率对于一些简单的对象，如一些数值较小的int对象，字符串对象等，python采取重用对象内存的办法.</strong> 这里就简单解释下，感兴趣的可以自己去深究。下面作些简单的总结。</p>
<ol>
<li>is, is not 对比的是两个变量的内存地址</li>
<li>==, != 对比的是两个变量的值</li>
<li>比较的两个变量，指向的都是地址不可变的类型（int, str等），那么is，is not 和 ==，！= 是完全等价的。</li>
<li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。</li>
</ol>
<h5 id="1-3-2-7-运算符的优先级"><a href="#1-3-2-7-运算符的优先级" class="headerlink" title="1.3.2.7 运算符的优先级"></a>1.3.2.7 运算符的优先级</h5><p><img src="https://img-blog.csdnimg.cn/20200719143004122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li>
<li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li>
<li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">-3</span> ** <span class="number">2</span>)  <span class="comment"># -9</span></span><br><span class="line">print(<span class="number">3</span> ** <span class="number">-2</span>)  <span class="comment"># 0.1111111111111111</span></span><br><span class="line">print(<span class="number">1</span> &lt;&lt; <span class="number">3</span> + <span class="number">2</span> &amp; <span class="number">7</span>)  <span class="comment"># 0</span></span><br><span class="line">print(<span class="number">-3</span> * <span class="number">2</span> + <span class="number">5</span> / <span class="number">-2</span> - <span class="number">4</span>)  <span class="comment"># -12.5</span></span><br><span class="line">print(<span class="number">3</span> &lt; <span class="number">4</span> <span class="keyword">and</span> <span class="number">4</span> &lt; <span class="number">5</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-变量和赋值"><a href="#1-3-3-变量和赋值" class="headerlink" title="1.3.3 变量和赋值"></a>1.3.3 变量和赋值</h4><ul>
<li>在使用变量之前，需要对其先赋值。</li>
<li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li>
<li>Python 变量名是大小写敏感的，foo != Foo。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>string = <span class="string">"Hello world!"</span> <span class="comment"># 是错误的，不能以数字开头</span></span><br><span class="line">string1 = <span class="string">"Hello world!"</span> <span class="comment"># 是正确的</span></span><br><span class="line">_string = <span class="string">"Hello world!"</span> <span class="comment"># 也是正确的</span></span><br><span class="line">string= <span class="string">"Hello Python"</span></span><br><span class="line">print(string)  <span class="comment"># Hello Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量赋值</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串可以相加</span></span><br><span class="line">string1 = <span class="string">"Hello"</span></span><br><span class="line">string2 = <span class="string">"world!"</span></span><br><span class="line">print(stirng1 + string2) <span class="comment"># Hello world!</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-数据类型与转换"><a href="#1-3-4-数据类型与转换" class="headerlink" title="1.3.4 数据类型与转换"></a>1.3.4 数据类型与转换</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">整型 <code>&lt;class &#39;int&#39;&gt;</code></td>
<td style="text-align:center"><code>-876, 10</code></td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">浮点型<code>&lt;class &#39;float&#39;&gt;</code></td>
<td style="text-align:center"><code>3.149, 11.11</code></td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td>
<td style="text-align:center"><code>True, False</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 整型</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">print(a, type(a))</span><br><span class="line"><span class="comment"># 1 &lt;class 'int'&gt;  值为1， 类型为 int</span></span><br></pre></td></tr></table></figure>
<p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。可以通过<code>dir()</code> 来查看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = dir(int)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__',</span></span><br><span class="line"><span class="comment"># '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__',</span></span><br><span class="line"><span class="comment"># '__float__', '__floor__', '__floordiv__', '__format__', '__ge__',</span></span><br><span class="line"><span class="comment"># '__getattribute__', '__getnewargs__', '__gt__', '__hash__',</span></span><br><span class="line"><span class="comment"># '__index__', '__init__', '__init_subclass__', '__int__', '__invert__',</span></span><br><span class="line"><span class="comment"># '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__',</span></span><br><span class="line"><span class="comment"># '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__',</span></span><br><span class="line"><span class="comment"># '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',</span></span><br><span class="line"><span class="comment"># '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',</span></span><br><span class="line"><span class="comment"># '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',</span></span><br><span class="line"><span class="comment"># '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',</span></span><br><span class="line"><span class="comment"># '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__',</span></span><br><span class="line"><span class="comment"># 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag',</span></span><br><span class="line"><span class="comment"># 'numerator', 'real', 'to_bytes']</span></span><br></pre></td></tr></table></figure>
<p>当然，上面的属性和方法不需要记住，需要用到的时候再来查看就行了。现在来看一些例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个整数输出它的二进制数表示的方式，并求出长度</span></span><br><span class="line">a = <span class="number">1025</span></span><br><span class="line">print(bin(a)) <span class="comment"># 0b10000000001</span></span><br><span class="line">print(a.bit_length()) <span class="comment"># 11</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浮点型</span></span><br><span class="line">print(<span class="number">1.</span>, type(<span class="number">1.</span>))</span><br><span class="line"><span class="comment"># 1.0 &lt;class 'float'&gt;</span></span><br><span class="line">a = <span class="number">0.00000023</span></span><br><span class="line">b = <span class="number">2.3e-7</span></span><br><span class="line">c = <span class="number">0.23</span></span><br><span class="line">print(a)  <span class="comment"># 2.3e-07</span></span><br><span class="line">print(b)  <span class="comment"># 2.3e-07</span></span><br><span class="line">print(c)  <span class="comment"># 0.23</span></span><br><span class="line"><span class="comment"># 可以看到当小数点位数过多后，会以科学计数法的方式表达</span></span><br></pre></td></tr></table></figure>
<p>对于浮点数来说，可以通过<code>round(x[,n])</code>函数来控制小数点的位数，x是要操作的数，n是要保留几位小数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(round(<span class="number">0.5111</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 0.511</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔型</span></span><br><span class="line"><span class="comment"># 布尔 (boolean) 型变量只能取两个值，`True` 和 `False`。当把布尔型变量用在数字运算中，用 `1` 和 `0` 代表 `True` 和 `False`。</span></span><br><span class="line">print(<span class="literal">True</span> + <span class="literal">True</span>)  <span class="comment"># 2</span></span><br><span class="line">print(<span class="literal">True</span> + <span class="literal">False</span>)  <span class="comment"># 1</span></span><br><span class="line">print(<span class="literal">True</span> * <span class="literal">False</span>)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p>
<ul>
<li>基本类型：整型、浮点型、布尔型</li>
<li>容器类型：字符串、元组、列表、字典和集合</li>
</ul>
<p>只要给的<code>X</code>是非零数(不是整型 <code>0</code> 和浮点型 <code>0.</code> 和 空的变量 )<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(bool(<span class="number">0</span>), bool(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># False True</span></span><br><span class="line">print(bool(<span class="string">''</span>), bool(<span class="string">'python'</span>))</span><br><span class="line"><span class="comment"># False True</span></span><br><span class="line">print(bool([]), bool([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="comment"># False True</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-4-1获取类型信息"><a href="#1-3-4-1获取类型信息" class="headerlink" title="1.3.4.1获取类型信息"></a>1.3.4.1获取类型信息</h5><p>获取类型信息<code>type(object)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(<span class="number">1</span>))  <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line">print(type(<span class="number">5.2</span>))  <span class="comment"># &lt;class 'float'&gt;</span></span><br><span class="line">print(type(<span class="literal">True</span>))  <span class="comment"># &lt;class 'bool'&gt;</span></span><br><span class="line">print(type(<span class="string">'5.2'</span>))  <span class="comment"># &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure>
<p>判断类型信息<code>isinstance(object, classinfo)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(isinstance(<span class="number">1</span>, int))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(<span class="number">5.2</span>, float))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(<span class="literal">True</span>, bool))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(<span class="string">'5.2'</span>, str))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>type(object)</code>不考虑继承关系，而<code>isinstance(object, classinfo)</code>考虑继承关系。<br><br></p>
<h4 id="1-3-5-print-函数"><a href="#1-3-5-print-函数" class="headerlink" title="1.3.5 print()函数"></a>1.3.5 print()函数</h4><p><code>print(*objects, sep=&#39; &#39;, end=&#39;\n)&#39;</code>这里就列出几个常用的参数，object没什么好说的就是要输出的变量，而sep参数就是每个变量之间用什么分割(默认为空格)，而end参数是最后一个参数的后面加上什么(默认输出完所有变量之后换行)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 1 2 中间是空格隔开</span></span><br><span class="line">print(<span class="number">1</span>, <span class="number">2</span>, sep=<span class="string">'*'</span>) <span class="comment"># 1*2 中间是*隔开</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello"</span>)</span><br><span class="line">print(<span class="string">"world!"</span>)</span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world!</span></span><br><span class="line"><span class="comment"># 默认是输出完之后换行，所以hello world!分两行显示了。</span></span><br><span class="line">print(<span class="string">"hello"</span>, end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">"world!"</span>)</span><br><span class="line"><span class="comment"># hello world!</span></span><br><span class="line"><span class="comment"># 修改了第一个print()，使输出完变量之后，用空格接上</span></span><br></pre></td></tr></table></figure>
<h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2 位运算"></a>2 位运算</h3><h4 id="2-1-原码、反码和补码"><a href="#2-1-原码、反码和补码" class="headerlink" title="2.1 原码、反码和补码"></a>2.1 原码、反码和补码</h4><p>在学习原码、反码和补码之前，需要先了解机器数和真值的概念<br><strong>机器数</strong><br>&emsp;&emsp;个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。<br><strong>真值</strong><br>&emsp;&emsp;因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p>
<p><strong>1、原码</strong><br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[+<span class="number">1</span>]原 = <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>]原 = <span class="number">1000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[1111 1111 , 0111 1111]==&gt;[-127 , 127]</span><br></pre></td></tr></table></figure>
<p><strong>2、反码</strong><br>反码的表示方法是:</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [<span class="number">00000001</span>]原 = [<span class="number">00000001</span>]反</span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反</span><br></pre></td></tr></table></figure>
<p><strong>3、补码</strong><br>补码的表示方法是:</p>
<ul>
<li>正数的补码就是其本身</li>
<li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[+<span class="number">1</span>] = [<span class="number">00000001</span>]原 = [<span class="number">00000001</span>]反 = [<span class="number">00000001</span>]补</span><br><span class="line"></span><br><span class="line">[<span class="number">-1</span>] = [<span class="number">10000001</span>]原 = [<span class="number">11111110</span>]反 = [<span class="number">11111111</span>]补</span><br></pre></td></tr></table></figure>
<p>特别注意：<strong>在位运算中符号位也参与运算。</strong></p>
<h4 id="2-2-按位非操作"><a href="#2-2-按位非操作" class="headerlink" title="2.2 按位非操作~"></a>2.2 按位非操作~</h4><p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无符号数</span></span><br><span class="line">~ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有符号数</span></span><br><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">~</span><br><span class="line">11 11 10 10 -&gt; -6</span><br><span class="line">-----------------</span><br><span class="line">11 11 10 11 -&gt; -5</span><br><span class="line">~</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>
<h4 id="2-3-按位与操作-amp"><a href="#2-3-按位与操作-amp" class="headerlink" title="2.3 按位与操作&amp;"></a>2.3 按位与操作&amp;</h4><p>只要有一个为0则结果为0，两个都为1则结果为1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">&amp;</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>
<h4 id="2-4-按位或操作"><a href="#2-4-按位或操作" class="headerlink" title="2.4 按位或操作|"></a>2.4 按位或操作|</h4><p>只要两个对应位中有一个 1 时就为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">|</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 11 -&gt; 7</span><br></pre></td></tr></table></figure>
<h4 id="2-5-按位异或操作"><a href="#2-5-按位异或操作" class="headerlink" title="2.5 按位异或操作^"></a>2.5 按位异或操作^</h4><p>两个对应位不同时为1，否则为0</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">^</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 00 11 -&gt; 3</span><br></pre></td></tr></table></figure>
<p>特别注意：<strong>满足交换律和结合律</strong></p>
<h4 id="2-6-按位左移操作-lt-lt"><a href="#2-6-按位左移操作-lt-lt" class="headerlink" title="2.6 按位左移操作&lt;&lt;"></a>2.6 按位左移操作&lt;&lt;</h4><p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位，并且右边用0补齐，所得到的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">01 01 10 00 -&gt; 88</span><br></pre></td></tr></table></figure>
<h4 id="2-7-按位右移操作-gt-gt"><a href="#2-7-按位右移操作-gt-gt" class="headerlink" title="2.7 按位右移操作&gt;&gt;"></a>2.7 按位右移操作&gt;&gt;</h4><p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位，并且左边用0不起，所得到的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">---</span><br><span class="line">00 00 00 10 -&gt; 2</span><br></pre></td></tr></table></figure>
<h4 id="2-8-利用位运算实现快速计算"><a href="#2-8-利用位运算实现快速计算" class="headerlink" title="2.8 利用位运算实现快速计算"></a>2.8 利用位运算实现快速计算</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">n &lt;&lt; 1 -&gt; 计算 n*2</span><br><span class="line">n &gt;&gt; 1 -&gt; 计算 n/2，负奇数的运算不可用</span><br><span class="line">n &lt;&lt; m -&gt; 计算 n*(2^m)，即乘以 2 的 m 次方</span><br><span class="line">n &gt;&gt; m -&gt; 计算 n/(2^m)，即除以 2 的 m 次方</span><br><span class="line">1 &lt;&lt; n -&gt; 2^n</span><br></pre></td></tr></table></figure>
<p>通过异或操作符^可以快速交换两个整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a ^= b <span class="comment"># a = a ^ b</span></span><br><span class="line">b ^= a <span class="comment"># b = b ^ a = b ^ a ^ b = a</span></span><br><span class="line">a ^= b <span class="comment"># a = a ^ b = a ^ b ^ a = b</span></span><br><span class="line"><span class="comment"># 因此达到交换两个整数的目的</span></span><br></pre></td></tr></table></figure>
<h4 id="2-9-利用位运算实现整数集合"><a href="#2-9-利用位运算实现整数集合" class="headerlink" title="2.9 利用位运算实现整数集合"></a>2.9 利用位运算实现整数集合</h4><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。最右边算是第0位。<br>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10</code> 而对应的位运算也就可以看作是对集合进行的操作。<br>元素与集合的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a | (1&lt;&lt;i)  -&gt; 把 i 插入到集合中</span><br><span class="line">a &amp; ~(1&lt;&lt;i) -&gt; 把 i 从集合中删除</span><br><span class="line">a &amp; (1&lt;&lt;i)  -&gt; 判断 i 是否属于该集合（零不属于，非零属于）</span><br></pre></td></tr></table></figure>
<p>集合与集合的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a 补   -&gt; ~a</span><br><span class="line">a 交 b -&gt; a &amp; b</span><br><span class="line">a 并 b -&gt; a | b</span><br><span class="line">a 差 b -&gt; a &amp; (~b)</span><br></pre></td></tr></table></figure>
<h4 id="2-10-leetcode题实战"><a href="#2-10-leetcode题实战" class="headerlink" title="2.10 leetcode题实战"></a>2.10 leetcode题实战</h4><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">leetcode_136 只出现一次的数字</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            ans ^= i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><br><br><br><br>参考文献:</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li>
<li><a href="https://www.cnblogs.com/OliverQin/p/7781019.html" target="_blank" rel="noopener">https://www.cnblogs.com/OliverQin/p/7781019.html</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习笔记，python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>python-异常处理</title>
    <url>/2020/07/22/python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p>
<h3 id="Python标准异常处理总结"><a href="#Python标准异常处理总结" class="headerlink" title="Python标准异常处理总结"></a>Python标准异常处理总结</h3><ul>
<li>BaseException：所有异常的 <strong>基类</strong></li>
<li>Exception：常规异常的 <strong>基类</strong></li>
<li>StandardError：所有的内建标准异常的基类</li>
<li>ArithmeticError：所有数值计算异常的基类</li>
<li>FloatingPointError：浮点计算异常</li>
<li>OverflowError：数值运算超出最大限制</li>
<li>ZeroDivisionError：除数为零</li>
<li>AssertionError：断言语句（assert）失败</li>
<li>AttributeError：尝试访问未知的对象属性</li>
<li>EOFError：没有内建输入，到达EOF标记</li>
<li>EnvironmentError：操作系统异常的基类</li>
<li>IOError：输入/输出操作失败</li>
<li>OSError：操作系统产生的异常（例如打开一个不存在的文件）</li>
<li>WindowsError：系统调用失败</li>
<li>ImportError：导入模块失败的时候</li>
<li>KeyboardInterrupt：用户中断执行</li>
<li>LookupError：无效数据查询的基类</li>
<li>IndexError：索引超出序列的范围</li>
<li>KeyError：字典中查找一个不存在的关键字</li>
<li>MemoryError：内存溢出（可通过删除对象释放内存）</li>
<li>NameError：尝试访问一个不存在的变量</li>
<li>UnboundLocalError：访问未初始化的本地变量</li>
<li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li>
<li>RuntimeError：一般的运行时异常</li>
<li>NotImplementedError：尚未实现的方法</li>
<li>SyntaxError：语法错误导致的异常</li>
<li>IndentationError：缩进错误导致的异常</li>
<li>TabError：Tab和空格混用</li>
<li>SystemError：一般的解释器系统异常</li>
<li>TypeError：不同类型间的无效操作</li>
<li>ValueError：传入无效的参数</li>
<li>UnicodeError：Unicode相关的异常</li>
<li>UnicodeDecodeError：Unicode解码时的异常</li>
<li>UnicodeEncodeError：Unicode编码错误导致的异常</li>
<li>UnicodeTranslateError：Unicode转换错误导致的异常</li>
</ul>
<p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200710131404548.png" style="zoom: 33%;" /></p>
<h3 id="Python标准警告总结"><a href="#Python标准警告总结" class="headerlink" title="Python标准警告总结"></a>Python标准警告总结</h3><ul>
<li>Warning：警告的基类</li>
<li>DeprecationWarning：关于被弃用的特征的警告</li>
<li>FutureWarning：关于构造将来语义会有改变的警告</li>
<li>UserWarning：用户代码生成的警告</li>
<li>PendingDeprecationWarning：关于特性将会被废弃的警告</li>
<li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li>
<li>SyntaxWarning：可疑语法的警告</li>
<li>ImportWarning：用于在导入模块过程中触发的警告</li>
<li>UnicodeWarning：与Unicode相关的警告</li>
<li>BytesWarning：与字节或字节码相关的警告</li>
<li>ResourceWarning：与资源使用相关的警告</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>datawhale，python</tag>
      </tags>
  </entry>
  <entry>
    <title>条件循环结构</title>
    <url>/2020/07/21/python-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="1-1-if语句"><a href="#1-1-if语句" class="headerlink" title="1.1 if语句"></a>1.1 <code>if</code>语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br></pre></td></tr></table></figure>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'Hello python'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hello python</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-if-else语句"><a href="#1-2-if-else语句" class="headerlink" title="1.2 if-else语句"></a>1.2 <code>if-else</code>语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    expr_false_suite</span><br></pre></td></tr></table></figure>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = input(<span class="string">"猜一猜小姐姐想的是哪个数字？"</span>)</span><br><span class="line">guess = int(temp) <span class="comment"># input 函数将接收的任何数据类型都默认为 str。</span></span><br><span class="line"><span class="keyword">if</span> guess == <span class="number">666</span>:</span><br><span class="line">    print(<span class="string">"你太了解小姐姐的心思了！"</span>)</span><br><span class="line">    print(<span class="string">"哼，猜对也没有奖励！"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"猜错了，小姐姐现在心里想的是666！"</span>)</span><br><span class="line">print(<span class="string">"游戏结束，不玩儿啦！"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：python不是使用大括号<code>{}</code>而是通过缩进来标记代码块边界的。</strong></p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hi = <span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> hi &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> hi &gt; <span class="number">7</span>:</span><br><span class="line">        print(<span class="string">'好棒!好棒!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'切~'</span>)</span><br></pre></td></tr></table></figure>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = input(<span class="string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)</span><br><span class="line">guess = int(temp)</span><br><span class="line"><span class="keyword">if</span> guess &gt; <span class="number">8</span>:</span><br><span class="line">    print(<span class="string">"大了，大了"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">8</span>:</span><br><span class="line">        print(<span class="string">"你这么懂小哥哥的心思吗？"</span>)</span><br><span class="line">        print(<span class="string">"哼，猜对也没有奖励！"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"小了，小了"</span>)</span><br><span class="line">print(<span class="string">"游戏结束，不玩儿啦！"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-if-elif-else语句"><a href="#1-3-if-elif-else语句" class="headerlink" title="1.3 if-elif-else语句"></a>1.3 <code>if-elif-else</code>语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1:</span><br><span class="line">    expr1_true_suite</span><br><span class="line"><span class="keyword">elif</span> expression2:</span><br><span class="line">    expr2_true_suite</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="keyword">elif</span> expressionN:</span><br><span class="line">    exprN_true_suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    expr_false_suite</span><br></pre></td></tr></table></figure>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = input(<span class="string">'请输入成绩:'</span>)</span><br><span class="line">source = int(temp)</span><br><span class="line"><span class="keyword">if</span> <span class="number">100</span> &gt;= source &gt;= <span class="number">90</span>:</span><br><span class="line">    print(<span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">90</span> &gt; source &gt;= <span class="number">80</span>:</span><br><span class="line">    print(<span class="string">'B'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">80</span> &gt; source &gt;= <span class="number">60</span>:</span><br><span class="line">    print(<span class="string">'C'</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">60</span> &gt; source &gt;= <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'D'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'输入错误！'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-assert关键词"><a href="#1-4-assert关键词" class="headerlink" title="1.4 assert关键词"></a>1.4 <code>assert</code>关键词</h3><p><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'lsgogroup'</span>]</span><br><span class="line">my_list.pop(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">assert</span> len(my_list) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AssertionError</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-while循环"><a href="#2-1-while循环" class="headerlink" title="2.1 while循环"></a>2.1 <code>while</code>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 布尔表达式:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<h3 id="2-2-while-else循环"><a href="#2-2-while-else循环" class="headerlink" title="2.2 while-else循环"></a>2.2 <code>while-else</code>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 布尔表达式:</span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<p>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。</p>
<h3 id="2-3-for循环"><a href="#2-3-for循环" class="headerlink" title="2.3 for循环"></a>2.3 <code>for</code>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<h3 id="2-4-for-else循环"><a href="#2-4-for-else循环" class="headerlink" title="2.4 for-else循环"></a>2.4 <code>for-else</code>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p>
<h3 id="2-5-range-函数"><a href="#2-5-range-函数" class="headerlink" title="2.5 range()函数"></a>2.5 <code>range()</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">range([start,] stop[, step=<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>这个函数有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li>
<li><code>step=1</code> 表示第三个参数的默认值是1。</li>
<li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li>
</ul>
<h3 id="2-6-enumerate-函数"><a href="#2-6-enumerate-函数" class="headerlink" title="2.6 enumerate()函数"></a>2.6 <code>enumerate()</code>函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>sequence — 一个序列、迭代器或其他支持迭代对象。</li>
<li>start — 下标起始位置。</li>
<li>返回 enumerate(枚举) 对象</li>
</ul>
<h3 id="2-7-推导式"><a href="#2-7-推导式" class="headerlink" title="2.7 推导式"></a>2.7 推导式</h3><ol>
<li><p>列表推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">( expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] )</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合推导式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-练习题"><a href="#3-练习题" class="headerlink" title="3 练习题"></a>3 练习题</h3><p>1、编写一个Python程序来查找那些既可以被7整除又可以被5整除的整数的数字，介于1500和2700之间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">answer = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1500</span>, <span class="number">2700</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">7</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        answer.append(i)</span><br><span class="line">print(answer)</span><br><span class="line"><span class="comment"># [1505, 1540, 1575, 1610, 1645, 1680, 1715, 1750, 1785, 1820, 1855, 1890, 1925, 1960, 1995, 2030, 2065, 2100, 2135, 2170, 2205, 2240, 2275, 2310, 2345, 2380, 2415, 2450, 2485, 2520, 2555, 2590, 2625, 2660, 2695]</span></span><br></pre></td></tr></table></figure>
<p>2、龟兔赛跑游戏</p>
<p>题目描述：</p>
<p>话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 </p>
<p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。</p>
<p>输入:</p>
<p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数) </p>
<p>输出:</p>
<p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 </p>
<p>第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = eval(input(<span class="string">"请依次输入五个正整数v1，v2，t，s，l"</span>))</span><br><span class="line">v2 = eval(input())</span><br><span class="line">t = eval(input())</span><br><span class="line">s = eval(input())</span><br><span class="line">l = eval(input())</span><br><span class="line">time = <span class="number">0</span>     <span class="comment"># 表示获胜者所需要的时间</span></span><br><span class="line">s1 = <span class="number">0</span>       <span class="comment"># 表示兔子走的路程</span></span><br><span class="line">s2 = <span class="number">0</span>       <span class="comment"># 表示乌龟走的路程</span></span><br><span class="line"><span class="keyword">while</span> s1 &lt; l <span class="keyword">and</span> s2 &lt; l:</span><br><span class="line">    s1 = s1 + v1</span><br><span class="line">    s2 = s2 + v2</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s1 == l <span class="keyword">or</span> s2 == l:      <span class="comment"># 有一个到达终点</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> (s1-s2) &gt;= t:            <span class="comment"># 兔子发现比乌龟领先t</span></span><br><span class="line">        s1 = s1 - s*v1</span><br><span class="line"><span class="keyword">if</span> s1 &gt; s2:</span><br><span class="line">    print(<span class="string">"R"</span>)                  <span class="comment"># 兔子赢</span></span><br><span class="line"><span class="keyword">elif</span> s2 &gt; s1:</span><br><span class="line">    print(<span class="string">"T"</span>)                  <span class="comment"># 乌龟赢</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"D"</span>)                  <span class="comment"># 平局</span></span><br><span class="line">print(time)                     <span class="comment"># 输出时间</span></span><br></pre></td></tr></table></figure>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2020/08/03/python-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="1-对象-属性-方法"><a href="#1-对象-属性-方法" class="headerlink" title="1. 对象 = 属性 + 方法"></a>1. 对象 = 属性 + 方法</h2><p>对象是类的实例。换句话说，类主要定义对象的结构，然后我们以类为模板创建对象。类不但包含方法定义，而且还包含所有实例共享的数据。</p>
<ul>
<li>封装：信息隐蔽技术</li>
</ul>
<p>我们可以使用关键字 <code>class</code> 定义 Python 类，关键字后面紧跟类的名称、分号和类的实现。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span>  <span class="comment"># Python中的类名约定以大写字母开头</span></span><br><span class="line">    <span class="string">"""关于类的一个简单例子"""</span></span><br><span class="line">    <span class="comment"># 属性</span></span><br><span class="line">    color = <span class="string">'green'</span></span><br><span class="line">    weight = <span class="number">10</span></span><br><span class="line">    legs = <span class="number">4</span></span><br><span class="line">    shell = <span class="literal">True</span></span><br><span class="line">    mouth = <span class="string">'大嘴'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climb</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我正在很努力的向前爬...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我正在飞快的向前跑...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bite</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'咬死你咬死你!!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'有得吃，真满足...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'困了，睡了，晚安，zzz'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = Turtle()</span><br><span class="line">print(tt)</span><br><span class="line"><span class="comment"># &lt;__main__.Turtle object at 0x0000007C32D67F98&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(tt))</span><br><span class="line"><span class="comment"># &lt;class '__main__.Turtle'&gt;</span></span><br><span class="line"></span><br><span class="line">print(tt.__class__)</span><br><span class="line"><span class="comment"># &lt;class '__main__.Turtle'&gt;</span></span><br><span class="line"></span><br><span class="line">print(tt.__class__.__name__)</span><br><span class="line"><span class="comment"># Turtle</span></span><br><span class="line"></span><br><span class="line">tt.climb()</span><br><span class="line"><span class="comment"># 我正在很努力的向前爬...</span></span><br><span class="line"></span><br><span class="line">tt.run()</span><br><span class="line"><span class="comment"># 我正在飞快的向前跑...</span></span><br><span class="line"></span><br><span class="line">tt.bite()</span><br><span class="line"><span class="comment"># 咬死你咬死你!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python类也是对象。它们是type的实例</span></span><br><span class="line">print(type(Turtle))</span><br><span class="line"><span class="comment"># &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>继承：子类自动共享父类之间数据和方法的机制</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = MyList([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">lst.append(<span class="number">9</span>)</span><br><span class="line">lst.sort()</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 2, 5, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多态：不同对象对同一方法响应不同的行动</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'子类必须实现这个方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'人正在走'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'pig is walking'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'dog is running'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(Pig())</span><br><span class="line"><span class="comment"># pig is walking</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-self-是什么？"><a href="#2-self-是什么？" class="headerlink" title="2. self 是什么？"></a>2. self 是什么？</h2><p>Python 的 <code>self</code> 相当于 C++ 的 <code>this</code> 指针。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line"><span class="comment"># &lt;__main__.Test object at 0x000000BC5A351208&gt;</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.Test'&gt;</span></span><br></pre></td></tr></table></figure>
<p>类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 <code>self</code>。在调用方法时，我们无需明确提供与参数 <code>self</code> 相对应的参数。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kick</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫%s,该死的，谁踢我..."</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Ball()</span><br><span class="line">a.setName(<span class="string">"球A"</span>)</span><br><span class="line">b = Ball()</span><br><span class="line">b.setName(<span class="string">"球B"</span>)</span><br><span class="line">c = Ball()</span><br><span class="line">c.setName(<span class="string">"球C"</span>)</span><br><span class="line">a.kick()</span><br><span class="line"><span class="comment"># 我叫球A,该死的，谁踢我...</span></span><br><span class="line">b.kick()</span><br><span class="line"><span class="comment"># 我叫球B,该死的，谁踢我...</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-Python-的魔法方法"><a href="#3-Python-的魔法方法" class="headerlink" title="3. Python 的魔法方法"></a>3. Python 的魔法方法</h2><p>据说，Python 的对象天生拥有一些神奇的方法，它们是面向对象的 Python 的一切…</p>
<p>它们是可以给你的类增加魔力的特殊方法…</p>
<p>如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的…</p>
<p>类有一个名为<code>__init__(self[, param1, param2...])</code>的魔法方法，该方法在类实例化时会自动调用。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kick</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫%s,该死的，谁踢我..."</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Ball(<span class="string">"球A"</span>)</span><br><span class="line">b = Ball(<span class="string">"球B"</span>)</span><br><span class="line">c = Ball(<span class="string">"球C"</span>)</span><br><span class="line">a.kick()</span><br><span class="line"><span class="comment"># 我叫球A,该死的，谁踢我...</span></span><br><span class="line">b.kick()</span><br><span class="line"><span class="comment"># 我叫球B,该死的，谁踢我...</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-公有和私有"><a href="#4-公有和私有" class="headerlink" title="4. 公有和私有"></a>4. 公有和私有</h2><p>在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了。</p>
<p>【例子】类的私有属性实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>  <span class="comment"># 公开变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        print(self.__secretCount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()  <span class="comment"># 1</span></span><br><span class="line">counter.count()  <span class="comment"># 2</span></span><br><span class="line">print(counter.publicCount)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">print(counter._JustCounter__secretCount)  <span class="comment"># 2 Python的私有为伪私有</span></span><br><span class="line">print(counter.__secretCount)  </span><br><span class="line"><span class="comment"># AttributeError: 'JustCounter' object has no attribute '__secretCount'</span></span><br></pre></td></tr></table></figure>
<p>【例子】类的私有方法实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, url)</span>:</span></span><br><span class="line">        self.name = name  <span class="comment"># public</span></span><br><span class="line">        self.__url = url  <span class="comment"># private</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'name  : '</span>, self.name)</span><br><span class="line">        print(<span class="string">'url : '</span>, self.__url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__foo</span><span class="params">(self)</span>:</span>  <span class="comment"># 私有方法</span></span><br><span class="line">        print(<span class="string">'这是私有方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  <span class="comment"># 公共方法</span></span><br><span class="line">        print(<span class="string">'这是公共方法'</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = Site(<span class="string">'老马的程序人生'</span>, <span class="string">'https://blog.csdn.net/LSGO_MYP'</span>)</span><br><span class="line">x.who()</span><br><span class="line"><span class="comment"># name  :  老马的程序人生</span></span><br><span class="line"><span class="comment"># url :  https://blog.csdn.net/LSGO_MYP</span></span><br><span class="line"></span><br><span class="line">x.foo()</span><br><span class="line"><span class="comment"># 这是公共方法</span></span><br><span class="line"><span class="comment"># 这是私有方法</span></span><br><span class="line"></span><br><span class="line">x.__foo()</span><br><span class="line"><span class="comment"># AttributeError: 'Site' object has no attribute '__foo'</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h2><p>Python 同样支持类的继承，派生类的定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p><code>BaseClassName</code>（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>【例子】如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment"># 定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w, g)</span>:</span></span><br><span class="line">        <span class="comment"># 调用父类的构函</span></span><br><span class="line">        people.__init__(self, n, a, w)</span><br><span class="line">        self.grade = g</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span> % (self.name, self.age, self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = student(<span class="string">'小马的程序人生'</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment"># 小马的程序人生 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure>
<p>注意：如果上面的程序去掉：<code>people.__init__(self, n, a, w)</code>，则输出：<code>说: 我 0 岁了，我在读 3 年级</code>，因为子类的构造方法把父类的构造方法覆盖了。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = r.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        self.y = r.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"我的位置"</span>, self.x, self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoldFish</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 金鱼</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carp</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 鲤鱼</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salmon</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 三文鱼</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shark</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 鲨鱼</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.hungry = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.hungry:</span><br><span class="line">            print(<span class="string">"吃货的梦想就是天天有得吃！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"太撑了，吃不下了！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = GoldFish()</span><br><span class="line">g.move()  <span class="comment"># 我的位置 9 4</span></span><br><span class="line">s = Shark()</span><br><span class="line">s.eat() <span class="comment"># 吃货的梦想就是天天有得吃！</span></span><br><span class="line">s.move()  </span><br><span class="line"><span class="comment"># AttributeError: 'Shark' object has no attribute 'x'</span></span><br></pre></td></tr></table></figure>
<p>解决该问题可用以下两种方式：</p>
<ul>
<li>调用未绑定的父类方法<code>Fish.__init__(self)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shark</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 鲨鱼</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Fish.__init__(self)</span><br><span class="line">        self.hungry = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.hungry:</span><br><span class="line">            print(<span class="string">"吃货的梦想就是天天有得吃！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"太撑了，吃不下了！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用super函数<code>super().__init__()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shark</span><span class="params">(Fish)</span>:</span>  <span class="comment"># 鲨鱼</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hungry = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.hungry:</span><br><span class="line">            print(<span class="string">"吃货的梦想就是天天有得吃！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"太撑了，吃不下了！"</span>)</span><br><span class="line">            self.hungry = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Python 虽然支持多继承的形式，但我们一般不使用多继承，因为容易引起混乱。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="comment"># 定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(People)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w, g)</span>:</span></span><br><span class="line">        <span class="comment"># 调用父类的构函</span></span><br><span class="line">        People.__init__(self, n, a, w)</span><br><span class="line">        self.grade = g</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span> % (self.name, self.age, self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span>:</span></span><br><span class="line">    topic = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, t)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫 %s，我是一个演说家，我演讲的主题是 %s"</span> % (self.name, self.topic))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample01</span><span class="params">(Speaker, Student)</span>:</span></span><br><span class="line">    a = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w, g, t)</span>:</span></span><br><span class="line">        Student.__init__(self, n, a, w, g)</span><br><span class="line">        Speaker.__init__(self, n, t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Sample01(<span class="string">"Tim"</span>, <span class="number">25</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="string">"Python"</span>)</span><br><span class="line">test.speak()  <span class="comment"># 方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample02</span><span class="params">(Student, Speaker)</span>:</span></span><br><span class="line">    a = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, a, w, g, t)</span>:</span></span><br><span class="line">        Student.__init__(self, n, a, w, g)</span><br><span class="line">        Speaker.__init__(self, n, t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Sample02(<span class="string">"Tim"</span>, <span class="number">25</span>, <span class="number">80</span>, <span class="number">4</span>, <span class="string">"Python"</span>)</span><br><span class="line">test.speak()  <span class="comment"># 方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tim 说: 我 25 岁了，我在读 4 年级</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-组合"><a href="#6-组合" class="headerlink" title="6. 组合"></a>6. 组合</h2><p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.num = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.num = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.turtle = Turtle(x)</span><br><span class="line">        self.fish = Fish(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_num</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"水池里面有乌龟%s只，小鱼%s条"</span> % (self.turtle.num, self.fish.num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Pool(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">p.print_num()</span><br><span class="line"><span class="comment"># 水池里面有乌龟2只，小鱼3条</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-类、类对象和实例对象"><a href="#7-类、类对象和实例对象" class="headerlink" title="7. 类、类对象和实例对象"></a>7. 类、类对象和实例对象</h2><p><img src="https://img-blog.csdnimg.cn/20191007090316462.png" alt="类对象和实例对象"></p>
<p>类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化对象 a、b、c都属于实例对象。</span></span><br><span class="line">a = A()</span><br><span class="line">b = A()</span><br><span class="line">c = A()</span><br></pre></td></tr></table></figure>
<p>类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    a = xx  <span class="comment">#类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.a = xx  <span class="comment">#使用类属性可以通过 （类名.类属性）调用。</span></span><br></pre></td></tr></table></figure>
<p>实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为<code>self</code>是谁调用，它的值就属于该对象。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">()</span>:</span></span><br><span class="line">    __init__(self)：</span><br><span class="line">        self.name = xx <span class="comment">#实例属性</span></span><br></pre></td></tr></table></figure>
<p>类属性和实例属性区别</p>
<ul>
<li>类属性：类外面，可以通过<code>实例对象.类属性</code>和<code>类名.类属性</code>进行调用。类里面，通过<code>self.类属性</code>和<code>类名.类属性</code>进行调用。</li>
<li>实例属性 ：类外面，可以通过<code>实例对象.实例属性</code>调用。类里面，通过<code>self.实例属性</code>调用。</li>
<li>实例属性就相当于局部变量。出了这个类或者这个类的实例对象，就没有作用了。</li>
<li>类属性就相当于类里面的全局变量，可以和这个类的所有实例对象共享。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    class_attr = <span class="number">100</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sl_attr = <span class="number">100</span>  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'类对象.类属性的值:'</span>, Test.class_attr)  <span class="comment"># 调用类属性</span></span><br><span class="line">        print(<span class="string">'self.类属性的值'</span>, self.class_attr)  <span class="comment"># 相当于把类属性 变成实例属性</span></span><br><span class="line">        print(<span class="string">'self.实例属性的值'</span>, self.sl_attr)  <span class="comment"># 调用实例属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">a.func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象.类属性的值: 100</span></span><br><span class="line"><span class="comment"># self.类属性的值 100</span></span><br><span class="line"><span class="comment"># self.实例属性的值 100</span></span><br><span class="line"></span><br><span class="line">b = Test()</span><br><span class="line">b.func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象.类属性的值: 100</span></span><br><span class="line"><span class="comment"># self.类属性的值 100</span></span><br><span class="line"><span class="comment"># self.实例属性的值 100</span></span><br><span class="line"></span><br><span class="line">a.class_attr = <span class="number">200</span></span><br><span class="line">a.sl_attr = <span class="number">200</span></span><br><span class="line">a.func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象.类属性的值: 100</span></span><br><span class="line"><span class="comment"># self.类属性的值 200</span></span><br><span class="line"><span class="comment"># self.实例属性的值 200</span></span><br><span class="line"></span><br><span class="line">b.func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象.类属性的值: 100</span></span><br><span class="line"><span class="comment"># self.类属性的值 100</span></span><br><span class="line"><span class="comment"># self.实例属性的值 100</span></span><br><span class="line"></span><br><span class="line">Test.class_attr = <span class="number">300</span></span><br><span class="line">a.func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象.类属性的值: 300</span></span><br><span class="line"><span class="comment"># self.类属性的值 200</span></span><br><span class="line"><span class="comment"># self.实例属性的值 200</span></span><br><span class="line"></span><br><span class="line">b.func()</span><br><span class="line"><span class="comment"># 类对象.类属性的值: 300</span></span><br><span class="line"><span class="comment"># self.类属性的值 300</span></span><br><span class="line"><span class="comment"># self.实例属性的值 100</span></span><br></pre></td></tr></table></figure>
<p>注意：属性与方法名相同，属性会覆盖方法。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'x_man'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aa = A()</span><br><span class="line">aa.x()  <span class="comment"># x_man</span></span><br><span class="line">aa.x = <span class="number">1</span></span><br><span class="line">print(aa.x)  <span class="comment"># 1</span></span><br><span class="line">aa.x()</span><br><span class="line"><span class="comment"># TypeError: 'int' object is not callable</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-什么是绑定？"><a href="#8-什么是绑定？" class="headerlink" title="8. 什么是绑定？"></a>8. 什么是绑定？</h2><p>Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。</p>
<p>Python 对象的数据属性通常存储在名为<code>.__ dict__</code>的字典中，我们可以直接访问<code>__dict__</code>，或利用 Python 的内置函数<code>vars()</code>获取<code>.__ dict__</code>。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setXY</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printXY</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.x, self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dd = CC()</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">print(vars(dd))</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000C3473DA048&gt;, 'printXY': &lt;function CC.printXY at 0x000000C3473C4F28&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line"></span><br><span class="line">dd.setXY(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;'x': 4, 'y': 5&#125;</span></span><br><span class="line"></span><br><span class="line">print(vars(CC))</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line"></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-一些相关的内置函数（BIF）"><a href="#9-一些相关的内置函数（BIF）" class="headerlink" title="9. 一些相关的内置函数（BIF）"></a>9. 一些相关的内置函数（BIF）</h2><ul>
<li><code>issubclass(class, classinfo)</code> 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</li>
<li>一个类被认为是其自身的子类。</li>
<li><code>classinfo</code>可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回<code>True</code>。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(issubclass(B, A))  <span class="comment"># True</span></span><br><span class="line">print(issubclass(B, B))  <span class="comment"># True</span></span><br><span class="line">print(issubclass(A, B))  <span class="comment"># False</span></span><br><span class="line">print(issubclass(B, object))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>isinstance(object, classinfo)</code> 方法用于判断一个对象是否是一个已知的类型，类似<code>type()</code>。</li>
<li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li>
<li>如果第一个参数不是对象，则永远返回<code>False</code>。</li>
<li>如果第二个参数不是类或者由类对象组成的元组，会抛出一个<code>TypeError</code>异常。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">print(isinstance(a, int))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(a, str))  <span class="comment"># False</span></span><br><span class="line">print(isinstance(a, (str, int, list)))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isinstance(A(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(A()) == A)  <span class="comment"># True</span></span><br><span class="line">print(isinstance(B(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(B()) == A)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>hasattr(object, name)</code>用于判断对象是否包含对应的属性。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span>:</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">-5</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point1 = Coordinate()</span><br><span class="line">print(hasattr(point1, <span class="string">'x'</span>))  <span class="comment"># True</span></span><br><span class="line">print(hasattr(point1, <span class="string">'y'</span>))  <span class="comment"># True</span></span><br><span class="line">print(hasattr(point1, <span class="string">'z'</span>))  <span class="comment"># True</span></span><br><span class="line">print(hasattr(point1, <span class="string">'no'</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>getattr(object, name[, default])</code>用于返回一个对象属性值。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(getattr(a, <span class="string">'bar'</span>))  <span class="comment"># 1</span></span><br><span class="line">print(getattr(a, <span class="string">'bar2'</span>, <span class="number">3</span>))  <span class="comment"># 3</span></span><br><span class="line">print(getattr(a, <span class="string">'bar2'</span>))</span><br><span class="line"><span class="comment"># AttributeError: 'A' object has no attribute 'bar2'</span></span><br></pre></td></tr></table></figure>
<p>【例子】这个例子很酷！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        x = a</span><br><span class="line">        a = b</span><br><span class="line">        b = x</span><br><span class="line">        print(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">c = getattr(a, <span class="string">'set'</span>)</span><br><span class="line">c(a=<span class="string">'1'</span>, b=<span class="string">'2'</span>)  <span class="comment"># 2 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>setattr(object, name, value)</code>对应函数 <code>getattr()</code>，用于设置属性值，该属性不一定是存在的。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(getattr(a, <span class="string">'bar'</span>))  <span class="comment"># 1</span></span><br><span class="line">setattr(a, <span class="string">'bar'</span>, <span class="number">5</span>)</span><br><span class="line">print(a.bar)  <span class="comment"># 5</span></span><br><span class="line">setattr(a, <span class="string">"age"</span>, <span class="number">28</span>)</span><br><span class="line">print(a.age)  <span class="comment"># 28</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>delattr(object, name)</code>用于删除属性。</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span>:</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">-5</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point1 = Coordinate()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'x = '</span>, point1.x)  <span class="comment"># x =  10</span></span><br><span class="line">print(<span class="string">'y = '</span>, point1.y)  <span class="comment"># y =  -5</span></span><br><span class="line">print(<span class="string">'z = '</span>, point1.z)  <span class="comment"># z =  0</span></span><br><span class="line"></span><br><span class="line">delattr(Coordinate, <span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'--删除 z 属性后--'</span>)  <span class="comment"># --删除 z 属性后--</span></span><br><span class="line">print(<span class="string">'x = '</span>, point1.x)  <span class="comment"># x =  10</span></span><br><span class="line">print(<span class="string">'y = '</span>, point1.y)  <span class="comment"># y =  -5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发错误</span></span><br><span class="line">print(<span class="string">'z = '</span>, point1.z)</span><br><span class="line"><span class="comment"># AttributeError: 'Coordinate' object has no attribute 'z'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>class property([fget[, fset[, fdel[, doc]]]])</code>用于在新式类中返回属性值。<ul>
<li><code>fget</code> — 获取属性值的函数</li>
<li><code>fset</code> — 设置属性值的函数</li>
<li><code>fdel</code> — 删除属性值函数</li>
<li><code>doc</code> — 属性描述信息</li>
</ul>
</li>
</ul>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc = C()</span><br><span class="line">cc.x = <span class="number">2</span></span><br><span class="line">print(cc.x)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li>
<li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li>
<li><a href="https://www.cnblogs.com/loved/p/8678919.html" target="_blank" rel="noopener">https://www.cnblogs.com/loved/p/8678919.html</a></li>
<li><a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-class.html</a></li>
<li><a href="https://www.jianshu.com/p/9fb316cbf42e" target="_blank" rel="noopener">https://www.jianshu.com/p/9fb316cbf42e</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>图像插值算法</title>
    <url>/2020/08/10/%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>&emsp;在图像处理中，平移变换、旋转变换以及放缩变换是一些基础且常用的操作。<!--more-->这些几何变换并不改变图象的象素值，只是在图象平面上进行象素的重新排列。在一幅输入图象$[u，v]$中，灰度值仅在整数位置上有定义。然而，输出图象[x，y]的灰度值一般由处在非整数坐标上的$（u，v）$值来决定。这就需要插值算法来进行处理，常见的插值算法有最近邻插值、双线性插值和三次样条插值。</p>
<h3 id="1、最近邻插值算法原理"><a href="#1、最近邻插值算法原理" class="headerlink" title="1、最近邻插值算法原理"></a>1、最近邻插值算法原理</h3><p>最近邻插值，是指将目标图像中的点，对应到源图像中后，找到最相邻的整数点，作为插值后的输出。</p>
<p><img src="https://img-blog.csdnimg.cn/20200412101740312.png" alt="img" style="zoom: 25%;" /></p>
<p>&emsp;如上图所示，目标图像中的某点投影到原图像中的位置为点P,此时易知，$f(P) = f(Q11)$.</p>
<p><strong>一个例子：</strong></p>
<p>&emsp;&emsp;如下图所示，将一幅3X3的图像放大到4X4，用$f(x, y)$表示目标图像，$h(x, y)$表示原图像，我们有如下公式：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
f(dst_{X}, dst_{Y}) = h(\frac{dst_{X}src_{Width}}  {dst_{Width}}, \frac{dst_{Y}src_{Height}} {dst_{Height}})
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{c}
f(0,0)=h(0,0) \\
f(0,1)=h(0,0.75)=h(0,1) \\
f(0,2)=h(0,1.50)=h(0,2) \\
f(0,3)=h(0,2.25)=h(0,2) \\
...\\
\end{array}</script><p><img src="https://img-blog.csdnimg.cn/20200412101854853.png" alt="img" style="zoom:25%;" /></p>
<p><strong>缺点：</strong><br>用该方法作放大处理时，在图象中可能出现明显的块状效应</p>
<div align=center><img width="150" height="150" src="https://img-blog.csdnimg.cn/20200412102932888.png#pic_center"/></div>

<h3 id="2、双线性插值"><a href="#2、双线性插值" class="headerlink" title="2、双线性插值"></a>2、双线性插值</h3><p>&emsp;在讲双线性插值之前先看以一下线性插值，线性插值多项式为：</p>
<script type="math/tex; mode=display">
f(x)=a_{1} x+a_{0}</script><p><img src="https://img-blog.csdnimg.cn/20200412103208674.png" alt="img" style="zoom:15%;" /></p>
<script type="math/tex; mode=display">
y=y_{0}+\left(x-x_{0}\right) \frac{y_{1}-y_{0}}{x_{1}-x_{0}}=y_{0}+\frac{\left(x-x_{0}\right) y_{1}-\left(x-x_{0}\right) y_{0}}{x_{1}-x_{0}}</script><p>&emsp;&emsp;双线性插值就是线性插值在二维时的推广,在两个方向上做三次线性插值，具体操作如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2020041210201784.png" alt="img" style="zoom:15%;" /></p>
<p>&emsp;&emsp;令$f(x，y)$为两个变量的函数，其在单位正方形顶点的值已知。假设我们希望通过插值得到正方形内任意点的函数值。则可由双线性方程:</p>
<script type="math/tex; mode=display">
f(x, y)=a x+b y+c x y+d</script><p>&emsp;&emsp;来定义的一个双曲抛物面与四个已知点拟合。</p>
<p>&emsp;&emsp;首先对上端的两个顶点进行线性插值得：</p>
<script type="math/tex; mode=display">
f(x, 0)=f(0,0)+x[f(1,0)-f(0,0)]</script><p>&emsp;&emsp;类似地，再对底端的两个顶点进行线性插值有：</p>
<script type="math/tex; mode=display">
f(x, 1)=f(0,1)+x[f(1,1)-f(0,1)]</script><p>&emsp;&emsp;最后，做垂直方向的线性插值，以确定：</p>
<script type="math/tex; mode=display">
f(x, y)=f(x, 0)+y[f(x, 1)-f(x, 0)]</script><p>&emsp;&emsp;整理得：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
f(x, y)=[f(1,0)-f(0,0)] x+[f(0,1)-f(0,0)] y \\
+[f(1,1)+f(0,0)-f(0,1)-f(1,0)] x y+f(0,0)
\end{array}</script><h3 id="3、基于opencv的实现"><a href="#3、基于opencv的实现" class="headerlink" title="3、基于opencv的实现"></a>3、基于opencv的实现</h3><p><code>cv2.resize(src, dsize[, dst[, fx[, fy[, interpolation]]]])</code></p>
<p><strong>参数：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>【必需】原图像</td>
</tr>
<tr>
<td>dsize</td>
<td>【必需】输出图像所需大小</td>
</tr>
<tr>
<td>fx</td>
<td>【可选】沿水平轴的比例因子</td>
</tr>
<tr>
<td>fy</td>
<td>【可选】沿垂直轴的比例因子</td>
</tr>
<tr>
<td>interpolation</td>
<td>【可选】插值方式</td>
</tr>
</tbody>
</table>
</div>
<p><strong>插值方式：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>cv.INTER_NEAREST</td>
<td>最近邻插值</td>
</tr>
<tr>
<td>cv.INTER_LINEAR</td>
<td>双线性插值</td>
</tr>
<tr>
<td>cv.INTER_CUBIC</td>
<td>基于4x4像素邻域的3次插值法</td>
</tr>
<tr>
<td>cv.INTER_AREA</td>
<td>基于局部像素的重采样</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>通常，缩小使用cv.INTER_AREA，放缩使用cv.INTER_CUBIC(较慢)和cv.INTER_LINEAR(较快效果也不错)。默认情况下，所有的放缩都使用cv.INTER_LINEAR。</p>
</blockquote>
<p>使用python实现了最近邻插值算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearest_resize</span><span class="params">(img, src_size)</span>:</span></span><br><span class="line">    h, w, c = img.shape</span><br><span class="line">    src = np.zeros((src_size[<span class="number">0</span>], src_size[<span class="number">1</span>], <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line">    <span class="keyword">if</span> h == src_size[<span class="number">0</span>] <span class="keyword">and</span> w == src_size[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(src_size[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(src_size[<span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># round()四舍五入的函数</span></span><br><span class="line">            src_x = round(i * (h / src_size[<span class="number">0</span>]))</span><br><span class="line">            src_y = round(j * (w / src_size[<span class="number">1</span>]))</span><br><span class="line">            src[i, j] = img[src_x, src_y]</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">'F:/DataWhale/cv/imgs/4.jpeg'</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"img"</span>, img)</span><br><span class="line">    src = nearest_resize(img, (<span class="number">270</span>, <span class="number">480</span>))</span><br><span class="line">    cv2.imshow(<span class="string">"resize_img"</span>, src)</span><br><span class="line">    cv2.waitKey()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200810131553441.png" alt="image-20200810131553441" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200810131445377.png" alt="image-20200810131445377" style="zoom:50%;" /></p>
<p>用自带的resize()实践</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">'D:/image/yuner.jpg'</span>, cv2.IMREAD_UNCHANGED)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'Original Dimensions : '</span>,img.shape)</span><br><span class="line">    </span><br><span class="line">    scale_percent = <span class="number">30</span>       <span class="comment"># percent of original size</span></span><br><span class="line">    width = int(img.shape[<span class="number">1</span>] * scale_percent / <span class="number">100</span>)</span><br><span class="line">    height = int(img.shape[<span class="number">0</span>] * scale_percent / <span class="number">100</span>)</span><br><span class="line">    dim = (width, height)</span><br><span class="line">    <span class="comment"># resize image</span></span><br><span class="line">    resized = cv2.resize(img, dim, interpolation = cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">    fx = <span class="number">1.5</span></span><br><span class="line">    fy = <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">    resized1 = cv2.resize(resized, dsize=<span class="literal">None</span>, fx=fx, fy=fy, interpolation = cv2.INTER_NEAREST)</span><br><span class="line">    </span><br><span class="line">    resized2 = cv2.resize(resized, dsize=<span class="literal">None</span>, fx=fx, fy=fy, interpolation = cv2.INTER_LINEAR)</span><br><span class="line">    print(<span class="string">'Resized Dimensions : '</span>,resized.shape)</span><br><span class="line">    </span><br><span class="line">    cv2.imshow(<span class="string">"Resized image"</span>, resized)</span><br><span class="line">    cv2.imshow(<span class="string">"INTER_NEAREST image"</span>, resized1)</span><br><span class="line">    cv2.imshow(<span class="string">"INTER_LINEAR image"</span>, resized2)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>cv，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>资金流入流出预测实践</title>
    <url>/2020/08/18/%E8%B5%84%E9%87%91%E6%B5%81%E5%85%A5%E6%B5%81%E5%87%BA%E9%A2%84%E6%B5%8B%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="一、数据探索与分析"><a href="#一、数据探索与分析" class="headerlink" title="一、数据探索与分析"></a>一、数据探索与分析</h3><p>首先来看看<code>seaborn</code>这个库的用法，因为我们在作分析的时候，会频繁的使用这个库。</p>
<p>Seaborn是一种基于matplotlib的图形可视化python libraty。它提供了一种<strong>高度交互式界面</strong>，便于用户能够做出各种有吸引力的统计图表。</p>
<p>Seaborn其实是在matplotlib的基础上进行了更高级的API封装，从而使得<strong>作图更加容易</strong>，在大多数情况下使用seaborn就能做出很具有吸引力的图，而使用matplotlib就能制作具有更多特色的图。应该把Seaborn视为matplotlib的补充，而不是替代物。同时它能高度兼容<strong>numpy</strong>与<strong>pandas</strong>数据结构以及<strong>scipy</strong>与<strong>statsmodels</strong>等统计模式。掌握seaborn能很大程度帮助我们更高效的观察数据与图表，并且更加深入了解它们。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818160001866.png" alt="image-20200818160001866" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818160014476.png" alt="image-20200818160014476" style="zoom:67%;" /></p>
<p>安装seaborn</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> seaborn</span><br><span class="line"><span class="comment"># anaconda 环境中</span></span><br><span class="line">conda <span class="keyword">install</span> seaborn</span><br></pre></td></tr></table></figure>
<p><strong>boxplot</strong> ：箱型图又称为盒须图、盒式图或箱线图，是一种用作显示一组数据分散情况资料的统计图。它能显示出一组数据的<strong>最大值</strong>、<strong>最小值</strong>、<strong>中位数</strong>及<strong>上下四分位数</strong>。因形状如箱子而得名。在各种领域也经常被使用，常见于品质管理。图解如下：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818161401562.png" alt="image-20200818161401562" style="zoom:50%;" /></p>
<p>先来介绍下箱型图的一些统计学的意义：</p>
<ol>
<li>IQR = Q3-Q1，即上四分位数与下四分位数之间的差，也就是盒子的长度。</li>
<li>最小观测值为min = Q1 - 1.5*IQR，如果存在离群点小于最小观测值，则胡须下限为最小观测值，离群点单独以点汇出。如果没有比最小观测值小的数，则胡须下限为最小值。</li>
<li>最大观测值为max = Q3 +1.5*IQR，如果存在离群点大于最大观测值，则胡须上限为最大观测值，离群点单独以点汇出。如果没有比最大观测值大的数，则胡须上限为最大值。</li>
</ol>
<p>接下来我们介绍Seaborn中的箱型图的具体实现方法，这是boxplot的API：</p>
<p><code>seaborn.``boxplot</code><strong>(*</strong>x=None<strong>*,</strong> <em>y=None**</em>,<strong> <em>hue=None</em></strong>,<strong> <em>data=None</em></strong>,<strong> <em>order=None</em></strong>,<strong> <em>hue_order=None</em></strong>,<strong> <em>orient=None</em></strong>,<strong> <em>color=None</em></strong>,<strong> <em>palette=None</em></strong>,<strong> <em>saturation=0.75</em></strong>,<strong> <em>width=0.8</em></strong>,<strong> <em>dodge=True</em></strong>,<strong> <em>fliersize=5</em></strong>,<strong> <em>linewidth=None</em></strong>,<strong> <em>whis=1.5</em></strong>,<strong> <em>ax=None</em></strong>,<strong> *</strong>kwargs<strong>*)</strong></p>
<ul>
<li><p><strong>x，y：</strong>dataframe中的<strong>列名（str）</strong>或者<strong>矢量数据</strong></p>
</li>
<li><p><strong>data：dataframe</strong>或者<strong>数组</strong></p>
</li>
<li><p><strong>palette：</strong>调色板，控制图像的色调</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">sns.boxplot(x=<span class="string">"catagory"</span>,y=<span class="string">"pw"</span>,data=data) <span class="comment">#左图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">sns.boxplot(x=<span class="string">"catagory"</span>,y=<span class="string">"pw"</span>,data=data,palette=<span class="string">"Set3"</span>) <span class="comment">#右图</span></span><br><span class="line"><span class="comment"># 这边使用的是鸢尾花数据集，category代表的是分类，pw则是其中的一个特征。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818160504730.png" alt="image-20200818160504730" style="zoom: 50%;" /></p>
</li>
<li><p><strong>order, hue_order (lists of strings)：用于控制条形图的顺序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.boxplot(x=<span class="string">"catagory"</span>,y=<span class="string">"pw"</span>,data=data,palette=<span class="string">"Set3"</span>,order=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818161053463.png" alt="image-20200818161053463" style="zoom:50%;" /></p>
</li>
<li><p><strong>orient：</strong>“v”|”h” 用于控制图像使水平还是竖直显示（这通常是从输入变量的dtype推断出来的，此参数一般当<strong>不传入x、y，只传入data的时候</strong>使用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.boxplot(data=data,orient=<span class="string">"v"</span>,palette=<span class="string">"Set3"</span>)  <span class="comment">#竖直显示</span></span><br><span class="line">plt.subolot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.boxplot(data=data,orient=<span class="string">"h"</span>,palette=<span class="string">"Set3"</span>)  <span class="comment">#水平显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818161228812.png" alt="image-20200818161228812" style="zoom:50%;" /></p>
</li>
</ul>
<p><strong>violinplot </strong>小提琴图，violinplot与boxplot扮演类似的角色，它显示了定量数据在一个（或多个）分类变量的多个层次上的分布，这些分布可以进行比较。不像箱形图中所有绘图组件都对应于<strong>实际数据点</strong>，小提琴绘图以基础分布的<strong>核密度估计</strong>为特征。具体用法如下：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818195136834.png" alt="image-20200818195136834" style="zoom:67%;" /></p>
<p><code>seaborn.``violinplot</code><strong>(*</strong>x=None<strong>*,</strong> <em>y=None**</em>,<strong> <em>hue=None</em></strong>,<strong> <em>data=None</em></strong>,<strong> <em>order=None</em></strong>,<strong> <em>hue_order=None</em></strong>,<strong> <em>bw=’scott’</em></strong>,<strong> <em>cut=2</em></strong>,<strong> <em>scale=’area’</em></strong>,<strong> <em>scale_hue=True</em></strong>,<strong> <em>gridsize=100</em></strong>,<strong> <em>width=0.8</em></strong>,<strong> <em>inner=’box’</em></strong>,<strong> <em>split=False</em></strong>,<strong> <em>dodge=True</em></strong>,<strong> <em>orient=None</em></strong>,<strong> <em>linewidth=None</em></strong>,<strong> <em>color=None</em></strong>,<strong> <em>palette=None</em></strong>,<strong> <em>saturation=0.75</em></strong>,<strong> <em>ax=None</em></strong>,<strong> *</strong>kwargs<strong>*)</strong></p>
<ul>
<li>bw：‘scott’, ‘silverman’, float，控制拟合程度。在计算内核带宽时，可以引用规则的名称（‘scott’, ‘silverman’）或者使用比例（float）。实际内核大小将通过将比例乘以每个bin内数据的标准差来确定；</li>
<li>cut：空值外壳的延伸超过极值点的密度，float；</li>
<li>scale：“area”, “count”, “width”，用来缩放每把小提琴的宽度的方法；</li>
<li>scale_hue：当使用hue分类后，设置为True时，此参数确定是否在主分组变量进行缩放；</li>
<li>gridsize：设置小提琴图的平滑度，越高越平滑；</li>
<li>inner：“box”, “quartile”, “point”, “stick”, None,小提琴内部数据点的表示。分别表示：箱子，四分位，点，数据线和不表示；</li>
<li>split：是否拆分，当设置为True时，绘制经hue分类的每个级别画出一半的小提琴；</li>
</ul>
<p><strong>barplot</strong> 条形图</p>
<p>条形图因为平时见得比较多，也很容易理解，这边就不细说了，直接看看api文档：</p>
<p><code>seaborn.``barplot</code><strong>(*</strong>x=None<strong>*,</strong> <em>y=None**</em>,<strong> <em>hue=None</em></strong>,<strong> <em>data=None</em></strong>,<strong> <em>order=None</em></strong>,<strong> <em>hue_order=None</em></strong>,<strong> <em>estimator=<function mean at 0x105c7d9e0></em></strong>,<strong> <em>ci=95</em></strong>,<strong> <em>n_boot=1000</em></strong>,<strong> <em>units=None</em></strong>,<strong> <em>seed=None</em></strong>,<strong> <em>orient=None</em></strong>,<strong> <em>color=None</em></strong>,<strong> <em>palette=None</em></strong>,<strong> <em>saturation=0.75</em></strong>,<strong> <em>errcolor=’.26’</em></strong>,<strong> <em>errwidth=None</em></strong>,<strong> <em>capsize=None</em></strong>,<strong> <em>dodge=True</em></strong>,<strong> <em>ax=None</em></strong>,<strong> *</strong>kwargs<strong>*)</strong></p>
<p><strong>heatmap</strong> 热力图。将数据绘制为颜色方格（编码矩阵）</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163311474.png" alt="image-20200818163311474" style="zoom:50%;" /></p>
<p><code>seaborn.``heatmap</code><strong>(*</strong>data<strong>*,</strong> <em>vmin=None**</em>,<strong> <em>vmax=None</em></strong>,<strong> <em>cmap=None</em></strong>,<strong> <em>center=None</em></strong>,<strong> <em>robust=False</em></strong>,<strong> <em>annot=None</em></strong>,<strong> <em>fmt=’.2g’</em></strong>,<strong> <em>annot_kws=None</em></strong>,<strong> <em>linewidths=0</em></strong>,<strong> <em>linecolor=’white’</em></strong>,<strong> <em>cbar=True</em></strong>,<strong> <em>cbar_kws=None</em></strong>,<strong> <em>cbar_ax=None</em></strong>,<strong> <em>square=False</em></strong>,<strong> <em>xticklabels=’auto’</em></strong>,<strong> <em>yticklabels=’auto’</em></strong>,<strong> <em>mask=None</em></strong>,<strong> <em>ax=None</em></strong>,<strong> *</strong>kwargs<strong>*)</strong></p>
<ul>
<li><strong>data :</strong> <strong>要显示的数据</strong></li>
<li><strong>vmin, vmax : 显示的数据值的最大和最小的范围</strong></li>
<li><strong>cmap : matplotlib颜色表名称或对象，或颜色列表，可选从数据值到色彩空间的映射。如果没有提供，默认设置</strong></li>
<li><strong>center :</strong> 指定色彩的中心值</li>
<li><strong>linewidths :</strong> 划分每个单元格的线的宽度。</li>
<li><strong>linecolor :</strong> 划分每个单元格的线的颜色。</li>
</ul>
<p><strong>kdeplot</strong>（核密度估计图）</p>
<p>核密度估计(kernel density estimation)是在<strong>概率论</strong>中用来估计未知的<strong>密度函数</strong>，属于非参数检验方法之一。通过核密度估计图可以比较直观的看出数据样本本身的分布特征。具体用法如下：</p>
<p><code>seaborn.``kdeplot</code><strong>(*</strong>data<strong>*,</strong> <em>data2=None**</em>,<strong> <em>shade=False</em></strong>,<strong> <em>vertical=False</em></strong>,<strong> <em>kernel=’gau’</em></strong>,<strong> <em>bw=’scott’</em></strong>,<strong> <em>gridsize=100</em></strong>,<strong> <em>cut=3</em></strong>,<strong> <em>clip=None</em></strong>,<strong> <em>legend=True</em></strong>,<strong> <em>cumulative=False</em></strong>,<strong> <em>shade_lowest=True</em></strong>,<strong> <em>cbar=False</em></strong>,<strong> <em>cbar_ax=None</em></strong>,<strong> <em>cbar_kws=None</em></strong>,<strong> <em>ax=None</em></strong>,<strong> *</strong>kwargs<strong>*)</strong></p>
<p>绘制简单的一维kde图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=np.random.randn(<span class="number">100</span>)  <span class="comment">#随机生成100个符合正态分布的数sns.kdeplot(x)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163538681.png" alt="image-20200818163538681" style="zoom: 67%;" /></p>
<ul>
<li><p><strong>cut：参数表示绘制的时候，切除带宽往数轴极限数值的多少(默认为3)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(x,cut=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163629675.png" alt="image-20200818163629675" style="zoom:67%;" /></p>
<ul>
<li><p><strong>cumulative ：是否绘制累积分布</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(x,cumulative=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163753989.png" alt="image-20200818163753989" style="zoom:67%;" /></p>
</li>
<li><p><strong>shade：若为True，则在kde曲线下面的区域中进行阴影处理，color控制曲线及阴影的颜色</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(x,shade=<span class="literal">True</span>,color=<span class="string">"g"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163840718.png" alt="image-20200818163840718" style="zoom:67%;" /></p>
</li>
<li><p><strong>vertical：表示以X轴进行绘制还是以Y轴进行绘制</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(x,vertical=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818163916991.png" alt="image-20200818163916991" style="zoom:67%;" /></p>
</li>
</ul>
<p><strong>displot</strong></p>
<p>displot()集合了matplotlib的hist()与核函数估计kdeplot的功能，增加了rugplot分布观测条显示与利用scipy库fit拟合参数分布的新颖用途。具体用法如下：</p>
<p><code>seaborn.``distplot</code><strong>(*</strong>a<strong>*,</strong> <em>bins=None**</em>,<strong> <em>hist=True</em></strong>,<strong> <em>kde=True</em></strong>,<strong> <em>rug=False</em></strong>,<strong> <em>fit=None</em></strong>,<strong> <em>hist_kws=None</em></strong>,<strong> <em>kde_kws=None</em></strong>,<strong> <em>rug_kws=None</em></strong>,<strong> <em>fit_kws=None</em></strong>,<strong> <em>color=None</em></strong>,<strong> <em>vertical=False</em></strong>,<strong> <em>norm_hist=False</em></strong>,<strong> <em>axlabel=None</em></strong>,<strong> <em>label=None</em></strong>,<strong> <em>ax=None</em></strong>)**</p>
<p>先介绍一下直方图(Histograms)：</p>
<p>直方图又称<strong>质量分布图</strong>，它是表示资料变化情况的一种主要工具。用直方图可以解析出资料的规则性，比较直观地看出产品质量特性的分布状态，对于资料分布状况一目了然，便于判断其总体质量分布情况。直方图表示通过沿数据范围<strong>形成分箱</strong>，然后绘制条以<strong>显示落入每个分箱的观测次数</strong>的数据分布。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.distplot(x,color=<span class="string">"g"</span>) <span class="comment"># 数据还是上面的数据</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164146027.png" alt="image-20200818164146027" style="zoom:67%;" /></p>
<p>通过<strong>hist</strong>和<strong>kde</strong>参数调节是否显示直方图及核密度估计(默认hist,kde均为True)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">sns.distplot(x) <span class="comment">#左图</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(x,hist=<span class="literal">False</span>) <span class="comment">#中图</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>) <span class="comment">#右图</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164343792.png" alt="image-20200818164343792" style="zoom:67%;" /></p>
<p><strong>bins：int或list，控制直方图的划分</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,bins=<span class="number">20</span>) <span class="comment">#左图：分成20个区间</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,bins=[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]) <span class="comment">#右图：以0,1,2,3为分割点，形成区间[0,1],[1,2],[2,3]，区间外的值不计入。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164451304.png" alt="image-20200818164451304" style="zoom:67%;" /></p>
<p><strong>rag：控制是否生成观测数值的小细条</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.distplot(x,rug=<span class="literal">True</span>) <span class="comment">#左图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(x) <span class="comment">#右图</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164600207.png" alt="image-20200818164600207" style="zoom:67%;" /></p>
<p><strong>fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系(黑色线条为确定的分布)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> *</span><br><span class="line">sns.distplot(x,hist=<span class="literal">False</span>,fit=norm) <span class="comment">#拟合标准正态分布</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164650557.png" alt="image-20200818164650557" style="zoom:67%;" /></p>
<p><strong>norm_hist：若为True, 则直方图高度显示密度而非计数(含有kde图像中默认为True)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.distplot(x,norm_hist=<span class="literal">True</span>,kde=<span class="literal">False</span>) <span class="comment">#左图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>) <span class="comment">#右图</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818164803349.png" alt="image-20200818164803349" style="zoom:67%;" /></p>
<p>参考博客：</p>
<p><a href="https://www.jianshu.com/p/96977b9869ac" target="_blank" rel="noopener">https://www.jianshu.com/p/96977b9869ac</a></p>
<p><a href="https://www.cnblogs.com/tsingke/p/6565605.html" target="_blank" rel="noopener">https://www.cnblogs.com/tsingke/p/6565605.html</a></p>
<p><a href="https://www.jianshu.com/p/844f66d00ac1" target="_blank" rel="noopener">https://www.jianshu.com/p/844f66d00ac1</a></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础入门nlp-新闻文本分类实战</title>
    <url>/2020/07/20/%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h3><p>&emsp;&emsp;首先要理解赛题的背景及描述——赛题以新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。通过描述，我们可以知道这道题是要==通过给定的一段文本来判断是属于哪一种类别的==。</p>
<p>&emsp;&emsp;赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。处理后的赛题训练数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">label</th>
<th style="text-align:center">text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td>
</tr>
</tbody>
</table>
</div>
<p>标签的对应关系为：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;'科技': <span class="number">0</span>, '股票': <span class="number">1</span>, '体育': <span class="number">2</span>, '娱乐': <span class="number">3</span>, '时政': <span class="number">4</span>, '社会': <span class="number">5</span>, '教育': <span class="number">6</span>, '财经': <span class="number">7</span>, '家居': <span class="number">8</span>, '游戏': <span class="number">9</span>, '房产': <span class="number">10</span>, '时尚': <span class="number">11</span>, '彩票': <span class="number">12</span>, '星座': <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在接触赛题初时，对于这次比赛的评判标准要很清楚！！！</p>
<script type="math/tex; mode=display">
计算公式：2\times \frac{precision \times recall}{precision + recall}</script><p>上述公式也就是F1_score,是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的<strong>精确(precision)</strong>和<strong>召回率(recall)</strong>。F1分数可以看作是模型精确率和召回率的一种调和平均，它的最大值是1，最小值是0。这里提到了精确率和召回率，要想理解这两个还得先知道<strong>TP、FP、TN、FN</strong>这四个概念</p>
<ul>
<li>TP：True Positive ：做出Positive的判定，而且判定是正确的</li>
<li>FP：False Positive ：做出Positive的判定，而且判定是错误的</li>
<li>TN：True Negative ：做出Negative的判定，而且判定是正确的</li>
<li>FN：False Negative：错误的Negative判定，而且判断是错误的</li>
</ul>
<script type="math/tex; mode=display">
precision = \frac{TP}{TP+FP} \\
recall = \frac{TP}{TP+FN}</script><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>出题者提到数据集文件用<code>&#39;\t&#39;</code>分割，因此这样读取数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train_df = pd.read_csv(<span class="string">'../input/train_set.csv'</span>, sep=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200722113005932.png?,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2OTYxMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>上面图中显示的数据，进行了脱敏处理的。</p>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>我们希望通过训练集的数据，通过数据分析得出下列的结论：</p>
<ul>
<li>赛题数据中，新闻文本的长度是多少？</li>
<li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li>
<li>赛题数据中，字符分布是怎么样的？</li>
</ul>
<h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%pylab inline</span><br><span class="line">train_df[<span class="string">'text_len'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: len(x.split(<span class="string">' '</span>)))</span><br><span class="line">print(train_df[<span class="string">'text_len'</span>].describe())</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Populating the interactive namespace <span class="keyword">from</span> numpy <span class="keyword">and</span> matplotlib</span><br><span class="line">count    <span class="number">200000.000000</span></span><br><span class="line">mean        <span class="number">907.207110</span></span><br><span class="line">std         <span class="number">996.029036</span></span><br><span class="line">min           <span class="number">2.000000</span></span><br><span class="line"><span class="number">25</span>%         <span class="number">374.000000</span></span><br><span class="line"><span class="number">50</span>%         <span class="number">676.000000</span></span><br><span class="line"><span class="number">75</span>%        <span class="number">1131.000000</span></span><br><span class="line">max       <span class="number">57921.000000</span></span><br><span class="line">Name: text_len, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过上面的结果，可以看出200000个句子，每个句子平局由907个字符组成，最短的由两个字符组成，最长的达到57921个字符。</p>
<p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_ = plt.hist(train_df[<span class="string">'text_len'</span>], bins=<span class="number">200</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Text char count'</span>)</span><br><span class="line">plt.title(<span class="string">"Histogram of char count"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203836905.png" alt="task2_char_hist" style="zoom:50%;" /></p>
<h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_df[<span class="string">'label'</span>].value_counts().plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.title(<span class="string">'News class count'</span>)</span><br><span class="line">plt.xlabel(<span class="string">"category"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200714203929296.png" alt="task2_class_hist" style="zoom:50%;" /></p>
<p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p>
<p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p>
<h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(len(word_count))</span><br><span class="line"><span class="comment"># 6869</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 7482224)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># ('3133', 1)</span></span><br></pre></td></tr></table></figure>
<p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p>
<p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_df[<span class="string">'text_unique'</span>] = train_df[<span class="string">'text'</span>].apply(<span class="keyword">lambda</span> x: <span class="string">' '</span>.join(list(set(x.split(<span class="string">' '</span>)))))</span><br><span class="line">all_lines = <span class="string">' '</span>.join(list(train_df[<span class="string">'text_unique'</span>]))</span><br><span class="line">word_count = Counter(all_lines.split(<span class="string">" "</span>))</span><br><span class="line">word_count = sorted(word_count.items(), key=<span class="keyword">lambda</span> d:int(d[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># ('3750', 197997)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># ('900', 197653)</span></span><br><span class="line"></span><br><span class="line">print(word_count[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># ('648', 191975)</span></span><br></pre></td></tr></table></figure>
<p>通过上述分析的总结：</p>
<ol>
<li>赛题中每个新闻包含的字符个数平均为900个，还有一些新闻字符较长；</li>
<li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li>
<li>赛题总共包括7000左右个字符；</li>
</ol>
<p>因此得出的结论：</p>
<ol>
<li><p>每个新闻平均字符个数较多，可能需要截断；</p>
</li>
<li><p>由于类别不均衡，会严重影响模型的精度；</p>
</li>
</ol>
<h3 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>&emsp;&emsp;在自然语言领域，文本的长度是不确定的。文本表示成计算机能够运算的数字或向量的方法一般为词嵌入(Word Embedding)方法。词嵌入将不定长的文本转换到定长的空间去，是文本分类的第一步。</p>
<h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p>
<p>One-hot表示方法的例子如下：假设有两个句子如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">句子<span class="number">1</span>：我 爱 北 京 天 安 门</span><br><span class="line">句子<span class="number">2</span>：我 喜 欢 上 海</span><br></pre></td></tr></table></figure>
<p>首先对所有的句子的字进行编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">'我'</span>: <span class="number">1</span>, <span class="string">'爱'</span>: <span class="number">2</span>, <span class="string">'北'</span>: <span class="number">3</span>, <span class="string">'京'</span>: <span class="number">4</span>, <span class="string">'天'</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">'安'</span>: <span class="number">6</span>, <span class="string">'门'</span>: <span class="number">7</span>, <span class="string">'喜'</span>: <span class="number">8</span>, <span class="string">'欢'</span>: <span class="number">9</span>, <span class="string">'上'</span>: <span class="number">10</span>, <span class="string">'海'</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">我：[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">爱：[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">...</span><br><span class="line">海：[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p>
<p>直接统计每个字出现的次数，并进行赋值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">句子<span class="number">1</span>：我 爱 北 京 天 安 门</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">句子<span class="number">2</span>：我 喜 欢 上 海</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>再看两句英语的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">句子<span class="number">1</span>：John likes to watch movies. Mary likes too.</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">句子<span class="number">2</span>：John also likes to watch football games.</span><br><span class="line">转换为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>不过这种表示方法有个缺点，<strong>在构造文档向量的过程中可以看到，我们并没有表达单词在原来句子中出现的顺序。</strong></p>
<p>下面来看一个用sklearn实现的例子：</p>
<p>安装sklearn库一句话就搞定了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install scikit-learn</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># array([[0, 1, 1, 1, 0, 0, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [0, 2, 0, 1, 0, 1, 1, 0, 1],</span></span><br><span class="line"><span class="comment">#        [1, 0, 0, 1, 1, 0, 1, 1, 1],</span></span><br><span class="line"><span class="comment">#        [0, 1, 1, 1, 0, 0, 1, 0, 1]], dtype=int64)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CountVectorizer(*, input=<span class="string">'content'</span>, encoding=<span class="string">'utf-8'</span>, decode_error=<span class="string">'strict'</span>, strip_accents=<span class="literal">None</span>, lowercase=<span class="literal">True</span>, preprocessor=<span class="literal">None</span>, tokenizer=<span class="literal">None</span>, stop_words=<span class="literal">None</span>, token_pattern=<span class="string">'(?u)\b\w\w+\b'</span>, ngram_range=(<span class="number">1</span>, <span class="number">1</span>), analyzer=<span class="string">'word'</span>, max_df=<span class="number">1.0</span>, min_df=<span class="number">1</span>, max_features=<span class="literal">None</span>, vocabulary=<span class="literal">None</span>, binary=<span class="literal">False</span>, dtype=&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">int64</span>'&gt;)</span></span><br></pre></td></tr></table></figure>
<p>其实上面的代码也是sklearn中一贯的套路了，<strong>先创建一个类，然后把数据扔进fit_transform()</strong>，就得到结果了，只不过这里还多了一步，把结果转成了ndarray。</p>
<h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>F-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p>
<script type="math/tex; mode=display">
TF=\frac{在某一类中词条w出现的次数}{该类中所有的词条数目} \\
IDF=\log{\frac{语料库的文档总数}{包含词条w的文档数+1}}\\
TF-IDF=TF\times IDF</script><p>分母之所以要加1，是为了避免分母为0。</p>
<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line">corpus = [</span><br><span class="line">    <span class="string">'This is the first document.'</span>,</span><br><span class="line">    <span class="string">'This document is the second document.'</span>,</span><br><span class="line">    <span class="string">'And this is the third one.'</span>,</span><br><span class="line">    <span class="string">'Is this the first document?'</span>,</span><br><span class="line">]</span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">vectorizer.fit_transform(corpus).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果 </span></span><br><span class="line"><span class="comment"># array([[0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.6876236 , 0.        , 0.28108867, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.53864762, 0.28108867, 0.        , 0.28108867],</span></span><br><span class="line"><span class="comment">#        [0.51184851, 0.        , 0.        , 0.26710379, 0.51184851,</span></span><br><span class="line"><span class="comment">#         0.        , 0.26710379, 0.51184851, 0.26710379],</span></span><br><span class="line"><span class="comment">#        [0.        , 0.46979139, 0.58028582, 0.38408524, 0.        ,</span></span><br><span class="line"><span class="comment">#         0.        , 0.38408524, 0.        , 0.38408524]])</span></span><br></pre></td></tr></table></figure>
<p>跟CountVectors的代码几乎一样就是CountVectorizer()变成了TfidfVectorizer()。</p>
<h4 id="RidgeClassifier-岭回归分类器"><a href="#RidgeClassifier-岭回归分类器" class="headerlink" title="RidgeClassifier(岭回归分类器)"></a>RidgeClassifier(岭回归分类器)</h4><p>&emsp;&emsp;简单介绍下，因为后面有用到分类。简单理解就跟LogisticRegression差不太多，把他们看成相似的作用就行了，细节就不过多说。</p>
<p>&emsp;&emsp;这个分类器有时被称为带有线性核的最小二乘支持向量机。该分类器首先将二进制目标转换为{- 1,1}，然后将该问题视为回归任务，优化与上面相同的目标。预测类对应于回归预测的符号，对于多类分类，将问题视为多输出回归，预测类对应的输出值最大。该分类器使用(惩罚)最小二乘损失来适应分类模型，而不是使用更传统的逻辑或铰链损失(最大边界损失)，在实践中，所有这些模型在准确性或精度/召回率方面都可能导致类似的交叉验证分数，而RidgeClassifier使用的惩罚最小二乘损失允许对具有不同计算性能概要的数值求解器进行各自不同的选择。</p>
<p>接下来我们将对比不同文本表示算法的精度，通过代码本地构建验证集计算F1得分。使用sklearn库中的函数实现。</p>
<p><strong>Count Vectors + RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">vectorizer = CountVectorizer(max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = vectorizer.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.74</span></span><br></pre></td></tr></table></figure>
<p><strong>TF-IDF +  RidgeClassifier</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line">tfidf = TfidfVectorizer(ngram_range=(<span class="number">1</span>,<span class="number">3</span>), max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = tfidf.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.87</span></span><br></pre></td></tr></table></figure>
<h3 id="基于深度学习的文本分类1"><a href="#基于深度学习的文本分类1" class="headerlink" title="基于深度学习的文本分类1"></a>基于深度学习的文本分类1</h3><p><strong>FastText</strong></p>
<p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p>
<p>优点：使用Embedding能提高计算的效率。</p>
<p>如下图所示，FastText是一个三层的神经网络，输入层、隐藏层和输出层。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204856589.png" alt="fast_text" style="zoom: 25%;" /></p>
<p>下图是使用keras实现的FastText网络结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714204249463.jpg" alt="keras_fasttext"  /></p>
<p>FastText安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、pip安装</span></span><br><span class="line">pip install fasttext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、源码安装</span></span><br><span class="line">git clone https://github.com/facebookresearch/fastText.git</span><br><span class="line">cd fastText</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为FastText需要的格式</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line">model = fastfasttext.train_supervised(<span class="string">'train.csv'</span>, lr=<span class="number">1.0</span>, wordNgrams=<span class="number">2</span>, </span><br><span class="line">                                  verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line"></span><br><span class="line">val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br><span class="line"><span class="comment"># 0.82</span></span><br></pre></td></tr></table></figure>
<p><code>fastfasttext.train_supervised</code>中的参数含义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input             <span class="comment"># training file path (required) 文件路径</span></span><br><span class="line">lr                <span class="comment"># learning rate [0.1]	学习率</span></span><br><span class="line">dim               <span class="comment"># size of word vectors [100] 向量维度</span></span><br><span class="line">ws                <span class="comment"># size of the context window [5] 上下文窗口的大小</span></span><br><span class="line">epoch             <span class="comment"># number of epochs [5] 迭代次数</span></span><br><span class="line">minCount          <span class="comment"># minimal number of word occurences [1] 词出现的最少次数</span></span><br><span class="line">minCountLabel     <span class="comment"># minimal number of label occurences [1] 标签出现的最少次数</span></span><br><span class="line">minn              <span class="comment"># min length of char ngram [0] char ngram的最小长度</span></span><br><span class="line">maxn              <span class="comment"># max length of char ngram [0] char ngram的最大长度</span></span><br><span class="line">neg               <span class="comment"># number of negatives sampled [5] 负样本的个数</span></span><br><span class="line">wordNgrams        <span class="comment"># max length of word ngram [1] ngram的最大长度</span></span><br><span class="line">loss              <span class="comment"># loss function &#123;ns, hs, softmax, ova&#125; [softmax] 损失函数</span></span><br><span class="line">bucket            <span class="comment"># number of buckets [2000000] 桶的个数</span></span><br><span class="line">thread            <span class="comment"># number of threads [number of cpus] 线程个数</span></span><br><span class="line">lrUpdateRate      <span class="comment"># change the rate of updates for the learning rate [100] 更改学习速率的更新速率</span></span><br><span class="line">t                 <span class="comment"># sampling threshold [0.0001] 抽样阈值</span></span><br><span class="line">label             <span class="comment"># label prefix ['__label__'] 标签前缀</span></span><br><span class="line">verbose           <span class="comment"># verbose [2]</span></span><br><span class="line">pretrainedVectors <span class="comment"># pretrained word vectors (.vec file) for supervised learning []</span></span><br></pre></td></tr></table></figure>
<p>下面稍微调整了下参数，学习率取[1.1, 1.2, 1.3, 1.4, ,1.5]，wordNgrams取[1,2,3]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">'train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>]:</span><br><span class="line">    print(<span class="string">"Current lr is: "</span>, lr)</span><br><span class="line">    <span class="keyword">for</span> wordNGram <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">        print(<span class="string">"Current wordNgrams is:"</span>, wordNGram)</span><br><span class="line">        model = fasttext.train_supervised(<span class="string">'train.csv'</span>, lr=lr, wordNgrams=wordNGram, </span><br><span class="line">                              verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line">        val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line">        print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>
<p>通过简单的调参，发现wordNgrams=3，lr=(1.4，1.5)效果比较好。</p>
<h3 id="基于深度学习的文本分类2"><a href="#基于深度学习的文本分类2" class="headerlink" title="基于深度学习的文本分类2"></a>基于深度学习的文本分类2</h3><p><strong>Word2Vec</strong></p>
<p>主要思路：通过单词和上下文彼此预测，对应的两个算法分布为：</p>
<ul>
<li><p>Skip-grams (SG)：通过给定Input word来预测上下文</p>
</li>
<li><p>Continuous Bag of Words (CBOW)：通过给定上下文来预测目标单词</p>
</li>
</ul>
<h5 id="1、Skip-grams原理和网络结构"><a href="#1、Skip-grams原理和网络结构" class="headerlink" title="1、Skip-grams原理和网络结构"></a>1、Skip-grams原理和网络结构</h5><p><img src="https://img-blog.csdnimg.cn/20200714210354729.png" alt="skip_grams" style="zoom: 33%;" /></p>
<p>Word2Vec模型实际上分为了两个部分，第一部分为建立模型，第二部分是通过模型获取嵌入词向量。</p>
<p>Word2Vec的整个建模过程实际上与自编码器（auto-encoder）的思想很相似，即先基于训练数据构建一个神经网络，当这个模型训练好以后，我们并不会用这个训练好的模型处理新的任务，我们真正需要的是这个模型通过训练数据所学得的参数，例如隐层的权重矩阵——后面我们将会看到这些权重在Word2Vec中实际上就是我们试图去学习的“word vectors”。</p>
<p>Skip-grams过程</p>
<p>假如我们有一个句子“The dog barked at the mailman”。</p>
<ol>
<li><p>首先我们选句子中间的一个词作为我们的输入词，例如我们选取“dog”作为input word；</p>
</li>
<li><p>有了input word以后，我们再定义一个叫做skip_window的参数，它代表着我们从当前input word的一侧（左边或右边）选取词的数量。如果我们设置skip_window=2，那么我们最终获得窗口中的词（包括input word在内）就是[‘The’, ‘dog’，’barked’, ‘at’]。skip_window=2代表着选取左input word左侧2个词和右侧2个词进入我们的窗口，所以整个窗口大小span=2x2=4。另一个参数叫num_skips，它代表着我们从整个窗口中选取多少个不同的词作为我们的output word，当skip_window=2，num_skips=2时，我们将会得到两组 (input word, output word) 形式的训练数据，即 (‘dog’, ‘barked’)，(‘dog’, ‘the’)。</p>
</li>
<li><p>神经网络基于这些训练数据将会输出一个概率分布，这个概率代表着我们的词典中的每个词作为input word的output word的可能性。这句话有点绕，我们来看个例子。第二步中我们在设置skip_window和num_skips=2的情况下获得了两组训练数据。假如我们先拿一组数据 (‘dog’, ‘barked’) 来训练神经网络，那么模型通过学习这个训练样本，会告诉我们词汇表中每个单词当’dog’作为input word时，其作为output word的可能性。</p>
</li>
</ol>
<p>也就是说模型的输出概率代表着到我们词典中每个词有多大可能性跟input word同时出现。例如：如果我们向神经网络模型中输入一个单词“Soviet“，那么最终模型的输出概率中，像“Union”， ”Russia“这种相关词的概率将远高于像”watermelon“，”kangaroo“非相关词的概率。因为”Union“，”Russia“在文本中更大可能在”Soviet“的窗口中出现。</p>
<p>我们将通过给神经网络输入文本中成对的单词来训练它完成上面所说的概率计算。下面的图中给出了一些我们训练样本的例子。我们选定句子“The quick brown fox jumps over lazy dog”，设定我们的窗口大小为2（window_size=2），也就是说我们仅选输入词前后各两个词和输入词进行组合。下图中，蓝色代表input word，方框内代表位于窗口内的单词。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom:40%;" /></p>
<p><img src="https://img-blog.csdnimg.cn/20200714210519939.png" alt="2" style="zoom: 40%;" /></p>
<p>我们的模型将会从每对单词出现的次数中习得统计结果。例如，我们的神经网络可能会得到更多类似（“Soviet“，”Union“）这样的训练样本对，而对于（”Soviet“，”Sasquatch“）这样的组合却看到的很少。因此，当我们的模型完成训练后，给定一个单词”Soviet“作为输入，输出的结果中”Union“或者”Russia“要比”Sasquatch“被赋予更高的概率。</p>
<p>PS：input word和output word都会被我们进行one-hot编码。仔细想一下，我们的输入被one-hot编码以后大多数维度上都是0（实际上仅有一个位置为1），所以这个向量相当稀疏，那么会造成什么结果呢。如果我们将一个1 x 10000的向量和10000 x 300的矩阵相乘，它会消耗相当大的计算资源，为了高效计算，它仅仅会选择矩阵中对应的向量中维度值为1的索引行：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205344406.png" alt=""></p>
<p><strong>2. Skip-grams训练</strong></p>
<p>由上部分可知，Word2Vec模型是一个超级大的神经网络（权重矩阵规模非常大）。例如：我们拥有10000个单词的词汇表，我们如果想嵌入300维的词向量，那么我们的输入-隐层权重矩阵和隐层-输出层的权重矩阵都会有 10000 x 300 = 300万个权重，在如此庞大的神经网络中进行梯度下降是相当慢的。更糟糕的是，你需要大量的训练数据来调整这些权重并且避免过拟合。百万数量级的权重矩阵和亿万数量级的训练样本意味着训练这个模型将会是个灾难</p>
<p>解决方案：</p>
<ul>
<li><p>将常见的单词组合（word pairs）或者词组作为单个“words”来处理</p>
</li>
<li><p>对高频次单词进行抽样来减少训练样本的个数</p>
</li>
<li><p>对优化目标采用“negative sampling”方法，这样每个训练样本的训练只会更新一小部分的模型权重，从而降低计算负担</p>
</li>
</ul>
<p><em>2.1 Word pairs and “phases”</em></p>
<p>一些单词组合（或者词组）的含义和拆开以后具有完全不同的意义。比如“Boston Globe”是一种报刊的名字，而单独的“Boston”和“Globe”这样单个的单词却表达不出这样的含义。因此，在文章中只要出现“Boston Globe”，我们就应该把它作为一个单独的词来生成其词向量，而不是将其拆开。同样的例子还有“New York”，“United Stated”等。</p>
<p>在Google发布的模型中，它本身的训练样本中有来自Google News数据集中的1000亿的单词，但是除了单个单词以外，单词组合（或词组）又有3百万之多。</p>
<p><em>2.2 对高频词抽样</em></p>
<p>在上一部分中，对于原始文本为“The quick brown fox jumps over the laze dog”，如果使用大小为2的窗口，那么我们可以得到图中展示的那些训练样本。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210458879.png" alt="1" style="zoom: 50%;" /></p>
<p>但是对于“the”这种常用高频单词，这样的处理方式会存在下面两个问题：</p>
<ol>
<li><p>当我们得到成对的单词训练样本时，(“fox”, “the”) 这样的训练样本并不会给我们提供关于“fox”更多的语义信息，因为“the”在每个单词的上下文中几乎都会出现</p>
</li>
<li><p>由于在文本中“the”这样的常用词出现概率很大，因此我们将会有大量的（”the“，…）这样的训练样本，而这些样本数量远远超过了我们学习“the”这个词向量所需的训练样本数</p>
</li>
</ol>
<p>Word2Vec通过“抽样”模式来解决这种高频词问题。它的基本思想如下：对于我们在训练原始文本中遇到的每一个单词，它们都有一定概率被我们从文本中删掉，而这个被删除的概率与单词的频率有关。</p>
<p>ωi 是一个单词，Z(ωi) 是 ωi 这个单词在所有语料中出现的频次，例如：如果单词“peanut”在10亿规模大小的语料中出现了1000次，那么 Z(peanut) = 1000/1000000000 = 1e - 6。</p>
<p>P(ωi) 代表着保留某个单词的概率：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205456898.png" alt=""></p>
<p><em>2.3 Negative sampling</em></p>
<p>训练一个神经网络意味着要输入训练样本并且不断调整神经元的权重，从而不断提高对目标的准确预测。每当神经网络经过一个训练样本的训练，它的权重就会进行一次调整。</p>
<p>所以，词典的大小决定了我们的Skip-Gram神经网络将会拥有大规模的权重矩阵，所有的这些权重需要通过数以亿计的训练样本来进行调整，这是非常消耗计算资源的，并且实际中训练起来会非常慢。</p>
<p>负采样（negative sampling）解决了这个问题，它是用来提高训练速度并且改善所得到词向量的质量的一种方法。不同于原本每个训练样本更新所有的权重，负采样每次让一个训练样本仅仅更新一小部分的权重，这样就会降低梯度下降过程中的计算量。</p>
<p>当我们用训练样本 ( input word: “fox”，output word: “quick”) 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的词典大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们期望输出为0的神经元结点所对应的单词我们称为“negative” word。</p>
<p>当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重。我们也会对我们的“positive” word进行权重更新（在我们上面的例子中，这个单词指的是”quick“）。</p>
<p>PS: 在论文中，作者指出指出对于小规模数据集，选择5-20个negative words会比较好，对于大规模数据集可以仅选择2-5个negative words。</p>
<p>我们使用“一元模型分布（unigram distribution）”来选择“negative words”。个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words。</p>
<p>每个单词被选为“negative words”的概率计算公式：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205545327.png" alt=""></p>
<p>其中 f(ωi)代表着单词出现的频次，而公式中开3/4的根号完全是基于经验的。</p>
<p>在代码负采样的代码实现中，unigram table有一个包含了一亿个元素的数组，这个数组是由词汇表中每个单词的索引号填充的，并且这个数组中有重复，也就是说有些单词会出现多次。那么每个单词的索引在这个数组中出现的次数该如何决定呢，有公式，也就是说计算出的负采样概率*1亿=单词在表中出现的次数。</p>
<p>有了这张表以后，每次去我们进行负采样时，只需要在0-1亿范围内生成一个随机数，然后选择表中索引号为这个随机数的那个单词作为我们的negative word即可。一个单词的负采样概率越大，那么它在这个表中出现的次数就越多，它被选中的概率就越大。</p>
<p><strong>使用gensim训练word2vec</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gensim</span>.<span class="title">models</span>.<span class="title">word2vec</span>.<span class="title">Word2Vec</span><span class="params">(sentences=None, corpus_file=None, size=<span class="number">100</span>, alpha=<span class="number">0.025</span>, window=<span class="number">5</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">min_count=<span class="number">5</span>,  max_vocab_size=None, sample=<span class="number">0.001</span>, seed=<span class="number">1</span>, workers=<span class="number">3</span>, min_alpha=<span class="number">0.0001</span>, sg=<span class="number">0</span>, hs=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">negative=<span class="number">5</span>, ns_exponent=<span class="number">0.75</span>, cbow_mean=<span class="number">1</span>, hashfxn=&lt;built-in function hash&gt;, iter=<span class="number">5</span>, null_word=<span class="number">0</span>, trim_rule=None, </span></span></span><br><span class="line"><span class="class"><span class="params">sorted_vocab=<span class="number">1</span>, batch_words=<span class="number">10000</span>, compute_loss=False, callbacks=<span class="params">()</span>, max_final_vocab=None)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>sentences</strong> (iterable of iterables, optional) – 供训练的句子，可以使用简单的列表，但是对于大语料库，建议直接从磁盘/网络流迭代传输句子。参阅word2vec模块中的BrownCorpus，Text8Corpus或LineSentence。</li>
<li><strong>corpus_file</strong> (str, optional) – LineSentence格式的语料库文件路径。</li>
<li><strong>size</strong> (int, optional) – word向量的维度。</li>
<li><strong>window</strong> (int, optional) – 一个句子中当前单词和被预测单词的最大距离。</li>
<li><strong>min_count</strong> (int, optional) – 忽略词频小于此值的单词。</li>
<li><strong>workers</strong> (int, optional) – 训练模型时使用的线程数。</li>
<li><strong>sg</strong> ({0, 1}, optional) – 模型的训练算法: 1: skip-gram; 0: CBOW.</li>
<li><strong>hs</strong> ({0, 1}, optional) – 1: 采用hierarchical softmax训练模型; 0: 使用负采样。</li>
<li><strong>negative</strong> (int, optional) – &gt; 0: 使用负采样，设置多个负采样(通常在5-20之间)。</li>
<li><strong>ns_exponent</strong> (float, optional) – 负采样分布指数。1.0样本值与频率成正比，0.0样本所有单词均等，负值更多地采样低频词。</li>
<li><strong>cbow_mean</strong> ({0, 1}, optional) – 0: 使用上下文单词向量的总和; 1: 使用均值，适用于使用CBOW。</li>
<li><strong>alpha</strong> (float, optional) – 初始学习率。</li>
<li><strong>min_alpha</strong> (float, optional) – 随着训练的进行，学习率线性下降到min_alpha。</li>
<li><strong>seed</strong> (int, optional) – 随机数发生器种子。</li>
<li><strong>max_vocab_size</strong> (int, optional) – 词汇构建期间RAM的限制; 如果有更多的独特单词，则修剪不常见的单词。 每1000万个类型的字需要大约1GB的RAM。</li>
<li><strong>max_final_vocab</strong> (int, optional) – 自动选择匹配的min_count将词汇限制为目标词汇大小。</li>
<li><strong>sample</strong> (float, optional) – 高频词随机下采样的配置阈值，范围是(0,1e-5)。</li>
<li><strong>hashfxn</strong> (function, optional) – 哈希函数用于随机初始化权重，以提高训练的可重复性。</li>
<li><strong>iter</strong> (int, optional) – 迭代次数。</li>
<li><strong>trim_rule</strong> (function, optional) – 词汇修剪规则，指定某些词语是否应保留在词汇表中，修剪掉或使用默认值处理。</li>
<li><strong>sorted_vocab</strong> ({0, 1}, optional) – 如果为1，则在分配单词索引前按降序对词汇表进行排序。</li>
<li><strong>batch_words</strong> (int, optional) – 每一个batch传递给线程单词的数量。</li>
<li><strong>compute_loss</strong> (bool, optional) – 如果为True，则计算并存储可使用get_latest_training_loss()检索的损失值。</li>
<li><strong>callbacks</strong> (iterable of CallbackAny2Vec, optional) – 在训练中特定阶段执行回调序列。</li>
</ul>
<p><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="noopener">官方文档链接</a></p>
<h5 id="2、TextCNN"><a href="#2、TextCNN" class="headerlink" title="2、TextCNN"></a>2、TextCNN</h5><p>TextCNN利用CNN（卷积神经网络）进行文本特征抽取，不同大小的卷积核分别抽取n-gram特征，卷积计算出的特征图经过MaxPooling保留最大的特征值，然后将拼接成一个向量作为文本的表示。</p>
<p>这里我们基于TextCNN原始论文的设定，分别采用了100个大小为2,3,4的卷积核，最后得到的文本向量大小为100*3=300维。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714205932720.jpeg" alt=""></p>
<h5 id="3、TextRNN"><a href="#3、TextRNN" class="headerlink" title="3、TextRNN"></a>3、TextRNN</h5><p>extRNN利用RNN（循环神经网络）进行文本特征抽取，由于文本本身是一种序列，而LSTM天然适合建模序列数据。TextRNN将句子中每个词的词向量依次输入到双向双层LSTM，分别将两个方向最后一个有效位置的隐藏层拼接成一个向量作为文本的表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714210806492.png" alt="5" style="zoom: 40%;" /></p>
<p>代码实现(Pytorch)：</p>
<p><strong>TextCNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">self.filter_sizes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># n-gram window</span></span><br><span class="line">self.out_channel = <span class="number">100</span></span><br><span class="line">self.convs = nn.ModuleList([nn.Conv2d(<span class="number">1</span>, self.out_channel, (filter_size, input_size), bias=<span class="literal">True</span>) <span class="keyword">for</span> filter_size <span class="keyword">in</span> self.filter_sizes])</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pooled_outputs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.filter_sizes)):</span><br><span class="line">    filter_height = sent_len - self.filter_sizes[i] + <span class="number">1</span></span><br><span class="line">    conv = self.convs[i](batch_embed)</span><br><span class="line">    hidden = F.relu(conv)  <span class="comment"># sen_num x out_channel x filter_height x 1</span></span><br><span class="line"></span><br><span class="line">    mp = nn.MaxPool2d((filter_height, <span class="number">1</span>))  <span class="comment"># (filter_height, filter_width)</span></span><br><span class="line">    <span class="comment"># sen_num x out_channel x 1 x 1 -&gt; sen_num x out_channel</span></span><br><span class="line">    pooled = mp(hidden).reshape(sen_num, self.out_channel)</span><br><span class="line">    </span><br><span class="line">    pooled_outputs.append(pooled)</span><br></pre></td></tr></table></figure>
<p><strong>TextRNN</strong></p>
<ul>
<li>模型搭建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_size = config.word_dims</span><br><span class="line"></span><br><span class="line">self.word_lstm = LSTM(</span><br><span class="line">    input_size=input_size,</span><br><span class="line">    hidden_size=config.word_hidden_size,</span><br><span class="line">    num_layers=config.word_num_layers,</span><br><span class="line">    batch_first=<span class="literal">True</span>,</span><br><span class="line">    bidirectional=<span class="literal">True</span>,</span><br><span class="line">    dropout_in=config.dropout_input,</span><br><span class="line">    dropout_out=config.dropout_hidden,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hiddens, _ = self.word_lstm(batch_embed, batch_masks)  <span class="comment"># sent_len x sen_num x hidden*2</span></span><br><span class="line">hiddens.transpose_(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># sen_num x sent_len x hidden*2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.training:</span><br><span class="line">    hiddens = drop_sequence_sharedmask(hiddens, self.dropout_mlp)</span><br></pre></td></tr></table></figure>
<h3 id="基于深度学习的文本分类3"><a href="#基于深度学习的文本分类3" class="headerlink" title="基于深度学习的文本分类3"></a>基于深度学习的文本分类3</h3><h4 id="Transformer原理"><a href="#Transformer原理" class="headerlink" title="Transformer原理"></a>Transformer原理</h4><p>Transformer是在”<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is All You Need</a>“中提出的，模型的编码部分是一组编码器的堆叠（论文中依次堆叠六个编码器），模型的解码部分是由相同数量的解码器的堆叠。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211046668.png" alt=""></p>
<p>我们重点关注编码部分。他们结构完全相同，但是并不共享参数，每一个编码器都可以拆解成两部分。在对输入序列做词的向量化之后，它们首先流过一个self-attention层，该层帮助编码器在它编码单词的时候能够看到输入序列中的其他单词。self-attention的输出流向一个前向网络（Feed Forward Neural Network），每个输入位置对应的前向网络是独立互不干扰的。最后将输出传入下一个编码器。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211115945.png" alt=""></p>
<p>这里能看到Transformer的一个关键特性，每个位置的词仅仅流过它自己的编码器路径。在self-attention层中，这些路径两两之间是相互依赖的。<strong>前向网络层则没有这些依赖性</strong>，但这些路径在流经前向网络时可以并行执行。</p>
<p>Self-Attention中使用多头机制，使得不同的attention heads所关注的的部分不同。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211153687.png" alt=""></p>
<p>编码”it”时，一个attention head集中于”the animal”，另一个head集中于“tired”，某种意义上讲，模型对“it”的表达合成了的“animal”和“tired”两者。</p>
<p>对于自注意力的详细计算，欢迎大家参考<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">Jay Alammar</a>关于Transformer的博客，这里不再展开。</p>
<p>除此之外，为了使模型保持单词的语序，模型中添加了位置编码向量。如下图所示，每行对应一个向量的位置编码。因此，第一行将是我们要添加到输入序列中第一个单词的嵌入的向量。每行包含512个值—每个值都在1到-1之间。因为左侧是用sine函数生成，右侧是用cosine生成，所以可以观察到中间显著的分隔。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211232716.png" alt=""></p>
<p>编码器结构中值得提出注意的一个细节是，在每个子层中（Self-attention, FFNN），都有残差连接，并且紧跟着<a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">layer-normalization</a>。如果我们可视化向量和LayerNorm操作，将如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211955713.png" alt=""></p>
<h4 id="基于预训练语言模型的词表示"><a href="#基于预训练语言模型的词表示" class="headerlink" title="基于预训练语言模型的词表示"></a>基于预训练语言模型的词表示</h4><p>基于预训练语言模型的词表示由于可以建模上下文信息，进而解决传统静态词向量不能建模“一词多义”语言现象的问题。最早提出的ELMo基于两个单向LSTM，将从左到右和从右到左两个方向的隐藏层向量表示拼接学习上下文词嵌入。而GPT用Transformer代替LSTM作为编码器，首先进行了语言模型预训练，然后在下游任务微调模型参数。但GPT由于仅使用了单向语言模型，因此难以建模上下文信息。为了解决以上问题，研究者们提出了BERT，BERT模型结构如下图所示，它是一个基于Transformer的多层Encoder，通过执行一系列预训练，进而得到深层的上下文表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211316167.png" alt="bert_elmo"></p>
<p>ELMo论文题目中Deep是指双向双层LSTM，而更关键的在于context。传统方法生成的单词映射表的形式，即先为每个单词生成一个静态的词向量，之后这个单词的表示就被固定住了，不会跟着上下文的变化而做出改变。事实上，由于一词多义的语言现象，静态词向量是有很大的弊端的。以bank为例，如果训练语料的足够大，事先学好的词向量中混杂着所有的语义。而当下游应用时，即使在新句子中，bank的上下文里包含money等词，我们基本可以确定bank是“银行”的语义而不是在其他上下文中的“河床”的语义，但是由于静态词向量不能跟随上下文而进行变化，所以bank的表示中还是混杂着多种语义。为了解决这一问题，ELMo首先进行了语言模型预训练，然后在下游任务中动态调整Word Embedding，因此最后输出的词表示能够充分表达单词在上下文中的特定语义，进而解决一词多义的问题。</p>
<p>GPT来自于openai，是一种生成式预训练模型。GPT 除了将ELMo中的LSTM替换为Transformer 的Encoder外，更开创了NLP界基于预训练-微调的新范式。尽管GPT采用的也是和ELMo相同的两阶段模式，但GPT在第一个阶段并没有采取ELMo中使用两个单向双层LSTM拼接的结构，而是采用基于自回归式的单向语言模型。</p>
<p>Google在NAACL 2018发表的论文中提出了BERT，与GPT相同，BERT也采用了预训练-微调这一两阶段模式。但在模型结构方面，BERT采用了ELMO的范式，即使用双向语言模型代替GPT中的单向语言模型，但是BERT的作者认为ELMo使用两个单向语言模型拼接的方式太粗暴，因此在第一阶段的预训练过程中，BERT提出掩码语言模型，即类似完形填空的方式，通过上下文来预测单词本身，而不是从右到左或从左到右建模，这允许模型能够自由地编码每个层中来自两个方向的信息。而为了学习句子的词序关系，BERT将Transformer中的三角函数位置表示替换为可学习的参数，其次为了区别单句和双句输入，BERT还引入了句子类型表征。BERT的输入如图所示。此外，为了充分学习句子间的关系，BERT提出了下一个句子预测任务。具体来说，在训练时，句子对中的第二个句子有50％来自与原有的连续句子，而其余50%的句子则是通过在其他句子中随机采样。同时，消融实验也证明，这一预训练任务对句间关系判断任务具有很大的贡献。除了模型结构不同之外，BERT在预训练时使用的无标签数据规模要比GPT大的多。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211348456.png" alt="bert_input"></p>
<p>在第二阶段，与GPT相同，BERT也使用Fine-Tuning模式来微调下游任务。如下图所示，BERT与GPT不同，它极大的减少了改造下游任务的要求，只需在BERT模型的基础上，通过额外添加Linear分类器，就可以完成下游任务。具体来说，对于句间关系判断任务，与GPT类似，只需在句子之间加个分隔符，然后在两端分别加上起始和终止符号。在进行输出时，只需把句子的起始符号[CLS]在BERT最后一层中对应的位置接一个Softmax+Linear分类层即可；对于单句分类问题，也与GPT类似，只需要在句子两段分别增加起始和终止符号，输出部分和句间关系判断任务保持一致即可；对于问答任务，由于需要输出答案在给定段落的起始和终止位置，因此需要先将问题和段落按照句间关系判断任务构造输入，输出只需要在BERT最后一层中第二个句子，即段落的每个单词对应的位置上分别接判断起始和终止位置的分类器；最后，对于NLP中的序列标注问题，输入与单句分类任务一致，不同的是在BERT最后一层中每个单词对应的位置上接分类器即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714211409582.png" alt="bert_task"></p>
<p>更重要的是，BERT开启了NLP领域“预训练-微调”这种两阶段的全新范式。在第一阶段首先在海量无标注文本上预训练一个双向语言模型，这里特别值得注意的是，将Transformer作为特征提取器在解决并行性和长距离依赖问题上都要领先于传统的RNN或者CNN，通过预训练的方式，可以将训练数据中的词法、句法、语法知识以网络参数的形式提炼到模型当中，在第二阶段使用下游任务的数据Fine-tuning不同层数的BERT模型参数，或者把BERT当作特征提取器生成BERT Embedding，作为新特征引入下游任务。这种两阶段的全新范式尽管是来自于计算机视觉领域，但是在自然语言处理领域一直没有得到很好的运用，而BERT作为近些年NLP突破性进展的集大成者，最大的亮点可以说不仅在于模型性能好，并且几乎所有NLP任务都可以很方便地基于BERT进行改造，进而将预训练学到的语言学知识引入下游任务，进一步提升模型的性能。</p>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/I-yeHQopTFdNk67Ir_iWiA</a></li>
<li><a href="https://github.com/hecongqing/2018-daguan-competition" target="_blank" rel="noopener">https://github.com/hecongqing/2018-daguan-competition</a></li>
</ol>
]]></content>
      <categories>
        <category>nlp</category>
      </categories>
      <tags>
        <tag>nlp，入门，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）数据加载及探索性数据分析</title>
    <url>/2020/08/16/%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%8E%A2%E7%B4%A2%E6%80%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h4 id="导入numpy和pandas"><a href="#导入numpy和pandas" class="headerlink" title="导入numpy和pandas"></a>导入numpy和pandas</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没安装这两个库可以通过</span></span><br><span class="line"><span class="comment"># conda install numpy 或者 pip install numpy</span></span><br><span class="line"><span class="comment"># conda install pandas 或者 pip install pandas</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h4><p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816110515081.png" alt="image-20200816110515081" style="zoom: 67%;" /></p>
<p>虽然有上面那么多种用法，不过用的最多的还是<code>read_csv</code>和<code>read_table</code>这两个。</p>
<p>这次学习使用的是泰坦尼克号的数据，kaggle链接——<a href="https://www.kaggle.com/c/titanic/overview" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/overview</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写入代码</span></span><br><span class="line">df_relative = pd.read_csv(<span class="string">'train.csv'</span>)</span><br><span class="line">df_relative.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816111116875.png" alt="image-20200816111116875"></p>
<p>这些特征的含义出题者也是给出了解释。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816113903794.png" alt="image-20200816113903794" style="zoom:67%;" /></p>
<p>当相对路径报错的时候，可以尝试使用绝对路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os.getcwd()查看当前目录</span></span><br><span class="line">os.getcwd() + <span class="string">'train.csv'</span> <span class="comment"># 绝对路径</span></span><br></pre></td></tr></table></figure>
<h4 id="逐块读取"><a href="#逐块读取" class="headerlink" title="逐块读取"></a>逐块读取</h4><p>当一个csv文件比较大的时候，如果直接读取整个csv，服务器的内存是吃不消的，因此需要用chunksize去分块处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  df=pd.read_csv(<span class="string">'data.csv'</span>, chunksize=<span class="number">1000</span>) <span class="comment"># chunksize自己设置</span></span><br><span class="line">  <span class="keyword">for</span> chunk <span class="keyword">in</span> df:</span><br><span class="line">print(chunk)</span><br></pre></td></tr></table></figure>
<h4 id="将表头英文换成中文，并且将乘客ID设置成索引"><a href="#将表头英文换成中文，并且将乘客ID设置成索引" class="headerlink" title="将表头英文换成中文，并且将乘客ID设置成索引"></a>将表头英文换成中文，并且将乘客ID设置成索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1 在读取文件的时候就设置</span></span><br><span class="line">df = pd.read_csv(<span class="string">'train.csv'</span>, names=[<span class="string">'乘客ID'</span>,<span class="string">'是否幸存'</span>,<span class="string">'仓位等级'</span>,<span class="string">'姓名'</span>,<span class="string">'性别'</span>,<span class="string">'年龄'</span>,<span class="string">'兄弟姐妹个数'</span>,<span class="string">'父母子女个数'</span>,<span class="string">'船票信息'</span>,<span class="string">'票价'</span>,<span class="string">'客舱'</span>,<span class="string">'登船港口'</span>],index_col=<span class="string">'乘客ID'</span>,header=<span class="number">0</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法2 读取文件还是一样读取，在后面设置</span></span><br><span class="line">d = &#123;<span class="string">'PassengerId'</span>:<span class="string">'乘客ID'</span>, <span class="string">'Survived'</span>:<span class="string">'是否幸存'</span>, <span class="string">'Pclass'</span>:<span class="string">'仓位等级'</span>, <span class="string">'Name'</span>:<span class="string">'姓名'</span>, <span class="string">'Sex'</span>:<span class="string">'性别'</span>, 	 <span class="string">'Age'</span>:<span class="string">'年龄'</span>,<span class="string">'SibSp'</span>:<span class="string">'兄弟姐妹个数'</span>, <span class="string">'Parch'</span>:<span class="string">'父母子女个数'</span>, <span class="string">'Ticket'</span>:<span class="string">'船票信息'</span>, <span class="string">'Fare'</span>:<span class="string">'票价'</span>,     	   <span class="string">'Cabin'</span>:<span class="string">'客舱'</span>, <span class="string">'Embarked'</span>:<span class="string">'登船港口'</span>&#125;</span><br><span class="line">df_table.rename(columns=d, inplace=<span class="literal">True</span>) <span class="comment"># 更换名字</span></span><br><span class="line">df_table.set_index(<span class="string">'乘客ID'</span>, inplace=<span class="literal">True</span>) <span class="comment"># 设置索引</span></span><br><span class="line">df_table.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816114650488.png" alt="image-20200816114650488"></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info() </span><br><span class="line">df.head() <span class="comment"># 前五行</span></span><br><span class="line">df.tail() <span class="comment"># 后五行</span></span><br><span class="line">df.isnull() <span class="comment"># 判断数据是否为空，空的地方是True</span></span><br><span class="line">df.to_csv(<span class="string">'train_chinese.csv'</span>) <span class="comment"># 将DataFrame导出为csv文件</span></span><br></pre></td></tr></table></figure>
<h4 id="删除多余的列"><a href="#删除多余的列" class="headerlink" title="删除多余的列"></a>删除多余的列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> df[a] <span class="comment"># a是列的名称</span></span><br><span class="line">df(<span class="string">'a'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>) <span class="comment"># 跟上面的效果一样</span></span><br></pre></td></tr></table></figure>
<h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>例子： 以”Age”为条件，将年龄在10岁以上和50岁以下的乘客信息显示出来，并将这个数据命名为midage</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">midage = df[(df[<span class="string">"Age"</span>]&gt;<span class="number">10</span>)&amp; (df[<span class="string">"Age"</span>]&lt;<span class="number">50</span>)]</span><br><span class="line">midage.head(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115236212.png" alt="image-20200816115236212"></p>
<p>例子：将midage的数据中第100行的”Pclass”和”Sex”的数据显示出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">midage.loc[[<span class="number">100</span>],[<span class="string">'Pclass'</span>,<span class="string">'Sex'</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115417706.png" alt="image-20200816115417706" style="zoom:67%;" /></p>
<p>例子：使用loc方法将midage的数据中第100，105，108行的”Pclass”，”Name”和”Sex”的数据显示出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">midage.loc[[<span class="number">100</span>,<span class="number">105</span>,<span class="number">108</span>],[<span class="string">'Pclass'</span>,<span class="string">'Name'</span>,<span class="string">'Sex'</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115509038.png" alt="image-20200816115509038" style="zoom:67%;" /></p>
<p>例子：使用iloc方法将midage的数据中第100，105，108行的”Pclass”，”Name”和”Sex”的数据显示出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">midage.iloc[[<span class="number">100</span>,<span class="number">105</span>,<span class="number">108</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>​    <img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115541392.png" alt="image-20200816115541392" style="zoom:67%;" /></p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>原始数据为：<img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115749253.png" alt="image-20200816115749253" style="zoom:67%;" /></p>
<p>例子1：让行索引升序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_table.sort_index(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115846642.png" alt="image-20200816115846642" style="zoom:67%;" /></p>
<p>例子2：让列索引升序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_table.sort_index(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816115930866.png" alt="image-20200816115930866" style="zoom:67%;" /></p>
<p>例子3：任选两列数据同时降序排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_table.sort_values([<span class="string">'d'</span>, <span class="string">'b'</span>], ascending=[<span class="literal">False</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200816120006619.png" alt="image-20200816120006619" style="zoom:67%;" /></p>
<p>小总结：如果是要按<strong>行索引</strong>或者<strong>列索引</strong>则使用<code>sort_index()</code>，如果要按值排序则使用<code>sort_value()</code></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）数据处理及特征清理</title>
    <url>/2020/08/18/%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E7%89%B9%E5%BE%81%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="2-1-缺失值观察与处理"><a href="#2-1-缺失值观察与处理" class="headerlink" title="2.1 缺失值观察与处理"></a>2.1 缺失值观察与处理</h3><p>我们拿到的数据经常会有很多缺失值，比如我们可以看到Cabin列存在NaN，那其他列还有没有缺失值，这些缺失值要怎么处理呢。</p>
<h4 id="2-1-1-缺失值观察"><a href="#2-1-1-缺失值观察" class="headerlink" title="2.1.1 缺失值观察"></a>2.1.1 缺失值观察</h4><p>还是以泰坦尼克号的数据为例。查看各个特征缺失值个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入库和数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">'train.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>方法1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818144229244.png" alt="image-20200818144229244" style="zoom:67%;" /></p>
<p>不过这样显示的是非缺失值的数据，不够直观。</p>
<p>方法2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isnull().sum()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818144324925.png" alt="image-20200818144324925" style="zoom:67%;" /></p>
<h4 id="2-1-2-对缺失值进行处理"><a href="#2-1-2-对缺失值进行处理" class="headerlink" title="2.1.2 对缺失值进行处理"></a>2.1.2 对缺失值进行处理</h4><p>1）填充</p>
<p>方法1：不使用函数（假设对Age这列进行<code>0</code>填充）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">'Age'</span>]==<span class="literal">None</span>] = <span class="number">0</span></span><br><span class="line">df[df[<span class="string">'Age'</span>].isnull()] = <span class="number">0</span></span><br><span class="line">df[df[<span class="string">'Age'</span>] == np.nan] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当然了，上面我使用的是用0填充，你可以用别的你想用的值进行填充。</p>
<p>方法2：使用<code>fillna()</code></p>
<p><code>DataFrame.``fillna</code><strong>(*</strong>value=None<strong>*,</strong> <em>method=None**</em>,<strong> <em>axis=None</em></strong>,<strong> <em>inplace=False</em></strong>,<strong> <em>limit=None</em></strong>,<strong> <em>downcast=None</em></strong>)**</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200818144839564.png" alt="image-20200818144839564" style="zoom:50%;" /></p>
<p>这是文档当中的定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'Age'</span>].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-重复值观察与处理"><a href="#2-2-重复值观察与处理" class="headerlink" title="2.2  重复值观察与处理"></a>2.2  重复值观察与处理</h3><p>1）查看重复值：使用的是<code>duplicated()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.duplicated()]</span><br></pre></td></tr></table></figure>
<p>2）删掉重复值：使用的是<code>drop_duplicates()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates()</span><br></pre></td></tr></table></figure>
<h3 id="2-3-特征观察与处理"><a href="#2-3-特征观察与处理" class="headerlink" title="2.3 特征观察与处理"></a>2.3 特征观察与处理</h3><p>数值型特征一般可以直接用于模型的训练，但有时候为了模型的稳定性及鲁棒性会对连续变量进行离散化。文本型特征往往需要转换成数值型特征才能用于建模分析。</p>
<p>1）分箱：一种无监督离散化方法，分为两类，1 等距离分箱 2 等频度分箱。等距离分箱即等宽度分箱，设有K个空间，则每个空间的间距 I=（Max-Min）/K。等频率分箱，即等深度分箱</p>
<p><code>pandas.``cut</code><strong>(*</strong>x<strong>*,</strong> <em>bins**</em>,<strong> <em>right=True</em></strong>,<strong> <em>labels=None</em></strong>,<strong> <em>retbins=False</em></strong>,<strong> <em>precision=3</em></strong>,<strong> <em>include_lowest=False</em></strong>,<strong> <em>duplicates=’raise’</em></strong>,<strong> <em>ordered=True</em></strong>)**</p>
<p><code>pandas.``qcut</code><strong>(*</strong>x<strong>*,</strong> <em>q**</em>,<strong> <em>labels=None</em></strong>,<strong> <em>retbins=False</em></strong>,<strong> <em>precision=3</em></strong>,<strong> <em>duplicates=’raise’</em></strong>)**</p>
<p>分箱一般会使用上面这两个函数。</p>
<p>【例子】1：将连续变量Age平均分箱成5个年龄段，并分别用类别变量12345表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.cut(df[<span class="string">'Age'</span>], <span class="number">5</span>, labels=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>【例子】2：将连续变量Age划分为[0,5) [5,15) [15,30) [30,50) [50,80)五个年龄段，并分别用类别变量12345表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.cut(df[<span class="string">'Age'</span>], [<span class="number">0</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">80</span>], right=<span class="literal">False</span>, labels=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>【例子】3：将连续变量Age按10% 30% 50 70% 90%五个年龄段，并用分类变量12345表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.qcut(df[<span class="string">'Age'</span>], [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.9</span>, <span class="number">1.</span>], labels=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>2）对文本变量进行转换</p>
<p>方法1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'Sex_num'</span>] = df[<span class="string">'Sex'</span>].replace([<span class="string">'male'</span>,<span class="string">'female'</span>],[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 适用于种类较少的</span></span><br></pre></td></tr></table></figure>
<p>方法2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'Sex_num'</span>] = df[<span class="string">'Sex'</span>].map(&#123;<span class="string">'male'</span>:<span class="number">1</span>, <span class="string">'female'</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 跟方法1一样，适用于种类较少的。</span></span><br></pre></td></tr></table></figure>
<p>方法3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">for</span> feat <span class="keyword">in</span> [<span class="string">'Cabin'</span>, <span class="string">'Ticket'</span>]:</span><br><span class="line">    lbl = LabelEncoder()  </span><br><span class="line">    label_dict = dict(zip(df[feat].unique(), range(df[feat].nunique())))</span><br><span class="line">    df[feat + <span class="string">"_labelEncode"</span>] = df[feat].map(label_dict)</span><br><span class="line">    df[feat + <span class="string">"_labelEncode"</span>] = lbl.fit_transform(df[feat].astype(str))</span><br><span class="line"><span class="comment"># 这种就无所谓种类的的多少了，均适用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python，datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>分治</title>
    <url>/2020/08/19/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="分治算法的原理"><a href="#分治算法的原理" class="headerlink" title="分治算法的原理"></a>分治算法的原理</h3><p>分治算法的原理可以用二叉树表示。假设给定的问题不能够被直接了当地解决。这时，我们可以将原问题分成相互独立的两个子问题。如果能将这两个子问题解决，那我们就离原问题的解不远了。如果子问题还是复杂问题的话，我们就继续分解，直到子问题满足边界条件，小到可以直接得出答案为止。得到最小子问题的解后，我们往上递回，将子问题的解层层合并，最终获得原问题的解。</p>
<p>我们不一定每一次都将原问题分成两个子问题。根据问题的需要，我们可以将原问题分成 k 个子问题， k&gt;1。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200819133056422.png" alt="image-20200819133056422" style="zoom: 50%;" /></p>
<h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><ul>
<li>原问题的<strong>计算复杂度</strong>随着问题的规模的增加而增加。</li>
<li>原问题<strong>能够被分解</strong>成更小的子问题。</li>
<li>子问题的<strong>结构和性质</strong>与原问题一样，并且<strong>相互独立</strong>，子问题之间<strong>不包含</strong>公共的子子问题。</li>
<li>原问题分解出的子问题的解<strong>可以合并</strong>为该问题的解。</li>
</ul>
<p>我们通过一个例子更好地理解分治算法的原理。 我们即将升序排序以下数组：[10,6,2,9,5,1,12,4,0,4,1,2,1,3,2,9]。</p>
<p><img src="https://images.gitbook.cn/3eed66e0-b8e8-11e9-b842-d54514bdf4a6" alt="enter image description here" style="zoom:50%;" /></p>
<p>我们将原问题分成了两个子问题，分别是排序 [10,6,2,9,5,1,12,4] 和排序 [0,4,1,2,1,3,2,9]。也就是说，我们将数组一分为二，分成了两个长度减半的数组。这样做的理由是，如果我们将两个子数组排序完毕，就可以通过双指针的方法不费事地将原数组排序。</p>
<p>双指针的方法如下：将两个指针分别放在两个子数组的第一个元素上，比较两个数字的大小，将较小的加入一个新的空数组，并将对应的指针挪到下一个位置，接着对比两个数字，一直将较小的数字加入新数组的队尾，直到某个指针到达队尾。如果还有剩余的数字，便将这些数字按顺序加入新数组的队尾。这样得到的新数组就是排序完毕的原数组。</p>
<p>问题是，如何将子数组排序？很好解决，利用同样的逻辑，我们可以将两个子数组也一分为二。只要将这四个子数组排序完毕，利用双指针的方法就能得到想要的答案。重复这个逻辑，我们同样也可以将那四个子数组递归排序。</p>
<p>我们不能永远地将问题传递下去，所以一旦子数组长度为一，我们就停止递归，将数组直接输出。在那之后，我们会通过双指针的方法得到排序完毕的，长度为二的子数组。得到长度为二的子数组后，我们会通过双指针的方法得到排序完毕的，长度为四的子数组，以此类推，直到得到原问题的解。</p>
<p>参考博客：</p>
<p><a href="https://gitchat.csdn.net/activity/5d39b22ba2a28a54fc0090f7?utm_source=so#1?utm_source=so&amp;utm_source=so" target="_blank" rel="noopener">https://gitchat.csdn.net/activity/5d39b22ba2a28a54fc0090f7?utm_source=so#1?utm_source=so&amp;utm_source=so</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>datawhale，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>泰坦尼克号生存预测</title>
    <url>/2020/08/20/%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p>这是kaggle上面比较入门的一个比赛。今天让我们来看看怎么做吧。<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">kaggle传送门</a>。首先报名，下载数据集。</p>
<h3 id="数据载入及概述"><a href="#数据载入及概述" class="headerlink" title="数据载入及概述"></a>数据载入及概述</h3><p>首先导入从Kaggle上面下载的数据集，在导入的过程中就需要先导入一些必备的包了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着导入我们的训练数据</span></span><br><span class="line">filename = <span class="string">'titanic/train.csv'</span>  <span class="comment"># 这是我存放的文件路径，这边换成你们自己的</span></span><br><span class="line">train = pd.read_csv(filename)</span><br></pre></td></tr></table></figure>
<p>然后来看看训练数据集长啥样。（每个列的名字的含义，在kaggle页面有介绍，这边就不说了。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820170750314.png" alt="image-20200820170750314"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.info()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820170950383.png" alt="image-20200820170950383" style="zoom: 67%;" /></p>
<p>通过<code>info()</code>这个函数我们可要知道，哪些特征的数值类型是什么。比如，上面PassengerId，Survived，Pclass，Age等是数值型数据，而Name，Sex，Ticket等是字符型数据。字符型数据肯定到后面是要转换的，可能转换成<code>one-hot</code>类型的。不过数值型数据也可能是需要转换的。后面会细说。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trian.isnull().sum()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820171408946.png" alt="image-20200820171408946" style="zoom:67%;" /></p>
<p>通过<code>isnull()</code>可以看出哪些列缺失了数据，缺失了多少行。只有对缺失数据的处理有很多种，比如说填充，或者删去。</p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h4 id="年龄与生存"><a href="#年龄与生存" class="headerlink" title="年龄与生存"></a>年龄与生存</h4><p>我们都知道，在危难来临之际，一般都会让孩子和老人先脱离危险，所以我们将年龄分成3个段[0,20],[20,60],[60,80]。画出存活的人数和年龄段的图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">examine = train.copy() <span class="comment"># 这边将训练数据集备份一份</span></span><br><span class="line"><span class="comment">#将连续变量Age划分为[0,5) [5,15) [15,30) [30,50) [50,80)五个年龄段，并分别用类别变量12345表示</span></span><br><span class="line">examine[<span class="string">'AgeBand'</span>] = pd.cut(examine[<span class="string">'Age'</span>],[<span class="number">0</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">80</span>],labels = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>])</span><br><span class="line">sns.barplot(x=<span class="string">'AgeBand'</span>, y=<span class="string">'Survived'</span>, data=examine)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820173257324.png" alt="image-20200820173257324" style="zoom:67%;" /></p>
<p>从上图，可以明显看出小孩的存活率偏高，那为什么老人存活率最低呢，是因为泰坦尼克号与一座冰山相撞，那么有冰山，必然说明那个地方的气候很寒冷，老人的身体不太好，所以存活率这么一解释，是不是也说得通。</p>
<h4 id="性别与生存"><a href="#性别与生存" class="headerlink" title="性别与生存"></a>性别与生存</h4><p>前面说的小孩和老人优先，当然了还有一句是女士优先。所以我们来看看性别与存活的关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">"Sex"</span>, y=<span class="string">"Survived"</span>, data=examine)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820173638288.png" alt="image-20200820173638288" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820180456938.png" alt="image-20200820180456938" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提示：计算男女中死亡人数 1表示生存，0表示死亡</span></span><br><span class="line">examine.groupby([<span class="string">'Sex'</span>,<span class="string">'Survived'</span>])[<span class="string">'Survived'</span>].count().unstack().plot(kind=<span class="string">'bar'</span>,stacked=<span class="string">'True'</span>)</span><br><span class="line">plt.title(<span class="string">'survived_count'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'count'</span>)</span><br></pre></td></tr></table></figure>
<p>从上面两个图，明显可以看出两者存活的几率是相差很大的。女性的存活率是明显高于男性。这也符合实际，在泰坦尼克号这部电影中，也是能够看出来。</p>
<h4 id="社会地位与生存"><a href="#社会地位与生存" class="headerlink" title="社会地位与生存"></a>社会地位与生存</h4><p>可能有人看到社会地位就有点疑惑了，数据集里面哪有这个特征，其实不然。仓位等级和票价多多少少都能说明的。就好比几十年前，家里有车的人都是大户人家，地主官僚跟普通人的地位还是差别很大的。因此萌发一个想法，看这个特征跟存活率的关系如何。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">"Pclass"</span>, y=<span class="string">"Survived"</span>, data=examine)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820180018917.png" alt="image-20200820180018917" style="zoom:67%;" /></p>
<p>从图中看出来，仓位等级跟生存关系还是很大的，这也比较符合现实。懂得都懂。</p>
<h4 id="泰坦尼克号数据集中不同仓位等级的人年龄分布情况"><a href="#泰坦尼克号数据集中不同仓位等级的人年龄分布情况" class="headerlink" title="泰坦尼克号数据集中不同仓位等级的人年龄分布情况"></a>泰坦尼克号数据集中不同仓位等级的人年龄分布情况</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">examine.Age[examine.Pclass == <span class="number">1</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">examine.Age[examine.Pclass == <span class="number">2</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">examine.Age[examine.Pclass == <span class="number">3</span>].plot(kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.xlabel(<span class="string">"age"</span>)</span><br><span class="line">plt.legend((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),loc=<span class="string">"best"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820180703425.png" alt="image-20200820180703425" style="zoom:67%;" /></p>
<p>不过这个图好像跟生存关系不大。</p>
<h3 id="数据清洗及特征处理"><a href="#数据清洗及特征处理" class="headerlink" title="数据清洗及特征处理"></a>数据清洗及特征处理</h3><h4 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h4><p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820171408946.png" alt="image-20200820171408946" style="zoom:67%;" /></p>
<p>前面分析过，<code>&#39;Cabin&#39;</code>这列缺失了687个数据，总共才891个数据。而且这列确实跟生存与否没什么关系，因此就直接删除掉这列。还有<code>&#39;Name&#39;</code>，<code>&#39;Ticket &#39;</code>跟生存也没什么关系，一并删除了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.drop([<span class="string">'Cabin'</span>, <span class="string">'Name'</span>, <span class="string">'Ticket'</span>], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820181911481.png" alt="image-20200820181911481" style="zoom: 80%;" /></p>
<p>然后来看<code>&#39;Age&#39;</code>这列的缺失值，这列缺失了100多条数据，因此我们采用填充的方式，不过填充的方式有很多，这边使用均值填充。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">"Age"</span>] = train[<span class="string">"Age"</span>].fillna(train[<span class="string">"Age"</span>].mean())</span><br><span class="line">trian.isnull().sum()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820182510244.png" alt="image-20200820182510244" style="zoom:67%;" /></p>
<p>现在看到只有<code>&#39;Embarked&#39;</code>这列还剩下2个缺失值，2个缺失值好办，我们直接删掉就好了，对结果没什么影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train = train.dropna()</span><br></pre></td></tr></table></figure>
<p>删掉这两条数据之后，总得数据就变成了889条了。缺失值的处理就到这里差不多结束了。</p>
<h4 id="分类变量的处理"><a href="#分类变量的处理" class="headerlink" title="分类变量的处理"></a>分类变量的处理</h4><p>首先将二分类变量<code>&#39;Sex&#39;</code>转换成0和1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">'Sex'</span>] = (train[<span class="string">'Sex'</span>] == <span class="string">'male'</span>).astype(np.int64)</span><br></pre></td></tr></table></figure>
<p>然后将三分类变量<code>&#39;Embarked&#39;</code>转换成0、1、2。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels = train[<span class="string">'Embarked'</span>].unique().tolist()</span><br><span class="line">train[<span class="string">'Embarked'</span>] = train[<span class="string">'Embarked'</span>].apply(<span class="keyword">lambda</span> x : labels.index(x))</span><br></pre></td></tr></table></figure>
<p>当然，将分类变量转换成数值型的方式又很多，我只是写了其中的一种。</p>
<h4 id="将数据中的训练变量和标签分开"><a href="#将数据中的训练变量和标签分开" class="headerlink" title="将数据中的训练变量和标签分开"></a>将数据中的训练变量和标签分开</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = train.iloc[:, train.columns != <span class="string">'Survived'</span>]</span><br><span class="line">y = train.iloc[:, train.columns == <span class="string">'Survived'</span>]</span><br><span class="line">X.shape, y.shape</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># (889, 8), (889, 1)</span></span><br></pre></td></tr></table></figure>
<p>接下来，要将训练集拆分为训练集和验证集。并且训练集和验证集的比列为3：1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, Ytrain, Ytest = train_test_split(X,y,test_size=<span class="number">0.25</span>)</span><br><span class="line">Xtrain.shape, Xtest.shape</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># (666, 8), (223, 8)</span></span><br></pre></td></tr></table></figure>
<p>还有最后一步，我们要重新设置下索引。至于为什么需要，看下面这张图就可以了。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820210343454.png" alt="image-20200820210343454" style="zoom: 67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [Xtrain, Xtest, Ytrain, Ytest]:</span><br><span class="line">    i.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>到这里，数据的清洗，特征处理的工作基本完成了。接下来就是建模了。</p>
<h3 id="数据建模及模型评估"><a href="#数据建模及模型评估" class="headerlink" title="数据建模及模型评估"></a>数据建模及模型评估</h3><p>先导入一些后面会用到的库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(Xtrain, Ytrain)</span><br><span class="line"><span class="comment"># 查看验证集score值</span></span><br><span class="line">print(<span class="string">"Testing set score: &#123;:.2f&#125;"</span>.format(clf.score(Xtest, Ytest)))</span><br><span class="line"><span class="comment"># Testing set score: 0.74</span></span><br></pre></td></tr></table></figure>
<p>使用10折交叉验证来评估，并且取平均。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = cross_val_score(clf,X,y,cv=<span class="number">10</span>).mean()</span><br><span class="line"><span class="comment"># 0.757</span></span><br></pre></td></tr></table></figure>
<p>接下来优化下这个模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tr = []</span><br><span class="line">te = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    clf = DecisionTreeClassifier(random_state=<span class="number">0</span>,max_depth=i,criterion=<span class="string">"entropy"</span>)</span><br><span class="line">    clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">    score_tr = clf.score(Xtrain,Ytrain)</span><br><span class="line">    score_te = cross_val_score(clf,X,y,cv=<span class="number">10</span>).mean()</span><br><span class="line">    tr.append(score_tr)</span><br><span class="line">    te.append(score_te)</span><br><span class="line">print(max(te))</span><br><span class="line">plt.plot(range(<span class="number">1</span>,<span class="number">11</span>),tr,color=<span class="string">"red"</span>,label=<span class="string">"train"</span>)</span><br><span class="line">plt.plot(range(<span class="number">1</span>,<span class="number">11</span>),te,color=<span class="string">"blue"</span>,label=<span class="string">"test"</span>)</span><br><span class="line">plt.xticks(range(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820211514091.png" alt="image-20200820211514091" style="zoom:67%;" /></p>
<p>可以看出，最大深度为3的时候，得分最高为<code>0.8166624106230849</code>。</p>
<h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认参数逻辑回归模型</span></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(Xtrain, Ytrain)</span><br><span class="line">print(<span class="string">"Testing set score: &#123;:.2f&#125;"</span>.format(lr.score(Xtest, Ytest)))</span><br><span class="line"><span class="comment"># Testing set score: 0.80</span></span><br></pre></td></tr></table></figure>
<p>使用10折交叉验证来评估，并且取平均。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = cross_val_score(lr,X,y,cv=<span class="number">10</span>).mean()</span><br><span class="line"><span class="comment"># 0.795</span></span><br></pre></td></tr></table></figure>
<h4 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    rfc = RandomForestClassifier(n_estimators=<span class="number">100</span>, max_depth=i, random_state=<span class="number">20</span>)</span><br><span class="line">    score = cross_val_score(rfc, X, y, cv=<span class="number">10</span>)</span><br><span class="line">    test.append(score.mean())</span><br><span class="line">plt.plot(range(<span class="number">1</span>, <span class="number">11</span>), test)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820214323400.png" alt="image-20200820214323400" style="zoom:67%;" /></p>
<p>可以，发现当最大深度为6的时候，模型的得分最高。接近0.83，我们可以使用网格搜索来获取最优的参数，但是网格搜索比较耗时，这边就不写出来了。</p>
<h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line">test = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">50</span>, <span class="number">5</span>):</span><br><span class="line">    clf = BaggingClassifier(n_estimators=i)</span><br><span class="line">    score = cross_val_score(clf, X, y, cv=<span class="number">10</span>)</span><br><span class="line">    test.append(score.mean())</span><br><span class="line">    </span><br><span class="line">plt.plot(range(<span class="number">10</span>, <span class="number">50</span>, <span class="number">5</span>), test)</span><br><span class="line">plt.ylabel(<span class="string">'score'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'n_estimators'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820215404157.png" alt="image-20200820215404157" style="zoom:67%;" /></p>
<p>从上图看出，最高应该在0.82左右。</p>
<h4 id="LGBClassifier"><a href="#LGBClassifier" class="headerlink" title="LGBClassifier"></a>LGBClassifier</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line">test = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>):</span><br><span class="line">    lgb = LGBMClassifier(max_depth=<span class="number">2</span>, n_estimators=i)</span><br><span class="line">    score = cross_val_score(lgb, X, y, cv=<span class="number">10</span>)</span><br><span class="line">    test.append(score.mean())</span><br><span class="line">    </span><br><span class="line">plt.plot(range(<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>), test)</span><br><span class="line">plt.ylabel(<span class="string">'score'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'n_estimators'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200820220218847.png" alt="image-20200820220218847" style="zoom:67%;" /></p>
<p>从图中可以看出，最高得分接近0.84。</p>
<h4 id="集成几个模型"><a href="#集成几个模型" class="headerlink" title="集成几个模型"></a>集成几个模型</h4><p>最后将几个模型集成一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = [<span class="literal">None</span>]*<span class="number">5</span></span><br><span class="line">clf[<span class="number">0</span>] = DecisionTreeClassifier(random_state=<span class="number">0</span>,max_depth=<span class="number">3</span>,criterion=<span class="string">"entropy"</span>)</span><br><span class="line">clf[<span class="number">1</span>] = LogisticRegression()</span><br><span class="line">clf[<span class="number">2</span>] = RandomForestClassifier(n_estimators=<span class="number">100</span>, max_depth=<span class="number">6</span>, random_state=<span class="number">20</span>)</span><br><span class="line">clf[<span class="number">3</span>] = BaggingClassifier(n_estimators=<span class="number">20</span>)</span><br><span class="line">clf[<span class="number">4</span>] = LGBMClassifier(max_depth=<span class="number">2</span>, n_estimators=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">predictFrame = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> clf:</span><br><span class="line">    model.fit(Xtrain, Ytrain)</span><br><span class="line">    predictFrame[str(model)[:<span class="number">14</span>]] = model.predict(Xtest)</span><br><span class="line"></span><br><span class="line">te = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    clf_ = RandomForestClassifier(n_estimators=<span class="number">100</span>, max_depth=i, random_state=<span class="number">0</span>)</span><br><span class="line">    score = cross_val_score(clf_, predictFrame, Ytest, cv=<span class="number">10</span>, scoring=<span class="string">'precision'</span>)</span><br><span class="line">    te.append(score.mean())</span><br><span class="line">    </span><br><span class="line">plt.plot(range(<span class="number">1</span>,<span class="number">10</span>), te)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/image-20200821002438273.png" alt="image-20200821002438273" style="zoom:67%;" /></p>
<p>从上图看出，集成后的得分超过了0.91比单个模型的正确率提升了很多。但还是挺菜的。</p>
<p>最后简单总结下，自己能力有限，一些参数也是简单的定了下来，当然我相信你们分数都会比我高。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>datawhale，数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2020/08/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><pre><code>   **动态规划**算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。在学习动态规划之前需要明确掌握几个重要概念。
</code></pre><p>  <strong>阶段：</strong>对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解。</p>
<p>  <strong>状态：</strong>状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况。</p>
<p>  <strong>决策：</strong>决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策。</p>
<p>  <strong>策略：</strong>由所有阶段的决策组成的决策序列称为全过程策略，简称策略。</p>
<p>  <strong>最优策略：</strong>在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略。</p>
<p>  <strong>状态转移方程：</strong>状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的。</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h3><p>能采用动态规划求解的问题的一般要具有 3 个性质：</p>
<p>  （1）<strong>最优化</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。子问题的局部最优将导致整个问题的全局最优。换句话说，就是问题的一个最优解中一定包含子问题的一个最优解。</p>
<p>  （2）<strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关，与其他阶段的状态无关，特别是与未发生的阶段的状态无关。</p>
<p>   （3）<strong>重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<h3 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3 算法流程"></a>3 算法流程</h3><p>  （1）划分阶段：按照问题的时间或者空间特征将问题划分为若干个阶段。<br>  （2）确定状态以及状态变量：将问题的不同阶段时期的不同状态描述出来。<br>  （3）确定决策并写出状态转移方程：根据相邻两个阶段的各个状态之间的关系确定决策。<br>  （4）寻找边界条件：一般而言，状态转移方程是递推式，必须有一个递推的边界条件。<br>  （5）设计程序，解决问题</p>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485288&amp;idx=1&amp;sn=fd043fc723f38bcaecc90d9945981f8a&amp;chksm=fa0e68e9cd79e1ffd965205bb06b1731539bf2e0bbc5991664f5d1d9721b346ec08c85bb9042&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">浅谈什么是动态规划以及相关的「股票」算法题</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>datawhale</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法——EM算法及其推广</title>
    <url>/2020/09/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%8E%A8%E5%B9%BF/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<h3 id="1、摘要"><a href="#1、摘要" class="headerlink" title="1、摘要"></a>1、摘要</h3><p>EM算法是一种迭代算法，1977年由Dempster等人总结提出，用于含有隐变量（hidden variable）的概率模型参数的极大似然估计，或极大后验概率估计。EM算法的每次迭代由两步组成：E步，求期望（expectation）；M步，求极大（maximization）。所以这一算法称为期望极大算法（expectation maximization algorithm），简称EM算法。</p>
<h3 id="2、预备知识"><a href="#2、预备知识" class="headerlink" title="2、预备知识"></a>2、预备知识</h3><h4 id="2-1、联合概率、边缘概率、条件概率"><a href="#2-1、联合概率、边缘概率、条件概率" class="headerlink" title="2.1、联合概率、边缘概率、条件概率"></a>2.1、联合概率、边缘概率、条件概率</h4><p><strong>1、联合概率</strong></p>
<p>联合概率指的是包含多个条件且<strong>所有条件同时成立</strong>的概率，记作P(X=a,Y=b)或P(a,b)。 <font color=red>一定要注意是所有条件同时成立。</font></p>
<p><strong>2、边缘概率</strong></p>
<p>边缘概率是与联合概率对应的，P(X=a)或P(Y=b)，这类仅与单个随机变量有关的概率称为边缘概率。</p>
<p><strong>1&amp;2、联合概率和边缘概率的关系</strong></p>
<script type="math/tex; mode=display">
P(X=a)=\sum_{b}P(X=a,Y=b) \\

P(Y=b)=\sum_{a}P(Y=b,X=a)</script><p>求和符号表示穷举所有Y（或X）所能取得b（或a）后，所有对应值相加得到的和。</p>
<p>注意：上面X和Y谁写在前面是没有关系的，我只是为了更容易理解，所以改了下位置。</p>
<p><strong>3、条件概率</strong></p>
<p>条件概率表示在条件Y=b成立的情况下，X=a的概率，记作P(X=a|Y=b)或P(a|b)，它具有如下性质：</p>
<p><strong>“在条件Y=b下X的条件分布”也是一种“X的概率分布”，因此穷举X的可取值之后，所有这些值对应的概率之和为1</strong>即：</p>
<script type="math/tex; mode=display">
\sum_{a}P(X=a|Y=b)=1</script><p><strong>1&amp;2&amp;3、联合概率、边缘概率和条件概率之间的关系</strong></p>
<script type="math/tex; mode=display">
P(X=a|Y=b)=\frac{P(X=a,Y=b)}{P(Y=b)}</script><p>当然，如果X和Y相互独立的话公式就变成这样了，$P(X=a)=\frac{P(X=a,Y=b)}{P(Y=b)}$</p>
<h4 id="2-2、极大似然估计"><a href="#2-2、极大似然估计" class="headerlink" title="2.2、极大似然估计"></a>2.2、极大似然估计</h4><p>在说极大似然估计前，先来看看贝叶斯决策。</p>
<p><strong>贝叶斯决策</strong></p>
<p>首先来看贝叶斯分类，我们都知道经典的贝叶斯公式：</p>
<script type="math/tex; mode=display">
P(w|x)=\frac{P(x|w)P(w)}{P(x)}</script><p>其中：$P(w)$为先验概率，表示每种类别分布的概率；$P(x|w)$为类条件概率，表示在某种类别前提下，某事发生的概率。而$P(w|x)$为后验概率，表示某事发生了，并且它属于某一类别的概率，了这个后验概率，我们就可以对样本进行分类。后验概率越大，说明某事物属于这个类别的可能性越大。</p>
<p>我们来看一个直观的例子：<strong>已知：</strong>在夏季，某公园男性穿凉鞋的概率为1/2，女性穿凉鞋的概率为2/3，并且该公园中男女比例通常为2:1，<strong>问题：</strong>若你在公园中随机遇到一个穿凉鞋的人，请问他的性别为男性或女性的概率分别为多少？</p>
<p> 从问题来看，就是上面讲的，某事发生了，它属于某一类别的概率是多少？即后验概率。</p>
<p>设&emsp;$w_1=男性$，$w_2=女性$，$x=穿凉鞋$。</p>
<p>由已知可以得：</p>
<script type="math/tex; mode=display">
先验概率P(w_1)=\frac{2}{3}，P(w_2)=\frac{1}{3} \\
类条件概率P(x|w_1)=\frac{1}{2}，P(x|w_2)=\frac{2}{3}</script><p>男性和女性穿凉鞋独立（至少这题没特别说明，两者不独立），所以在公园里遇到一个人穿凉鞋的概率为：</p>
<script type="math/tex; mode=display">
P(x)=P(w_1)P(x|w_1)+P(w_2)P(x|w_2)=\frac{2}{3}\times\frac{1}{2}+\frac{1}{3}\times\frac{2}{3}=\frac{1}{3}+\frac{2}{9}=\frac{5}{9}</script><p>有贝叶斯公式算出：</p>
<script type="math/tex; mode=display">
P(w_1|x)=\frac{P(x|w_1)P(w_1)}{P(x)}=\frac{\frac{1}{2}\times\frac{2}{3}}{\frac{5}{9}}=\frac{3}{5} \\
P(w_2|x)=\frac{P(x|w_2)P(w_2)}{P(x)}=\frac{\frac{2}{3}\times\frac{1}{3}}{\frac{5}{9}}=\frac{2}{5}</script><p>所以遇到一个穿凉鞋的人，判断这个人是男性的概率为$\frac{3}{5}$，是女性的概率为$\frac{2}{5}$。当然贝叶斯决策并不是我们要说的重点。</p>
<p><strong>问题引出</strong></p>
<p>​    但是在实际问题中并不都是这样幸运的，我们能获得的数据可能只有有限数目的样本数据，而先验概率$P(w_i)$和类条件概率(各类的总体分布)$P(x|w_i)$都是未知的。根据仅有的样本数据进行分类时，一种可行的办法是我们需要先对先验概率和类条件概率进行估计，然后再套用贝叶斯分类器。</p>
<p>​    先验概率的估计较简单，1、每个样本所属的自然状态都是已知的（有监督学习）；2、依靠经验；3、用训练样本中各类出现的频率估计。</p>
<p>​    类条件概率的估计（非常难），原因包括：概率密度函数包含了一个随机变量的全部信息；样本数据可能不多；特征向量x的维度可能很大等等。总之要直接估计类条件概率的密度函数很难。解决的办法就是，把估计完全未知的概率密度$P(x|w_i)$转化为估计参数。这里就将概率密度估计问题转化为参数估计问题，极大似然估计就是一种参数估计方法。当然了，概率密度函数的选取很重要，模型正确，在样本区域无穷时，我们会得到较准确的估计值，如果模型都错了，那估计半天的参数，肯定也没啥意义了。</p>
<p><strong>极大似然估计</strong></p>
<p> 极大似然估计的原理，用一张图片来说明，如下图所示：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904125744.jpg" alt="a_1"></p>
<p>总结起来，最大似然估计的目的就是： <font color=red>利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。</font></p>
<p>原理：极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。</p>
<p>由于样本集中的样本都是独立同分布，可以只考虑一类样本集D，来估计参数向量θ。记已知的样本集为：</p>
<script type="math/tex; mode=display">
D=\lbrace x_1,x_2,x_3,\cdots,x_N \rbrace</script><p>似然函数（likehood function）：联合概率密度$P(D|\theta)$称为相对于$\lbrace x_1,x_2,x_3,\cdots,x_N \rbrace$的$\theta$的似然幻术。</p>
<script type="math/tex; mode=display">
记l(\theta)=P(D|\theta)=p(x_1,x_2,x_3,\cdots,x_N|\theta)=\prod_{i=1}^NP(x_i|\theta)</script><p>如果$\hat{\theta}$是参数空间中能使似然函数$l(\theta)$最大的$\theta$值，则$\hat{\theta}$应该是最有可能的参数值，那么$\hat{\theta}$就是$\theta$的极大似然估计量。它是样本集的函数，记作：</p>
<script type="math/tex; mode=display">
\hat{\theta}=d(x_1,x_2,\cdots,x_N)=d(D) \\
\hat{\theta}(x_1,x_2,\cdots,x_N)称作极大似然函数估计值</script><p>ML估计：求使得出现改组样本的概率最大的$\theta$值</p>
<script type="math/tex; mode=display">
\hat{\theta}=arg~\mathop{max}_{\theta}~l(\theta)=arg~\mathop{max}_\theta\prod_{i=1}^NP(x_i|\theta)</script><p>为了便于计算，通常把$\prod$，利用对数可以转换成$\log$。因此就定义了对数似然函数（通常取e作为底数）：</p>
<script type="math/tex; mode=display">
记H(\theta)=log~l(\theta) \\
\hat{\theta}=arg~\mathop{max}_\theta~H(\theta)=arg~\mathop{max}_\theta~log~l(\theta)=arg~\mathop{max}_\theta\sum_{i=1}^Nlog~(P(x_i|\theta))</script><p>然后通过，求导使式子等于0就可以求出$\theta$的值了。</p>
<h4 id="2-3、Jensen不等式"><a href="#2-3、Jensen不等式" class="headerlink" title="2.3、Jensen不等式"></a>2.3、Jensen不等式</h4><p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153745.png" alt="image-20200904153745173" style="zoom:80%;" /></p>
<p><img src="https://pic3.zhimg.com/v2-22d1d68bb9db46d48c1a4c194477427c_b.jpg" alt="img"></p>
<p>注：若函数 $f$ 是凹函数，Jensen不等式符号相反。</p>
<h3 id="3、EM算法"><a href="#3、EM算法" class="headerlink" title="3、EM算法"></a>3、EM算法</h3><h4 id="3-1、EM算法的引入"><a href="#3-1、EM算法的引入" class="headerlink" title="3.1、EM算法的引入"></a>3.1、EM算法的引入</h4><p>首先通过书上的三硬币模型来导入，这里我就直接将书上的题目拍下来了。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/1.jpg" style="zoom: 25%;" /></p>
<script type="math/tex; mode=display">
\begin{cases}
\pi p+(1-\pi)q，y=1\\
\pi(1-p)+(1-\pi)(1-q)，y=0\tag{1}
\end{cases}</script><p>将(1)式合并一下就得到：</p>
<script type="math/tex; mode=display">
\pi p^y(1-p)^{1-y}+(1-\pi)q^y(1-q)^{1-y}\tag{2}</script><p>接下来来推导书上的三硬币模型也就是<code>公式(9.1)</code>。</p>
<script type="math/tex; mode=display">
P(y|\theta)=\sum_zP(y,z|\theta)</script><p>这一步就是前面说过的联合概率和边缘概率的关系。下面来证明</p>
<script type="math/tex; mode=display">
\sum_zP(y,z|\theta)=\sum_zP(z|\theta)P(y|z,\theta)\\
左边=\sum_z\frac{P(y,z,\theta)}{P(\theta)}\\
右边=\sum_z\frac{P(z,\theta)}{P(\theta)}P(y|z,\theta)=\sum_z\frac{P(y,z,\theta)}{P(\theta)}</script><p>因此该等式成立。然后再结合<code>公式(2)</code>就可以得出书上的<code>公式(9.1)</code>。</p>
<p>将观测数据表示为$Y=(Y_1,Y_2,Y_3,\cdots,Y_n)^T$，未观测数据表示为$Z=(Z_1,Z_2,Z_3,\cdots,Z_n)^T$，所以观测数据的似然函数为</p>
<script type="math/tex; mode=display">
P(Y|\theta)=\sum_ZP(Y,Z|\theta)=\sum_ZP(Z|\theta)P(Y|Z,\theta)) \tag{9.2}</script><p>即</p>
<script type="math/tex; mode=display">
P(Y|\theta)=\prod_{j=1}^n[\pi p^{y_j}(1-p)^{1-y_j}+(1-\pi)q^{y_j}(1-q)^{1-y_j}]\tag{9.3}</script><p>考虑求模型参数$\theta=(\theta,p,q)$的极大似然估计，即</p>
<script type="math/tex; mode=display">
\hat{\theta}=arg~\mathop{max}_{\theta}log~P(Y|\theta)\tag{9.4}</script><p>由于这个问题没有解析解，只有通过迭代的方法求解，EM算法就是可以用于求解这个问题的一种迭代算法。每次迭代包含两步：E步，求期望；M步，求极大化。下面来介绍EM算法。</p>
<h4 id="3-2、EM算法的导出"><a href="#3-2、EM算法的导出" class="headerlink" title="3.2、EM算法的导出"></a>3.2、EM算法的导出</h4><p>我们面对一个含有隐变量的概率模型，目标是极大化观测数据（不完全数据）Y关于参数$\theta$的对数似然函数，即极大化</p>
<script type="math/tex; mode=display">
L(\theta)=log~P(Y|\theta)=log~\sum_ZP(Y,Z|\theta)=log(\sum_ZP(Y|Z,\theta)P(Z|\theta))\tag{9.12}</script><p>然后我们要来极大化$L(\theta)$，也就是要对$\theta$求导咯。我们先来展开看看$L(\theta)$长什么样子。</p>
<script type="math/tex; mode=display">
L(\theta)=log[(Y|Z_1,\theta)P(Z_1|\theta)+(Y|Z_2,\theta)P(Z_2|\theta)+\cdots+(Y|Z_n,\theta)P(Z_n|\theta)]</script><p>这个式子求导后的形式自己脑补一下就知道很复杂了吧。所以很难通过求导来求解得到$\theta$。因此我们想一下可不可以把$\sum$符号从$log$当中提出来呢。因此，这里我们前面说过的Jensen不等式就派上用场了。得到了它的下界。</p>
<script type="math/tex; mode=display">
L(\theta)=log(\sum_ZP(Y|Z,\theta)P(Z|\theta))=log(\sum_ZQ(Z)\frac{P(Y|Z,\theta)P(Z|\theta)}{Q(Z)})\tag{3}</script><script type="math/tex; mode=display">
>=\sum_ZQ(Z)log~\frac{P(Y|Z,\theta)P(Z|\theta)}{Q(Z)}\tag{4}</script><p>上面<code>公式(3)</code>中引入了一个新的未知的分布Q(Z)，满足：</p>
<script type="math/tex; mode=display">
\sum_zQ(z)=1,其中，0<=Q(z)<=1</script><p><code>公式(4)</code>用到了Jensen不等式（对数函数是凹函数）：</p>
<script type="math/tex; mode=display">
log(E(x))>=E(log(x))</script><p>其中：</p>
<script type="math/tex; mode=display">
E(x)=\sum_i\lambda_ix_i,\lambda_i>=0,\sum_i\lambda_i=1\\
x_i=\frac{P(Y,Z^i|\theta)}{Q(Z^i)}\\
\lambda_i=Q(Z^i)</script><p>由 Jensen 不等式可知，等式成立的条件是随机变量是常数，则有：</p>
<script type="math/tex; mode=display">
\frac{P(Y,Z^i|\theta)}{Q(Z^i)}=c</script><p>其中c为常数，对于任意<code>i</code>，我们得到</p>
<script type="math/tex; mode=display">
P(Y,Z^i|\theta)=cQ(Z^i)\tag{5}</script><p><code>方程(5)</code>两边同时累加和：</p>
<script type="math/tex; mode=display">
\sum_zP(Y,Z|\theta)=c\sum_zQ(z)</script><p>由于$\sum_ZQ(Z)=1$。从上面式子中得到$\sum_ZP(Y,Z|\theta)=c$</p>
<p>所以：$Q_(Z^i)=\frac{P(Y,Z^i|\theta)}{c}=\frac{P(Y,Z^i|\theta)}{\sum_ZP(Y,Z|\theta)}=\frac{P(Y,Z|\theta)}{P(Y|\theta)}=P(Z|Y,\theta)$。这就是<code>书中公式(9.13)</code>上面为什么分子分母同时乘以$P(Z|Y,\theta^{(i)})$。</p>
<h3 id="4、EM算法案例-两硬币模型"><a href="#4、EM算法案例-两硬币模型" class="headerlink" title="4、EM算法案例-两硬币模型"></a>4、<a href="https://link.zhihu.com/?target=http%3A//ai.stanford.edu/~chuongdo/papers/em_tutorial.pdf">EM算法案例-两硬币模型</a></h3><p>假设有两枚硬币A、B，以相同的概率随机选择一个硬币，进行如下的掷硬币实验：共做 5 次实验，每次实验独立的掷十次，结果如图中 a 所示，例如某次实验产生了H、T、T、T、H、H、T、H、T、H (H代表正面朝上)。a 是在知道每次选择的是A还是B的情况下进行，b是在不知道选择的是A还是B的情况下进行，问如何估计两个硬币正面出现的概率？</p>
<p><img src="https://pic4.zhimg.com/80/v2-a5b47206d802b392e0e72a23c6b7bb95_720w.jpg" alt="img"></p>
<p><strong>CASE a</strong></p>
<p>已知每个实验选择的是硬币A 还是硬币 B，重点是如何计算输出的概率分布，这其实也是极大似然求导所得。<br><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904152856.png" alt="image-20200904152856113"><br>上面这个式子求导之后发现，5 次实验中A正面向上的次数再除以总次数作为即为 $\hat{\theta}_A$，5次实验中B正面向上的次数再除以总次数作为即为 ，即:</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153119.png" alt="image-20200904153119865" style="zoom: 67%;" /></p>
<p><strong>CASE b</strong></p>
<p>由于并不知道选择的是硬币 A 还是硬币 B，因此采用EM算法。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153149.png" alt="image-20200904153149814" style="zoom:67%;" /></p>
<p>计算出每个实验为硬币 A 和硬币 B 的概率，然后进行加权求和。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153230.png" alt="image-20200904153230384" style="zoom:67%;" /></p>
<p>针对L函数求导来对参数求导，例如对 $\theta_A$求导：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153322.png" alt="image-20200904153322627" style="zoom:67%;" /></p>
<p>求导等于 0 之后就可得到图中的第一次迭代之后的参数值:</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153346.png" alt="image-20200904153346590" style="zoom:67%;" /></p>
<p>当然，基于Case a 我们也可以用一种更简单的方法求得：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153400.png" alt="image-20200904153400339" style="zoom:67%;" /></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/Godg1000/picture_bed/raw/master/img/20200904153413.png" alt="image-20200904153413865"  /></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EM</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, prob)</span>:</span></span><br><span class="line">        self.pro_A, self.pro_B, self.pro_C = prob</span><br><span class="line"></span><br><span class="line">    <span class="comment"># e_step</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pmf</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="comment"># 硬币B产生y的概率</span></span><br><span class="line">        pro_1 = self.pro_A * math.pow(self.pro_B, data[i]) * math.pow(</span><br><span class="line">            (<span class="number">1</span> - self.pro_B), <span class="number">1</span> - data[i])</span><br><span class="line">        <span class="comment"># 硬币A产生y的概率</span></span><br><span class="line">        pro_2 = (<span class="number">1</span> - self.pro_A) * math.pow(self.pro_C, data[i]) * math.pow(</span><br><span class="line">            (<span class="number">1</span> - self.pro_C), <span class="number">1</span> - data[i])</span><br><span class="line">        <span class="comment"># y来自硬币B的概率，也就是公式(9.5)</span></span><br><span class="line">        <span class="keyword">return</span> pro_1 / (pro_1 + pro_2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># m_step</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        count = len(data)</span><br><span class="line">        print(<span class="string">'init prob:&#123;&#125;, &#123;&#125;, &#123;&#125;'</span>.format(self.pro_A, self.pro_B,</span><br><span class="line">                                            self.pro_C))</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> range(count):</span><br><span class="line">            _ = <span class="keyword">yield</span></span><br><span class="line">            _pmf = [self.pmf(k) <span class="keyword">for</span> k <span class="keyword">in</span> range(count)]</span><br><span class="line">            <span class="comment"># 公式(9.6)</span></span><br><span class="line">            pro_A = <span class="number">1</span> / count * sum(_pmf)</span><br><span class="line">            <span class="comment"># 公式(9.7)</span></span><br><span class="line">            pro_B = sum([_pmf[k] * data[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(count)]) / sum(</span><br><span class="line">                [_pmf[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(count)])</span><br><span class="line">            <span class="comment"># 公式(9.8)</span></span><br><span class="line">            pro_C = sum([(<span class="number">1</span> - _pmf[k]) * data[k]</span><br><span class="line">                         <span class="keyword">for</span> k <span class="keyword">in</span> range(count)]) / sum([(<span class="number">1</span> - _pmf[k])</span><br><span class="line">                                                        <span class="keyword">for</span> k <span class="keyword">in</span> range(count)])</span><br><span class="line">            print(<span class="string">'&#123;&#125;/&#123;&#125;  pro_a:&#123;:.3f&#125;, pro_b:&#123;:.3f&#125;, pro_c:&#123;:.3f&#125;'</span>.format(</span><br><span class="line">                d + <span class="number">1</span>, count, pro_A, pro_B, pro_C))</span><br><span class="line">            self.pro_A = pro_A</span><br><span class="line">            self.pro_B = pro_B</span><br><span class="line">            self.pro_C = pro_C</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我这里直接使用书上的数据</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 初始化的概率也选择跟书上一样</span></span><br><span class="line">em = EM(prob=[<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">f = em.fit(data)</span><br><span class="line">next(f)</span><br><span class="line"><span class="comment"># 输出 init prob:0.5, 0.5, 0.5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次迭代</span></span><br><span class="line">f.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出 1/10  pro_a:0.500, pro_b:0.600, pro_c:0.600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次</span></span><br><span class="line">f.send(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 输出 2/10  pro_a:0.500, pro_b:0.600, pro_c:0.600</span></span><br></pre></td></tr></table></figure>
<p>可以看出跟书上得出的结果是一样一样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 书中另一个初始化的概率为[0.4, 0.6, 0.7]</span></span><br><span class="line">em = EM(prob=[<span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.7</span>])</span><br><span class="line">f2 = em.fit(data)</span><br><span class="line">next(f2)</span><br><span class="line"><span class="comment"># 输出 init prob:0.4, 0.6, 0.7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次迭代</span></span><br><span class="line">f2.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出 1/10  pro_a:0.406, pro_b:0.537, pro_c:0.643</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次迭代</span></span><br><span class="line">f2.send(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 输出 2/10  pro_a:0.406, pro_b:0.537, pro_c:0.643</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三次迭代</span></span><br><span class="line">f2.send(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 输出 3/10  pro_a:0.406, pro_b:0.537, pro_c:0.643</span></span><br></pre></td></tr></table></figure>
<p>一直迭代下去也就是书上的那个概率。至此EM算法的一些笔记到这里就结束了，如果跟书本有出入的，还是以书本为准。溜了~</p>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://blog.csdn.net/tick_tock97/article/details/79885868" target="_blank" rel="noopener">https://blog.csdn.net/tick_tock97/article/details/79885868</a></li>
<li><a href="https://blog.csdn.net/zengxiantao1994/article/details/72787849" target="_blank" rel="noopener">https://blog.csdn.net/zengxiantao1994/article/details/72787849</a></li>
<li>李航《统计学习方法》第二版</li>
<li><a href="https://www.zhihu.com/collection/582310071" target="_blank" rel="noopener">https://www.zhihu.com/collection/582310071</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35698329" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35698329</a></li>
<li><a href="http://ai.stanford.edu/~chuongdo/papers/em_tutorial.pdf" target="_blank" rel="noopener">http://ai.stanford.edu/~chuongdo/papers/em_tutorial.pdf</a></li>
<li><a href="https://github.com/wzyonggege/statistical-learning-method" target="_blank" rel="noopener">https://github.com/wzyonggege/statistical-learning-method</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法——隐马尔科夫模型</title>
    <url>/2020/09/07/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p><strong>摘要：</strong>隐马尔可夫模型（hidden Markov model，HMM）是可用于标注问题的统计学习模型，描述由隐藏的马尔可夫链随机生成观测序列的过程，属于生成模型。隐马尔可夫模型在语音识别，自然语言处理，生物信息，模式识别等领域有着广泛的应用。</p>
<h3 id="1、马尔科夫模型与HMM"><a href="#1、马尔科夫模型与HMM" class="headerlink" title="1、马尔科夫模型与HMM"></a>1、<strong>马尔科夫模型与HMM</strong></h3><p>&emsp;&emsp;要讲隐马尔科夫模型，需要先从马尔科夫模型讲起。已知N个有序随机变量，根据贝叶斯定理，他们的联合分布可以写成条件分布的连乘积：</p>
<script type="math/tex; mode=display">
P(x_1,x_2,\cdots,x_N)=\prod_{n=1}^NP(x_n|x_{n-1},\cdots,x_1)\tag{1}</script><p>&emsp;&emsp;马尔科夫模型是指，假设序列中的任何一个随机变量在给定它的前一个变量时的分布与更早的变量无关，即：</p>
<script type="math/tex; mode=display">
P(x_n|x_{n-1},\cdots,x_1)=P(x_n|x_{n-1})\tag{2}</script><p>&emsp;&emsp;在此假设下，N个随机变量的联合分布可以简化为：</p>
<script type="math/tex; mode=display">
P(x_1,x_2,\cdots,x_N)=\prod_{n=2}^NP(x_n|x_{n-1})\tag{3}</script><p>&emsp;&emsp;一阶马尔科夫性只能表达当前变量与前一个变量的关系，然而很多实际问题往往没有这么简单。为了表达当前变量与更早的变量之间的关系，可以引入高阶马尔科夫性。概括来说，M阶马尔科夫性是指当前随机变量在给定其之前的M个变量时与更早的变量无关，用公式表达就是：</p>
<script type="math/tex; mode=display">
P(x_n|x_{n-1},\cdots,x_1)=P(x_n|x_{n-1},\cdots,x_{n-M})\tag{4}</script><p>&emsp;&emsp;高阶马尔科夫性虽然达到了关联当前变量与更早的变量的目的，但有一个问题就是指数爆炸问题，即参数数量随着M的增大呈指数增长。假设每个随机变量有<code>K</code>种状态，对于一阶马尔科夫模型而言，要表达条件分布$P(x_n|x_{n-1})$，因为对于$x_{n-1}$的每个取值（共有<code>K</code>个取值）需要<code>K</code>个$x_n$的取值，根据条件概率的定义，这<code>K</code>个值的和为1，因此实际有个<code>K-1</code>个自由参数，因此共需要<code>K(K-1)</code>个参数。同理，对于<code>M</code>阶马尔科夫模型而言，要表达条件分布$P(x_n|x_{n-1},\cdots,x_{n-M})$，则需要$K^M(K-1)$个参数（对于$x_n,\cdots,x_{n-M}$的每一个取值的组合（共$K^M$个），都需要<code>K-1</code>个$x_n$的取值）。</p>
<p>&emsp;&emsp;那么，有没有一种方法即能将当前变量与更早的变量关联起来，又不需要那么多参数呢？当然，这里有一种非常强大的手段，即引入隐变量，这是机器学习中用简单的基础部件表达丰富的模型的有力手段。这里如果假设隐变量构成一阶马尔科夫模型，而每个观测变量与一个隐变量关联，则可以得到一类模型的基础结构，即状态空间模型。如下图，$z_n$为隐藏变量，$x_n$为观测变量。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200907182750.jpg" alt="img" style="zoom: 67%;" /></p>
<p>该类模型的关键是隐藏变量之间满足如下条件独立性，即在给定$z_n$时，$z_{n-1}$和$z_{n+1}$条件独立：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200907232309.jpg" alt="img"></p>
<p>这类模型的联合分布可以表示为：</p>
<script type="math/tex; mode=display">
P(x_1,\cdots,x_N,z_1,\cdots,z_N)=P(z_1)</script><p>&emsp;&emsp;可见，看似很复杂的模型被分解成了简单的$P(z_1)$、$P(z_n|z_{n-1})$和$P(x_n|z_n)$部分，这三者分别叫做<strong>初始概率模型、转移概率模型和观测概率模型</strong>，对状态空间模型建模实际就是对这三者进行建模。而且此时观测变量之间不再具有任何马尔科夫性，因为此时$x_n$的分布与其之前所有的观测变量都相关，无法从的$P(x_n|x_{n-1},\cdots,x_1)$条件变量中拿掉任何一个变量，这样就将一个变量与其之前所有的变量关联起来了。这就是隐变量的能力。</p>
<p>&emsp;&emsp;当$z_n$为离散变量时，该状态空间模型即为隐马尔科夫模型。现在可以解释一下“隐马尔科夫”这个名字的含义了。“马尔科夫”自然是表示随机变量之间构成一个马尔科夫链了。而“隐”是指我们要推测的变量是未知的、隐藏的。正是这些隐藏的变量构成了马尔科夫链，所以就叫“隐马尔科夫”了。</p>
<h3 id="2、隐马尔可夫模型"><a href="#2、隐马尔可夫模型" class="headerlink" title="2、隐马尔可夫模型"></a>2、隐马尔可夫模型</h3><p>&emsp;&emsp;隐藏的马尔可夫链随机生成的状态的序列，称为<strong>状态序列</strong>；每个状态生成一个一个观测，而由此产生的观测的随机序列，称为<strong>观测序列</strong>。</p>
<p>&emsp;&emsp;设Q是所有可能的状态的集合，V是所有可能的观测的集合：</p>
<script type="math/tex; mode=display">
Q=\lbrace q_1,q_2,\cdots,q_N \rbrace，V=\lbrace v_1,v_2,\cdots,v_M \rbrace</script><p>其中，N是所有可能的状态的集合，V是所有可能的观测的集合。</p>
<p>&emsp;&emsp;I是长度为T的状态序列，O是对应的观测序列：</p>
<script type="math/tex; mode=display">
I=(i_1,i_2,\cdots,i_T)，O=(o_1,o_2,\cdots,o_T)</script><p>&emsp;&emsp;A是状态转移概率矩阵：</p>
<script type="math/tex; mode=display">
A=[a_{ij}]_{N\times N}</script><p>其中，</p>
<script type="math/tex; mode=display">
a_{ij}=P(i_{t+1}=q_j|i_t=q_i)，i=1,2,\cdots,N;~~~j=1,2,\cdots,N</script><p>是在时刻$t$处于状态$q_i$的条件下在时刻$t+1$转移到状态$q_j$的概率。</p>
<p>&emsp;&emsp;B是观测概率矩阵：</p>
<script type="math/tex; mode=display">
B=[b_j(k)]_{N\times M}</script><p>其中，</p>
<script type="math/tex; mode=display">
b_j(k)=P(o_t=v_k|i_t=q_j)，~~k=1,2,\cdots,M;~~~j=1,2,\cdots,N</script><p>是在时刻$t$处于状态$q_j$的条件下生成观测$v_k$的概率。</p>
<p>&emsp;&emsp;$\pi$是初始状态概率向量：</p>
<script type="math/tex; mode=display">
\pi=(\pi_i)</script><p>其中，</p>
<script type="math/tex; mode=display">
\pi_i=P(i_1=q_i)，i=1,2,\cdots,N</script><p>是时刻$t=1$处于状态$q_i$的概率。</p>
<h3 id="3、隐马尔可夫模型的3个基本问题"><a href="#3、隐马尔可夫模型的3个基本问题" class="headerlink" title="3、隐马尔可夫模型的3个基本问题"></a>3、隐马尔可夫模型的3个基本问题</h3><ol>
<li>概率计算问题</li>
<li>学习问题</li>
<li>预测问题</li>
</ol>
<p>为了解决上述的三个问题，由此产生了一些算法。</p>
<h4 id="3-1、概率计算算法"><a href="#3-1、概率计算算法" class="headerlink" title="3.1、概率计算算法"></a>3.1、概率计算算法</h4><ul>
<li>直接计算法（计算复杂度达到了$TN^T$，复杂度太高，因此在实际中不使用）</li>
<li>前向算法</li>
<li>后向算法</li>
</ul>
<p>1）前向算法：</p>
<p><strong>定义</strong>：给定马尔可夫模型$\lambda$，定义到时刻$t$部分观测序列为$o_1,o_2,\cdots,o_t$且状态为$q_i$的概率为前向概率，记作</p>
<script type="math/tex; mode=display">
\alpha_t(i)=P(o_1,o_2,\cdots,o_t,i_t=q_i|\lambda)</script><p>2）后向算法：</p>
<p><strong>定义</strong>：给定马尔可夫模型$\lambda$，定义在时刻$t$状态为$q_i$的条件下，从$t+1$到$T$的 部分观测序列为$o_{t+1},o_{t+2},\cdots,o_T$的概率为后向概率，记作</p>
<script type="math/tex; mode=display">
\beta_t(i)=P(o_{t+1},o_{t+2},\cdots,o_T|i_t=q_i,\lambda)</script><h4 id="3-2、学习算法"><a href="#3-2、学习算法" class="headerlink" title="3.2、学习算法"></a>3.2、学习算法</h4><ul>
<li>监督学习算法</li>
<li>无监督学习算法——Baum-Welch算法（也就是EM算法）</li>
</ul>
<p>1）监督学习算法：</p>
<p>使用极大似然估计法来估计模型参数</p>
<script type="math/tex; mode=display">
\hat{a}_{ij}=\frac{A_{ij}}{\sum_{j=1}^NA_{ij}}，i=1,2,\cdots,N;~~~j=1,2,\cdots,N \\
\hat{b}_j(k)=\frac{B_{jk}}{\sum_{k=1}^MB_{jk}}，j=1,2,\cdots,N;~~~k=1,2,\cdots,M</script><p>2）无监督学习算法：</p>
<script type="math/tex; mode=display">
a_{ij}^{(n+1)}=\frac{\sum_{t=1}^{T-1}\zeta_t(i,j)}{\sum_{t=1}^{T-1}\gamma_t(i)}\\ \\
b_j(k)^{(n+1)}=\frac{\sum_{t=1,o_t=v_k}^T\gamma_t(j)}{\sum_{t=1}^T\gamma_t(j)}\\ \\
\pi_i^{(n+1)}=\gamma_1(i)</script><h4 id="3-3、预测算法"><a href="#3-3、预测算法" class="headerlink" title="3.3、预测算法"></a>3.3、预测算法</h4><ul>
<li>近似算法</li>
<li>维特比算法</li>
</ul>
<p>1）近似算法：</p>
<script type="math/tex; mode=display">
\gamma_t(i)=\frac{\alpha_t(i)\beta_t(i)}{P(O|\lambda)}=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\beta_t(j)} \\
i_t^*=arg ~\mathop{max}_{1\le i\le N}~[\gamma_t(i)]，t=1,2,\cdots,T \\
I^*=(i_1^*,i_2^*,\cdots,i_T^*)</script><p>2）维特比算法：</p>
<p>这个算法就要隆重的来学习一下了。维特比算法实际是用<a href="https://www.yakult.icu/2020/08/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/#more" target="_blank" rel="noopener">动态规划</a>解隐马尔可夫模型预测问题，即用动态规划求解概率最大路径（最优路径）。（动态规划看另外一个博客）</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200909141628.png" alt="9825bc315c6034a83754a192cc1349540923766a" style="zoom:67%;" /></p>
<p>1）如果概率最大的路径p(或者说最短路径)经过某个点，比如途中的$X_{22}$，那么这条路径上的起始点S到X22的这段子路径Q，一定是S到$X_{22}$之间的最短路径。否则，用S到$X_{22}$的最短路径R替代Q，便构成一条比P更短的路径，这显然是矛盾的。证明了满足最优性原理。</p>
<p>2）从S到E的路径必定经过第i个时刻的某个状态，假定第i个时刻有k个状态，那么如果记录了从S到第i个状态的所有k个节点的最短路径，最终的最短路径必经过其中一条，这样，在任意时刻，只要考虑非常有限的最短路即可。</p>
<p>3）结合以上两点，假定当我们从状态i进入状态i+1时，从S到状态i上各个节的最短路径已经找到，并且记录在这些节点上，那么在计算从起点S到第i+1状态的某个节点$X_{i+1}$的最短路径时，只要考虑从S到前一个状态i所有的k个节点的最短路径，以及从这个节点到$X_{i+1}$，j的距离即可。 </p>
<h3 id="4、代码实践"><a href="#4、代码实践" class="headerlink" title="4、代码实践"></a>4、代码实践</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiddenMarkov</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, Q, V, A, B, O, PI)</span>:</span>  <span class="comment"># 使用前向算法</span></span><br><span class="line">        N = len(Q)  <span class="comment">#可能存在的状态数量</span></span><br><span class="line">        M = len(O)  <span class="comment"># 观测序列的大小</span></span><br><span class="line">        alphas = np.zeros((N, M))  <span class="comment"># alpha值</span></span><br><span class="line">        T = M  <span class="comment"># 有几个时刻，有几个观测序列，就有几个时刻</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(T):  <span class="comment"># 遍历每一时刻，算出alpha值</span></span><br><span class="line">            indexOfO = V.index(O[t])  <span class="comment"># 找出序列对应的索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">if</span> t == <span class="number">0</span>:  <span class="comment"># 计算初值</span></span><br><span class="line">                    alphas[i][t] = PI[t][i] * B[i][indexOfO]  <span class="comment"># P176（10.15）</span></span><br><span class="line">                    print(</span><br><span class="line">                        <span class="string">'alpha1(%d)=p%db%db(o1)=%f'</span> % (i, i, i, alphas[i][t]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    alphas[i][t] = np.dot(</span><br><span class="line">                        [alpha[t - <span class="number">1</span>] <span class="keyword">for</span> alpha <span class="keyword">in</span> alphas],</span><br><span class="line">                        [a[i] <span class="keyword">for</span> a <span class="keyword">in</span> A]) * B[i][indexOfO]  <span class="comment"># 对应P176（10.16）</span></span><br><span class="line">                    print(<span class="string">'alpha%d(%d)=[sigma alpha%d(i)ai%d]b%d(o%d)=%f'</span> %</span><br><span class="line">                          (t, i, t - <span class="number">1</span>, i, i, t, alphas[i][t]))</span><br><span class="line">                    <span class="comment"># print(alphas)</span></span><br><span class="line">        P = np.sum([alpha[M - <span class="number">1</span>] <span class="keyword">for</span> alpha <span class="keyword">in</span> alphas])  <span class="comment"># P176(10.17)</span></span><br><span class="line">        <span class="comment"># alpha11 = pi[0][0] * B[0][0]    #代表a1(1)</span></span><br><span class="line">        <span class="comment"># alpha12 = pi[0][1] * B[1][0]    #代表a1(2)</span></span><br><span class="line">        <span class="comment"># alpha13 = pi[0][2] * B[2][0]    #代表a1(3)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, Q, V, A, B, O, PI)</span>:</span>  <span class="comment"># 后向算法</span></span><br><span class="line">        N = len(Q)  <span class="comment"># 可能存在的状态数量</span></span><br><span class="line">        M = len(O)  <span class="comment"># 观测序列的大小</span></span><br><span class="line">        betas = np.ones((N, M))  <span class="comment"># beta</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            print(<span class="string">'beta%d(%d)=1'</span> % (M, i))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(M - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            indexOfO = V.index(O[t + <span class="number">1</span>])  <span class="comment"># 找出序列对应的索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                betas[i][t] = np.dot(</span><br><span class="line">                    np.multiply(A[i], [b[indexOfO] <span class="keyword">for</span> b <span class="keyword">in</span> B]),</span><br><span class="line">                    [beta[t + <span class="number">1</span>] <span class="keyword">for</span> beta <span class="keyword">in</span> betas])</span><br><span class="line">                realT = t + <span class="number">1</span></span><br><span class="line">                realI = i + <span class="number">1</span></span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">'beta%d(%d)=[sigma a%djbj(o%d)]beta%d(j)=('</span> %</span><br><span class="line">                    (realT, realI, realI, realT + <span class="number">1</span>, realT + <span class="number">1</span>),</span><br><span class="line">                    end=<span class="string">''</span>)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                    print(</span><br><span class="line">                        <span class="string">"%.2f*%.2f*%.2f+"</span> % (A[i][j], B[j][indexOfO],</span><br><span class="line">                                             betas[j][t + <span class="number">1</span>]),</span><br><span class="line">                        end=<span class="string">''</span>)</span><br><span class="line">                print(<span class="string">"0)=%.3f"</span> % betas[i][t])</span><br><span class="line">        <span class="comment"># print(betas)</span></span><br><span class="line">        indexOfO = V.index(O[<span class="number">0</span>])</span><br><span class="line">        P = np.dot(</span><br><span class="line">            np.multiply(PI, [b[indexOfO] <span class="keyword">for</span> b <span class="keyword">in</span> B]),</span><br><span class="line">            [beta[<span class="number">0</span>] <span class="keyword">for</span> beta <span class="keyword">in</span> betas])</span><br><span class="line">        print(<span class="string">"P(O|lambda)="</span>, end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">"%.1f*%.1f*%.5f+"</span> % (PI[<span class="number">0</span>][i], B[i][indexOfO], betas[i][<span class="number">0</span>]),</span><br><span class="line">                end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"0=%f"</span> % P)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">viterbi</span><span class="params">(self, Q, V, A, B, O, PI)</span>:</span></span><br><span class="line">        N = len(Q)  <span class="comment">#可能存在的状态数量</span></span><br><span class="line">        M = len(O)  <span class="comment"># 观测序列的大小</span></span><br><span class="line">        deltas = np.zeros((N, M))</span><br><span class="line">        psis = np.zeros((N, M))</span><br><span class="line">        I = np.zeros((<span class="number">1</span>, M))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(M):</span><br><span class="line">            realT = t + <span class="number">1</span></span><br><span class="line">            indexOfO = V.index(O[t])  <span class="comment"># 找出序列对应的索引</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                realI = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                    deltas[i][t] = PI[<span class="number">0</span>][i] * B[i][indexOfO]</span><br><span class="line">                    psis[i][t] = <span class="number">0</span></span><br><span class="line">                    print(<span class="string">'delta1(%d)=pi%d * b%d(o1)=%.2f * %.2f=%.2f'</span> %</span><br><span class="line">                          (realI, realI, realI, PI[<span class="number">0</span>][i], B[i][indexOfO],</span><br><span class="line">                           deltas[i][t]))</span><br><span class="line">                    print(<span class="string">'psis1(%d)=0'</span> % (realI))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    deltas[i][t] = np.max(</span><br><span class="line">                        np.multiply([delta[t - <span class="number">1</span>] <span class="keyword">for</span> delta <span class="keyword">in</span> deltas],</span><br><span class="line">                                    [a[i] <span class="keyword">for</span> a <span class="keyword">in</span> A])) * B[i][indexOfO]</span><br><span class="line">                    print(</span><br><span class="line">                        <span class="string">'delta%d(%d)=max[delta%d(j)aj%d]b%d(o%d)=%.2f*%.2f=%.5f'</span></span><br><span class="line">                        % (realT, realI, realT - <span class="number">1</span>, realI, realI, realT,</span><br><span class="line">                           np.max(</span><br><span class="line">                               np.multiply([delta[t - <span class="number">1</span>] <span class="keyword">for</span> delta <span class="keyword">in</span> deltas],</span><br><span class="line">                                           [a[i] <span class="keyword">for</span> a <span class="keyword">in</span> A])), B[i][indexOfO],</span><br><span class="line">                           deltas[i][t]))</span><br><span class="line">                    psis[i][t] = np.argmax(</span><br><span class="line">                        np.multiply(</span><br><span class="line">                            [delta[t - <span class="number">1</span>] <span class="keyword">for</span> delta <span class="keyword">in</span> deltas],</span><br><span class="line">                            [a[i]</span><br><span class="line">                             <span class="keyword">for</span> a <span class="keyword">in</span> A])) + <span class="number">1</span>  <span class="comment">#由于其返回的是索引，因此应+1才能和正常的下标值相符合。</span></span><br><span class="line">                    print(<span class="string">'psis%d(%d)=argmax[delta%d(j)aj%d]=%d'</span> %</span><br><span class="line">                          (realT, realI, realT - <span class="number">1</span>, realI, psis[i][t]))</span><br><span class="line">        print(deltas)</span><br><span class="line">        print(psis)</span><br><span class="line">        I[<span class="number">0</span>][M - <span class="number">1</span>] = np.argmax([delta[M - <span class="number">1</span>] <span class="keyword">for</span> delta <span class="keyword">in</span> deltas</span><br><span class="line">                                 ]) + <span class="number">1</span>  <span class="comment">#由于其返回的是索引，因此应+1才能和正常的下标值相符合。</span></span><br><span class="line">        print(<span class="string">'i%d=argmax[deltaT(i)]=%d'</span> % (M, I[<span class="number">0</span>][M - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(M - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            I[<span class="number">0</span>][t] = psis[int(I[<span class="number">0</span>][t + <span class="number">1</span>]) - <span class="number">1</span>][t + <span class="number">1</span>]</span><br><span class="line">            print(<span class="string">'i%d=psis%d(i%d)=%d'</span> % (t + <span class="number">1</span>, t + <span class="number">2</span>, t + <span class="number">2</span>, I[<span class="number">0</span>][t]))</span><br><span class="line">        print(<span class="string">"状态序列I："</span>, I)</span><br></pre></td></tr></table></figure>
<p><strong>Reference:</strong></p>
<ul>
<li><a href="https://www.zhihu.com/people/yi-zhi-luo-shui-de-zhu" target="_blank" rel="noopener">https://www.zhihu.com/people/yi-zhi-luo-shui-de-zhu</a></li>
<li>统计学习方法（第二版）</li>
<li>数学之美</li>
<li><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">https://github.com/fengdu78/lihang-code</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>金融风控-贷款违约预测</title>
    <url>/2020/09/12/%E9%87%91%E8%9E%8D%E9%A3%8E%E6%8E%A7-%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>&emsp;<a id="more"></a></p>
<p><strong>摘要：</strong>赛题以金融风控中的个人信贷为背景，要求选手根据贷款申请人的数据信息预测其是否有违约的可能，以此判断是否通过此项贷款，这是一个典型的分类问题。赛题以预测用户贷款是否违约为任务，数据集报名后可见并可下载，该数据来自某信贷平台的贷款记录，总数据量超过120w，包含47列变量信息，其中15列为匿名变量。为了保证比赛的公平性，将会从中抽取80万条作为训练集，20万条作为测试集A，20万条作为测试集B，同时会对employmentTitle、purpose、postCode和title等信息进行脱敏。比赛链接——<a href="https://tianchi.aliyun.com/competition/entrance/531830/information" target="_blank" rel="noopener">天池</a></p>
<h3 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h3><p>部分字段表，详细的请看赛题与数据中。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912143934.png" alt="image-20200912143831093" style="zoom:67%;" /></p>
<p><strong>评测标准</strong>：</p>
<p>本次比赛的评价方法为AUC评估模型效果（越大越好）。现在来看看什么是AUC。</p>
<p>混淆矩阵（Confuse Matrix）</p>
<ul>
<li>若一个实例是正类，并且被预测为正类，即为真正类TP(True Positive )</li>
<li>若一个实例是正类，但是被预测为负类，即为假负类FN(False Negative )</li>
<li>若一个实例是负类，但是被预测为正类，即为假正类FP(False Positive )</li>
<li>若一个实例是负类，并且被预测为负类，即为真负类TN(True Negative )</li>
</ul>
<p>ROC空间将假正例率（FPR）定义为 X 轴，真正例率（TPR）定义为 Y 轴。</p>
<p>TPR：在所有实际为正例的样本中，被正确地判断为正例之比率。</p>
<script type="math/tex; mode=display">TPR = \frac{TP}{TP + FN}</script><p>FPR：在所有实际为负例的样本中，被错误地判断为正例之比率。</p>
<script type="math/tex; mode=display">FPR = \frac{FP}{FP + TN}</script><p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912144353.jpg" alt="img" style="zoom:67%;" /></p>
<p>这是百度百科中关于AUC介绍的一张图。</p>
<p>AUC（Area Under Curve）被定义为ROC曲线下与坐标轴围成的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围在0.5和1之间。AUC越接近1.0，检测方法真实性越高;等于0.5时，则真实性最低，无应用价值。</p>
<p><strong>结果提交</strong>：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912144612.png" alt="image-20200912144612128"></p>
<p>下面通过<code>sklearn</code>库中的一些函数来简单演示下上面提到的混淆矩阵，ROC，以及AUC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 混淆矩阵</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">y_pred = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">print(<span class="string">'混淆矩阵:\n'</span>,confusion_matrix(y_true, y_pred))</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 输出</span><br><span class="line">混淆矩阵:</span><br><span class="line"><span class="string">[[1 1]</span></span><br><span class="line"><span class="string">[1 1]]</span></span><br></pre></td></tr></table></figure>
<p>其中<code>[0, 0]</code>表示的是TN，<code>[0, 1]</code>表示的是FP，<code>[1, 0]</code>表示的是FN，<code>[1, 1]</code>表示的是FP。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## ROC曲线</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">y_pred = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">FPR,TPR,thresholds=roc_curve(y_true, y_pred)</span><br><span class="line">plt.title(<span class="string">'ROC'</span>)</span><br><span class="line">plt.plot(FPR, TPR,<span class="string">'b'</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'TPR'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'FPR'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912145411.png" alt="image-20200912145411211" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## AUC</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">y_true = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">y_scores = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line">print(<span class="string">'AUC socre:'</span>,roc_auc_score(y_true, y_scores))</span><br><span class="line"><span class="comment"># AUC socre: 0.75</span></span><br></pre></td></tr></table></figure>
<p>AUC的取值就是上面ROC蓝色曲线和下坐标轴构成的面积。</p>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>首先导入数据分析及可视化会用到的库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure>
<p>读取<code>train.csv</code>和<code>testA.csv</code>的数据，并查看数据的大小、特征、缺失值之类的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(train.info(), testA.info())</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912151139.png" alt="image-20200912151139645" style="zoom: 80%;" /></p>
<p>训练集<code>train</code>的大小为80万，<code>testA</code>的大小为20万行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.describe()</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912151211.png" alt="image-20200912151211639" style="zoom: 67%;" /></p>
<p>特征比较多，只能展示部分了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">missing = train.isnull().sum()</span><br><span class="line">missing = missing[missing &gt; <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 并画出缺失率的图</span></span><br><span class="line">missing_rate = missing/len(train)</span><br><span class="line">missing_rate.plot.bar()</span><br></pre></td></tr></table></figure>
<center class="half">
    <img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912151323.png" alt="image-20200912151323722" width="300"/>
    <img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912151813.png" width="300"/>
</center>

<p>可以看出，<code>train</code>的缺失值还是不少的，但是占比不是很多。不过缺失值对于<code>xgb</code>，<code>lgb</code>等树模型来说可以直接空缺，树模型会自己优化，要是用别的模型还是要处理的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_value_fea = [col <span class="keyword">for</span> col <span class="keyword">in</span> train.columns <span class="keyword">if</span> train[col].nunique() &lt;= <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 'policyCode'</span></span><br><span class="line">one_value_fea_test = [col <span class="keyword">for</span> col <span class="keyword">in</span> testA.columns <span class="keyword">if</span> testA[col].nunique() &lt;= <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 'policyCode'</span></span><br></pre></td></tr></table></figure>
<p>然后我们发现<code>policyCode</code>这个记录不管是在训练集中还是测试集中 ，都只有一个值，那么这个就直接可以删去了，对模型丝毫没有影响。</p>
<p><strong>查看特征的数值类型和对象类型：</strong></p>
<ul>
<li>特征一般都是由类别型特征和数值型特征组成</li>
<li>类别型特征有时具有非数值关系，有时也具有数值关系。比如‘grade’中的等级A，B，C等，是否只是单纯的分类，还是A优于其他要结合业务判断。</li>
<li>数值型特征本是可以直接入模的，但往往风控人员要对其做分箱，转化为WOE编码进而做标准评分卡等操作。从模型效果上来看，特征分箱主要是为了降低变量的复杂性，减少变量噪音对模型的影响，提高自变量和因变量的相关度。从而使模型更加稳定。</li>
</ul>
<p>数值类型一般是能直接带进模型里面的，而对象模型也就是<code>object</code>是需要先处理一下的。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">numerical_fea = list(<span class="name">train</span>.select_dtypes(<span class="name">exclude=</span>['object']).columns)</span><br><span class="line">category_fea = list(<span class="name">train</span>.select_dtypes(<span class="name">include=</span>['object']).columns)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每个数字特征得分布可视化</span></span><br><span class="line">f = pd.melt(train, value_vars=numerical_fea)</span><br><span class="line">g = sns.FacetGrid(f, col=<span class="string">"variable"</span>,  col_wrap=<span class="number">2</span>, sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>)</span><br><span class="line">g = g.map(sns.distplot, <span class="string">"value"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200912154652.png" alt="1"></p>
<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>首先导入在这个过程中会用到的一些库，将数据读取进来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> catboost <span class="keyword">import</span> CatBoostRegressor</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold, KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, f1_score, roc_auc_score, log_loss</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train =pd.read_csv(<span class="string">'data/train.csv'</span>)</span><br><span class="line">testA = pd.read_csv(<span class="string">'data/testA.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>方便后序对特征的操作，在这里就把训练集的数据和测试集的数据拼接起来（后面再拆分开）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.concat([train, testA], axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'employmentLength'</span>].value_counts(dropna=<span class="literal">False</span>).sort_index()</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="string">year</span>        <span class="number">65671</span></span><br><span class="line"><span class="number">10</span><span class="string">+</span> <span class="string">years</span>    <span class="number">328525</span></span><br><span class="line"><span class="number">2</span> <span class="string">years</span>       <span class="number">90565</span></span><br><span class="line"><span class="number">3</span> <span class="string">years</span>       <span class="number">80163</span></span><br><span class="line"><span class="number">4</span> <span class="string">years</span>       <span class="number">59818</span></span><br><span class="line"><span class="number">5</span> <span class="string">years</span>       <span class="number">62645</span></span><br><span class="line"><span class="number">6</span> <span class="string">years</span>       <span class="number">46582</span></span><br><span class="line"><span class="number">7</span> <span class="string">years</span>       <span class="number">44230</span></span><br><span class="line"><span class="number">8</span> <span class="string">years</span>       <span class="number">45168</span></span><br><span class="line"><span class="number">9</span> <span class="string">years</span>       <span class="number">37866</span></span><br><span class="line"><span class="string">&lt;</span> <span class="number">1</span> <span class="string">year</span>      <span class="number">80226</span></span><br><span class="line"><span class="string">NaN</span>           <span class="number">58541</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">employmentLength,</span> <span class="attr">dtype:</span> <span class="string">int64</span></span><br></pre></td></tr></table></figure>
<p>从上面看出<code>employmentLength</code>是<code>object</code>类型，因此我们可以将字符串转成数字类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'employmentLength'</span>].replace(to_replace=<span class="string">'10+ years'</span>, value=<span class="string">'10 years'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">'employmentLength'</span>].replace(<span class="string">'&lt; 1 year'</span>, <span class="string">'0 years'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">employmentLength_to_int</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pd.isnull(s):</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.int8(s.split()[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">data[<span class="string">'employmentLength'</span>] = data[<span class="string">'employmentLength'</span>].apply(employmentLength_to_int)</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">10.0</span>    <span class="number">328525</span></span><br><span class="line"><span class="number">2.0</span>      <span class="number">90565</span></span><br><span class="line"><span class="number">0.0</span>      <span class="number">80226</span></span><br><span class="line"><span class="number">3.0</span>      <span class="number">80163</span></span><br><span class="line"><span class="number">1.0</span>      <span class="number">65671</span></span><br><span class="line"><span class="number">5.0</span>      <span class="number">62645</span></span><br><span class="line"><span class="number">4.0</span>      <span class="number">59818</span></span><br><span class="line"><span class="number">6.0</span>      <span class="number">46582</span></span><br><span class="line"><span class="number">8.0</span>      <span class="number">45168</span></span><br><span class="line"><span class="number">7.0</span>      <span class="number">44230</span></span><br><span class="line"><span class="number">9.0</span>      <span class="number">37866</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">employmentLength,</span> <span class="attr">dtype:</span> <span class="string">int64</span></span><br></pre></td></tr></table></figure>
<p>现在再来看看<code>earliesCreditLine</code>这列的数据长什么样子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'earliesCreditLine'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>         Aug<span class="number">-2001</span></span><br><span class="line"><span class="number">1</span>         May<span class="number">-2002</span></span><br><span class="line"><span class="number">2</span>         May<span class="number">-2006</span></span><br><span class="line"><span class="number">3</span>         May<span class="number">-1999</span></span><br><span class="line"><span class="number">4</span>         Aug<span class="number">-1977</span></span><br><span class="line">            ...   </span><br><span class="line"><span class="number">999995</span>    Nov<span class="number">-2005</span></span><br><span class="line"><span class="number">999996</span>    Oct<span class="number">-2006</span></span><br><span class="line"><span class="number">999997</span>    Dec<span class="number">-2001</span></span><br><span class="line"><span class="number">999998</span>    Aug<span class="number">-2005</span></span><br><span class="line"><span class="number">999999</span>    Aug<span class="number">-2002</span></span><br><span class="line">Name: earliesCreditLine, Length: <span class="number">1000000</span>, dtype: object</span><br></pre></td></tr></table></figure>
<p>我们也可以将其中的月份去掉只取其中的年，操作如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'earliesCreditLine'</span>] = data[<span class="string">'earliesCreditLine'</span>].apply(<span class="keyword">lambda</span> s: int(s[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure>
<p>结果就变成了数值类型的数据了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>         <span class="number">2001</span></span><br><span class="line"><span class="number">1</span>         <span class="number">2002</span></span><br><span class="line"><span class="number">2</span>         <span class="number">2006</span></span><br><span class="line"><span class="number">3</span>         <span class="number">1999</span></span><br><span class="line"><span class="number">4</span>         <span class="number">1977</span></span><br><span class="line">          <span class="string">...</span> </span><br><span class="line"><span class="number">999995</span>    <span class="number">2005</span></span><br><span class="line"><span class="number">999996</span>    <span class="number">2006</span></span><br><span class="line"><span class="number">999997</span>    <span class="number">2001</span></span><br><span class="line"><span class="number">999998</span>    <span class="number">2005</span></span><br><span class="line"><span class="number">999999</span>    <span class="number">2002</span></span><br><span class="line"><span class="attr">Name:</span> <span class="string">earliesCreditLine,</span> <span class="attr">Length:</span> <span class="number">1000000</span><span class="string">,</span> <span class="attr">dtype:</span> <span class="string">int64</span></span><br></pre></td></tr></table></figure>
<p>对一些类别特征做如下操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类型数在2之上，又不是高维稀疏的</span></span><br><span class="line">data = pd.get_dummies(data, columns=[<span class="string">'grade'</span>, <span class="string">'subGrade'</span>, <span class="string">'homeOwnership'</span>, <span class="string">'verificationStatus'</span>, 				<span class="string">'purpose'</span>, <span class="string">'regionCode'</span>], drop_first=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 高维类别特征需要进行转换</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">'employmentTitle'</span>, <span class="string">'postCode'</span>, <span class="string">'title'</span>]:</span><br><span class="line">    data[f+<span class="string">'_cnts'</span>] = data.groupby([f])[<span class="string">'id'</span>].transform(<span class="string">'count'</span>)</span><br><span class="line">    data[f+<span class="string">'_rank'</span>] = data.groupby([f])[<span class="string">'id'</span>].rank(ascending=<span class="literal">False</span>).astype(int)</span><br><span class="line">    <span class="keyword">del</span> data[f]</span><br></pre></td></tr></table></figure>
<p>我们发现在训练集中没有<code>n2.2，n2.3</code>这列，而在测试集中有，因此我们可以选择删掉这两列（也可以不删，如果用的是树模型，树模型会自己优化缺失值）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> data[<span class="string">'n2.2'</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">'n2.3'</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">'id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># id这列也没什么用，就一起删去了。</span></span><br></pre></td></tr></table></figure>
<p>现在将训练集和测试集拆分开来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = [f <span class="keyword">for</span> f <span class="keyword">in</span> data.columns <span class="keyword">if</span> f <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'id'</span>,<span class="string">'issueDate'</span>,<span class="string">'isDefault'</span>]]</span><br><span class="line"></span><br><span class="line">train = data[data.isDefault.notnull()].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">test = data[data.isDefault.isnull()].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">x_train = train[features]</span><br><span class="line">x_test = test[features]</span><br><span class="line"></span><br><span class="line">y_train = train[<span class="string">'isDefault'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="建模和融合"><a href="#建模和融合" class="headerlink" title="建模和融合"></a>建模和融合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_model</span><span class="params">(clf, train_x, train_y, test_x, clf_name)</span>:</span></span><br><span class="line">    folds = <span class="number">10</span></span><br><span class="line">    seed = <span class="number">2020</span></span><br><span class="line">    kf = KFold(n_splits=folds, shuffle=<span class="literal">True</span>, random_state=seed)</span><br><span class="line"></span><br><span class="line">    train = np.zeros(train_x.shape[<span class="number">0</span>])</span><br><span class="line">    test = np.zeros(test_x.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    cv_scores = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (train_index, valid_index) <span class="keyword">in</span> enumerate(kf.split(train_x, train_y)):</span><br><span class="line">        print(<span class="string">'************************************ &#123;&#125; ************************************'</span>.format(str(i+<span class="number">1</span>)))</span><br><span class="line">        trn_x, trn_y, val_x, val_y = train_x.iloc[train_index], train_y[train_index], train_x.iloc[valid_index], train_y[valid_index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"lgb"</span>:</span><br><span class="line">            train_matrix = clf.Dataset(trn_x, label=trn_y)</span><br><span class="line">            valid_matrix = clf.Dataset(val_x, label=val_y)</span><br><span class="line"></span><br><span class="line">            params = &#123;</span><br><span class="line">                <span class="string">'boosting_type'</span>: <span class="string">'gbdt'</span>,</span><br><span class="line">                <span class="string">'objective'</span>: <span class="string">'binary'</span>,</span><br><span class="line">                <span class="string">'metric'</span>: <span class="string">'auc'</span>,</span><br><span class="line">                <span class="string">'min_child_weight'</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">'num_leaves'</span>: <span class="number">2</span> ** <span class="number">5</span>,</span><br><span class="line">                <span class="string">'lambda_l2'</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="string">'feature_fraction'</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="string">'bagging_fraction'</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="string">'bagging_freq'</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="string">'learning_rate'</span>: <span class="number">0.1</span>,</span><br><span class="line">                <span class="string">'seed'</span>: <span class="number">2020</span>,</span><br><span class="line">                <span class="string">'nthread'</span>: <span class="number">28</span>,</span><br><span class="line">                <span class="string">'n_jobs'</span>:<span class="number">24</span>,</span><br><span class="line">                <span class="string">'silent'</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">'verbose'</span>: <span class="number">-1</span>,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            model = clf.train(params, train_matrix, <span class="number">50000</span>, valid_sets=[train_matrix, valid_matrix], verbose_eval=<span class="number">200</span>,early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">            val_pred = model.predict(val_x, num_iteration=model.best_iteration)</span><br><span class="line">            test_pred = model.predict(test_x, num_iteration=model.best_iteration)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># print(list(sorted(zip(features, model.feature_importance("gain")), key=lambda x: x[1], reverse=True))[:20])</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"xgb"</span>:</span><br><span class="line">            train_matrix = clf.DMatrix(trn_x , label=trn_y)</span><br><span class="line">            valid_matrix = clf.DMatrix(val_x , label=val_y)</span><br><span class="line">            test_matrix = clf.DMatrix(test_x)</span><br><span class="line">            </span><br><span class="line">            params = &#123;<span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">                      <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>,</span><br><span class="line">                      <span class="string">'eval_metric'</span>: <span class="string">'auc'</span>,</span><br><span class="line">                      <span class="string">'gamma'</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="string">'min_child_weight'</span>: <span class="number">1.5</span>,</span><br><span class="line">                      <span class="string">'max_depth'</span>: <span class="number">5</span>,</span><br><span class="line">                      <span class="string">'lambda'</span>: <span class="number">10</span>,</span><br><span class="line">                      <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'colsample_bylevel'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'eta'</span>: <span class="number">0.04</span>,</span><br><span class="line">                      <span class="string">'tree_method'</span>: <span class="string">'exact'</span>,</span><br><span class="line">                      <span class="string">'seed'</span>: <span class="number">2020</span>,</span><br><span class="line">                      <span class="string">'nthread'</span>: <span class="number">36</span>,</span><br><span class="line">                      <span class="string">"silent"</span>: <span class="literal">True</span>,</span><br><span class="line">                      &#125;</span><br><span class="line">            </span><br><span class="line">            watchlist = [(train_matrix, <span class="string">'train'</span>),(valid_matrix, <span class="string">'eval'</span>)]</span><br><span class="line">            </span><br><span class="line">            model = clf.train(params, train_matrix, num_boost_round=<span class="number">50000</span>, evals=watchlist, verbose_eval=<span class="number">200</span>, early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">            val_pred  = model.predict(valid_matrix, ntree_limit=model.best_ntree_limit)</span><br><span class="line">            test_pred = model.predict(test_matrix , ntree_limit=model.best_ntree_limit)</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"cat"</span>:</span><br><span class="line">            params = &#123;<span class="string">'learning_rate'</span>: <span class="number">0.05</span>, <span class="string">'depth'</span>: <span class="number">5</span>, <span class="string">'l2_leaf_reg'</span>: <span class="number">10</span>, <span class="string">'bootstrap_type'</span>: <span class="string">'Bernoulli'</span>,</span><br><span class="line">                      <span class="string">'od_type'</span>: <span class="string">'Iter'</span>, <span class="string">'od_wait'</span>: <span class="number">50</span>, <span class="string">'random_seed'</span>: <span class="number">11</span>, <span class="string">'allow_writing_files'</span>: <span class="literal">False</span>&#125;</span><br><span class="line">            </span><br><span class="line">            model = clf(iterations=<span class="number">20000</span>, **params)</span><br><span class="line">            model.fit(trn_x, trn_y, eval_set=(val_x, val_y),</span><br><span class="line">                      cat_features=[], use_best_model=<span class="literal">True</span>, verbose=<span class="number">500</span>)</span><br><span class="line">            </span><br><span class="line">            val_pred  = model.predict(val_x)</span><br><span class="line">            test_pred = model.predict(test_x)</span><br><span class="line">            </span><br><span class="line">        train[valid_index] = val_pred</span><br><span class="line">        test = test_pred / kf.n_splits</span><br><span class="line">        cv_scores.append(roc_auc_score(val_y, val_pred))</span><br><span class="line">        </span><br><span class="line">        print(cv_scores)</span><br><span class="line">       </span><br><span class="line">    print(<span class="string">"%s_scotrainre_list:"</span> % clf_name, cv_scores)</span><br><span class="line">    print(<span class="string">"%s_score_mean:"</span> % clf_name, np.mean(cv_scores))</span><br><span class="line">    print(<span class="string">"%s_score_std:"</span> % clf_name, np.std(cv_scores))</span><br><span class="line">    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lgb_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    lgb_train, lgb_test = cv_model(lgb, x_train, y_train, x_test, <span class="string">"lgb"</span>)</span><br><span class="line">    <span class="keyword">return</span> lgb_train, lgb_test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xgb_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    xgb_train, xgb_test = cv_model(xgb, x_train, y_train, x_test, <span class="string">"xgb"</span>)</span><br><span class="line">    <span class="keyword">return</span> xgb_train, xgb_test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cat_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    cat_train, cat_test = cv_model(CatBoostRegressor, x_train, y_train, x_test, <span class="string">"cat"</span>) </span><br><span class="line">    <span class="keyword">return</span> cat_train, cat_test</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rh_test = <span class="number">0.5</span>*lgb_test+<span class="number">0.5</span>*cat_test</span><br><span class="line">testA[<span class="string">'isDefault'</span>] = rh_test</span><br><span class="line">testA[[<span class="string">'id'</span>,<span class="string">'isDefault'</span>]].to_csv(<span class="string">'test_sub.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>因为<code>xgboost</code>模型的速度会比其它两个慢很多，我就没用这个去训练了。</p>
<p><strong>baseline.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入需要的库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> catboost <span class="keyword">import</span> CatBoostRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDRegressor, LinearRegression, Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold, KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, f1_score, roc_auc_score, log_loss</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">train = pd.read_csv(<span class="string">'data/train.csv'</span>)</span><br><span class="line">testA = pd.read_csv(<span class="string">'data/testA.csv'</span>)</span><br><span class="line"></span><br><span class="line">data = pd.concat([train, testA], axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">data[<span class="string">'employmentLength'</span>].replace(to_replace=<span class="string">'10+ years'</span>, value=<span class="string">'10 years'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">'employmentLength'</span>].replace(<span class="string">'&lt; 1 year'</span>, <span class="string">'0 years'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">employmentLength_to_int</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pd.isnull(s):</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.int8(s.split()[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">data[<span class="string">'employmentLength'</span>] = data[<span class="string">'employmentLength'</span>].apply(employmentLength_to_int)</span><br><span class="line">data[<span class="string">'earliesCreditLine'</span>] = data[<span class="string">'earliesCreditLine'</span>].apply(<span class="keyword">lambda</span> s: int(s[<span class="number">-4</span>:]))</span><br><span class="line"></span><br><span class="line">data = pd.get_dummies(data, columns=[<span class="string">'grade'</span>, <span class="string">'subGrade'</span>, <span class="string">'homeOwnership'</span>, <span class="string">'verificationStatus'</span>, <span class="string">'purpose'</span>, <span class="string">'regionCode'</span>], drop_first=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">'employmentTitle'</span>, <span class="string">'postCode'</span>, <span class="string">'title'</span>]:</span><br><span class="line">    data[f+<span class="string">'_cnts'</span>] = data.groupby([f])[<span class="string">'id'</span>].transform(<span class="string">'count'</span>)</span><br><span class="line">    data[f+<span class="string">'_rank'</span>] = data.groupby([f])[<span class="string">'id'</span>].rank(ascending=<span class="literal">False</span>).astype(int)</span><br><span class="line">    <span class="keyword">del</span> data[f]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">del</span> data[<span class="string">'n2.2'</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">'n2.3'</span>]</span><br><span class="line"><span class="keyword">del</span> data[<span class="string">'id'</span>]</span><br><span class="line"></span><br><span class="line">features = [f <span class="keyword">for</span> f <span class="keyword">in</span> data.columns <span class="keyword">if</span> f <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'id'</span>,<span class="string">'issueDate'</span>,<span class="string">'isDefault'</span>]]</span><br><span class="line"></span><br><span class="line">train = data[data.isDefault.notnull()].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">test = data[data.isDefault.isnull()].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">x_train = train[features]</span><br><span class="line">x_test = test[features]</span><br><span class="line">y_train = train[<span class="string">'isDefault'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_model</span><span class="params">(clf, train_x, train_y, test_x, clf_name)</span>:</span></span><br><span class="line">    folds = <span class="number">10</span></span><br><span class="line">    seed = <span class="number">2020</span></span><br><span class="line">    kf = KFold(n_splits=folds, shuffle=<span class="literal">True</span>, random_state=seed)</span><br><span class="line"></span><br><span class="line">    train = np.zeros(train_x.shape[<span class="number">0</span>])</span><br><span class="line">    test = np.zeros(test_x.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    cv_scores = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (train_index, valid_index) <span class="keyword">in</span> enumerate(kf.split(train_x, train_y)):</span><br><span class="line">        print(<span class="string">'************************************ &#123;&#125; ************************************'</span>.format(str(i+<span class="number">1</span>)))</span><br><span class="line">        trn_x, trn_y, val_x, val_y = train_x.iloc[train_index], train_y[train_index], train_x.iloc[valid_index], train_y[valid_index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"lgb"</span>:</span><br><span class="line">            train_matrix = clf.Dataset(trn_x, label=trn_y)</span><br><span class="line">            valid_matrix = clf.Dataset(val_x, label=val_y)</span><br><span class="line"></span><br><span class="line">            params = &#123;</span><br><span class="line">                <span class="string">'boosting_type'</span>: <span class="string">'gbdt'</span>,</span><br><span class="line">                <span class="string">'objective'</span>: <span class="string">'binary'</span>,</span><br><span class="line">                <span class="string">'metric'</span>: <span class="string">'auc'</span>,</span><br><span class="line">                <span class="string">'min_child_weight'</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">'num_leaves'</span>: <span class="number">2</span> ** <span class="number">5</span>,</span><br><span class="line">                <span class="string">'lambda_l2'</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="string">'feature_fraction'</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="string">'bagging_fraction'</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="string">'bagging_freq'</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="string">'learning_rate'</span>: <span class="number">0.1</span>,</span><br><span class="line">                <span class="string">'seed'</span>: <span class="number">2020</span>,</span><br><span class="line">                <span class="string">'nthread'</span>: <span class="number">28</span>,</span><br><span class="line">                <span class="string">'n_jobs'</span>:<span class="number">24</span>,</span><br><span class="line">                <span class="string">'silent'</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">'verbose'</span>: <span class="number">-1</span>,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            model = clf.train(params, train_matrix, <span class="number">50000</span>, valid_sets=[train_matrix, valid_matrix], verbose_eval=<span class="number">200</span>,early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">            val_pred = model.predict(val_x, num_iteration=model.best_iteration)</span><br><span class="line">            test_pred = model.predict(test_x, num_iteration=model.best_iteration)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># print(list(sorted(zip(features, model.feature_importance("gain")), key=lambda x: x[1], reverse=True))[:20])</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"xgb"</span>:</span><br><span class="line">            train_matrix = clf.DMatrix(trn_x , label=trn_y)</span><br><span class="line">            valid_matrix = clf.DMatrix(val_x , label=val_y)</span><br><span class="line">            test_matrix = clf.DMatrix(test_x)</span><br><span class="line">            </span><br><span class="line">            params = &#123;<span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">                      <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>,</span><br><span class="line">                      <span class="string">'eval_metric'</span>: <span class="string">'auc'</span>,</span><br><span class="line">                      <span class="string">'gamma'</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="string">'min_child_weight'</span>: <span class="number">1.5</span>,</span><br><span class="line">                      <span class="string">'max_depth'</span>: <span class="number">5</span>,</span><br><span class="line">                      <span class="string">'lambda'</span>: <span class="number">10</span>,</span><br><span class="line">                      <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'colsample_bylevel'</span>: <span class="number">0.7</span>,</span><br><span class="line">                      <span class="string">'eta'</span>: <span class="number">0.04</span>,</span><br><span class="line">                      <span class="string">'tree_method'</span>: <span class="string">'exact'</span>,</span><br><span class="line">                      <span class="string">'seed'</span>: <span class="number">2020</span>,</span><br><span class="line">                      <span class="string">'nthread'</span>: <span class="number">36</span>,</span><br><span class="line">                      <span class="string">"silent"</span>: <span class="literal">True</span>,</span><br><span class="line">                      &#125;</span><br><span class="line">            </span><br><span class="line">            watchlist = [(train_matrix, <span class="string">'train'</span>),(valid_matrix, <span class="string">'eval'</span>)]</span><br><span class="line">            </span><br><span class="line">            model = clf.train(params, train_matrix, num_boost_round=<span class="number">50000</span>, evals=watchlist, verbose_eval=<span class="number">200</span>, early_stopping_rounds=<span class="number">200</span>)</span><br><span class="line">            val_pred  = model.predict(valid_matrix, ntree_limit=model.best_ntree_limit)</span><br><span class="line">            test_pred = model.predict(test_matrix , ntree_limit=model.best_ntree_limit)</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">if</span> clf_name == <span class="string">"cat"</span>:</span><br><span class="line">            params = &#123;<span class="string">'learning_rate'</span>: <span class="number">0.05</span>, <span class="string">'depth'</span>: <span class="number">5</span>, <span class="string">'l2_leaf_reg'</span>: <span class="number">10</span>, <span class="string">'bootstrap_type'</span>: <span class="string">'Bernoulli'</span>,</span><br><span class="line">                      <span class="string">'od_type'</span>: <span class="string">'Iter'</span>, <span class="string">'od_wait'</span>: <span class="number">50</span>, <span class="string">'random_seed'</span>: <span class="number">11</span>, <span class="string">'allow_writing_files'</span>: <span class="literal">False</span>&#125;</span><br><span class="line">            </span><br><span class="line">            model = clf(iterations=<span class="number">20000</span>, **params)</span><br><span class="line">            model.fit(trn_x, trn_y, eval_set=(val_x, val_y),</span><br><span class="line">                      cat_features=[], use_best_model=<span class="literal">True</span>, verbose=<span class="number">500</span>)</span><br><span class="line">            </span><br><span class="line">            val_pred  = model.predict(val_x)</span><br><span class="line">            test_pred = model.predict(test_x)</span><br><span class="line">            </span><br><span class="line">        train[valid_index] = val_pred</span><br><span class="line">        test = test_pred / kf.n_splits</span><br><span class="line">        cv_scores.append(roc_auc_score(val_y, val_pred))</span><br><span class="line">        </span><br><span class="line">        print(cv_scores)</span><br><span class="line">       </span><br><span class="line">    print(<span class="string">"%s_scotrainre_list:"</span> % clf_name, cv_scores)</span><br><span class="line">    print(<span class="string">"%s_score_mean:"</span> % clf_name, np.mean(cv_scores))</span><br><span class="line">    print(<span class="string">"%s_score_std:"</span> % clf_name, np.std(cv_scores))</span><br><span class="line">    <span class="keyword">return</span> train, test</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lgb_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    lgb_train, lgb_test = cv_model(lgb, x_train, y_train, x_test, <span class="string">"lgb"</span>)</span><br><span class="line">    <span class="keyword">return</span> lgb_train, lgb_test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xgb_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    xgb_train, xgb_test = cv_model(xgb, x_train, y_train, x_test, <span class="string">"xgb"</span>)</span><br><span class="line">    <span class="keyword">return</span> xgb_train, xgb_test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cat_model</span><span class="params">(x_train, y_train, x_test)</span>:</span></span><br><span class="line">    cat_train, cat_test = cv_model(CatBoostRegressor, x_train, y_train, x_test, <span class="string">"cat"</span>) </span><br><span class="line">    <span class="keyword">return</span> cat_train, cat_test</span><br><span class="line"></span><br><span class="line">lgb_train, lgb_test = lgb_model(x_train, y_train, x_test)</span><br><span class="line">xgb_train, xgb_test = xgb_model(x_train, y_train, x_test)</span><br><span class="line">cat_train, cat_test = cat_model(x_train, y_train, x_test)</span><br><span class="line"></span><br><span class="line">rh_test = <span class="number">0.5</span>*lgb_test+<span class="number">0.5</span>*xgb_test</span><br><span class="line">testA[<span class="string">'isDefault'</span>] = rh_test</span><br><span class="line">testA[[<span class="string">'id'</span>,<span class="string">'isDefault'</span>]].to_csv(<span class="string">'test_sub.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>金融风控</tag>
      </tags>
  </entry>
  <entry>
    <title>条件随机场</title>
    <url>/2020/09/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/</url>
    <content><![CDATA[<p><strong>摘要：</strong></p>
<p>&emsp;&emsp;条件随机场（Conditional Random Field，CRF）是自然语言处理的基础模型，广泛应用于中文分词、命名实体识别、词性标注等标注场景。</p>
<p>下面通过一个小问题来引入：</p>
<p> &emsp;&emsp;假设你有许多小明同学一天内不同时段的照片，从小明提裤子起床到脱裤子睡觉各个时间段都有（小明是照片控！）。现在的任务是对这些照片进行分类。比如有的照片是吃饭，那就给它打上吃饭的标签；有的照片是跑步时拍的，那就打上跑步的标签；有的照片是开会时拍的，那就打上开会的标签。问题来了，你准备怎么干？一个简单直观的办法就是，不管这些照片之间的时间顺序，想办法训练出一个多元分类器。就是用一些打好标签的照片作为训练数据，训练出一个模型，直接根据照片的特征来分类。例如，如果照片是早上6:00拍的，且画面是黑暗的，那就给它打上睡觉的标签;如果照片上有车，那就给它打上开车的标签。</p>
<p>这样可行吗？</p>
<p>&emsp;&emsp;乍一看可以！但实际上，由于我们忽略了这些照片之间的时间顺序这一重要信息，我们的分类器会有缺陷的。举个例子，假如有一张小明闭着嘴的照片，怎么分类？显然难以直接判断，需要参考闭嘴之前的照片，如果之前的照片显示小明在吃饭，那这个闭嘴的照片很可能是小明在咀嚼食物准备下咽，可以给它打上吃饭的标签；如果之前的照片显示小明在唱歌，那这个闭嘴的照片很可能是小明唱歌瞬间的抓拍，可以给它打上唱歌的标签。所以，为了让我们的分类器能够有更好的表现，在为一张照片分类时，我们必须将与它相邻的照片的标签信息考虑进来。</p>
<p>这——就是条件随机场(CRF)大显身手的地方！</p>
<h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p><strong>成对马尔可夫性</strong></p>
<p>设无向图G中的任意两个没有边连接的节点u,v ，其他所有节点为O，成对马尔可夫性指：给定$Y_O$的条件下，$Y_u$和$Y_v$条件独立</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920131014.png" alt="1878606-20191124224138348-1444697223" style="zoom: 33%;" /></p>
<script type="math/tex; mode=display">
P\left(Y_{u}, Y_{v} \mid Y_{O}\right)=P\left(Y_{u} \mid Y_{O}\right) P\left(Y_{v} \mid Y_{O}\right)</script><p><strong>局部马尔可夫性</strong></p>
<p>设无向图G的任一节点v，W是与v有边相连的所有节点，O是v、W外的其他所有节点，局部马尔可夫性指：给定$Y_W$的条件下，$Y_v$和$Y_O$条件独立</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920131325.png" alt="1" style="zoom:33%;" /></p>
<script type="math/tex; mode=display">
P\left(Y_{v}, Y_{O} \mid Y_{W}\right)=P\left(Y_{v} \mid Y_{W}\right) P\left(Y_{O} \mid Y_{W}\right)</script><p>在 $P\left(Y_{O} / Y_{W}\right)&gt;0$ 时, 等价地,</p>
<script type="math/tex; mode=display">
P\left(Y_{v} \mid Y_{W}\right)=P\left(Y_{v} \mid Y_{W}, Y_{O}\right)</script><p><strong>全局马尔可夫性</strong></p>
<p>设节点集合 $A, B$ 是在无向图 $G$ 中被节点集合C分开的任意节点集合, 全局马尔可夫性指：给定 $Y_{C}$ 的条件下, $Y_{A}$ 和 $Y_{B}$ 条件独立</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920131618.png" alt="2" style="zoom:33%;" /></p>
<script type="math/tex; mode=display">
P\left(Y_{A}, Y_{B} \mid Y_{C}\right)=P\left(Y_{A} \mid Y_{C}\right) P\left(Y_{B} \mid Y_{C}\right)</script><p><strong>团和最大团</strong></p>
<p>无向图G中任何两个结点均有边连接的结点子集称为团。若C是无向图G的一个团，并且不能再加进任何一个G的结点使其成为更大的一个团，则称此C为最大团。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920132252.jpg" alt="微信图片_20200920132242" style="zoom: 25%;" /></p>
<h3 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h3><h4 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h4><p>设X和Y是随机变量, $P(Y \mid X)$ 是在给定 $X$ 的条件下Y的条件概率分布。若随机变量 $Y$ 构成一个有无向图 $G=(V, E)$ 表示的马尔可夫场, 即</p>
<script type="math/tex; mode=display">
P\left(Y_{v} \mid X, Y_{w}, w \neq v\right)=P\left(Y_{v} \mid X, Y_{w}, w \sim v\right)</script><p>对任意节点v都成立，则称 $P(Y \mid X)$ 是条件随机场。式中 $w \neq v$ 表示 $w$ 是除v以外的所有节点, $w \sim v$ 表示 $w$ 是与 $v$ 相连接的所有节点。</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920132646.png" alt="1878606-20191124224606259-1035123340" style="zoom: 33%;" /></p>
<h4 id="线性链随机场"><a href="#线性链随机场" class="headerlink" title="线性链随机场"></a>线性链随机场</h4><p>对于线性链条件随机场来说，图G的每条边都存在于状态序列Y的相邻两个节点, 最大团 $C$ 是相邻两个节点的集合, X和Y有相同的图 结构意味着每个 $X_{i}$ 都与 $Y_{i} \longrightarrow$ 对应 $_{0}$<br>设 $X=\left(X_{1}, \ldots, X_{n}\right), Y=\left(Y_{1}, \ldots, Y_{n}\right)$ 均为线性链表示的随机变量序列, 若在给定随机变量序列 $X$ 的条件下, 随机变量序列 $Y$ 的 条件分布 $P(Y \mid X)$ 构成条件随机场，即满足马尔可夫性</p>
<script type="math/tex; mode=display">
P\left(Y_{i} \mid X, Y_{1}, \cdots, Y_{i-1}, Y_{i+1}, \cdots, Y_{n}\right)=P\left(Y_{i} \mid X, Y_{i-1}, Y_{i+1}\right),\\
i=1,\cdots,n~~~~其中当i取1或n时只考虑单边</script><p>则称 $P(Y \mid X)$ 为线性链条件随机场。在标注问题中 $X$ 表示输入观测序列, $Y$ 表示对应的状态序列。</p>
<h4 id="参数化形式"><a href="#参数化形式" class="headerlink" title="参数化形式"></a>参数化形式</h4><p>设 $P(Y \mid X)$ 为线性链条件随机场，则在随机变量X取值为x的条件下，随机变量Y取值为y的条件概率具有如下形式：</p>
<script type="math/tex; mode=display">
P(y \mid x)=\frac{1}{Z(x)} \exp \left[\sum_{i, k} \lambda_{k} t_{k}\left(y_{i-1}, y_{i}, x, i\right)+\sum_{i, l} \mu_{l} s_{l}\left(y_{i}, x, i\right)\right]</script><p>其中$s_l \left(y_i,x,i\right)，l=1,2,\cdots,L。$ $L是定义在该节点的节点特征函数的总个数，i是当前节点在序列的位置。$<br>$t_k(y_{i-1},y_i,x,i)，k=1,2,\cdots,K。$$K是定义在该节点的局部特征函数的总个数，i是是当前节点在序列的位置。$</p>
<script type="math/tex; mode=display">
Z(x)=\sum_{y} \exp \left[\sum_{i, k} \lambda_{k} t_{k}\left(y_{i-1}, y_{i}, x, i\right)+\sum_{i, l} \mu_{l} s_{l}\left(y_{i}, x, i\right)\right]</script><p>上式是基本形式, 表示给定输入序列 $x,$ 对输出序列 $y$ 预闪的条件概率。 $t_{k}$ 是定义在边上的特征函数，称为转移特征, 依赖于当前和前一个 位置, $s_{l}$ 是定义在节点上的特征函数, 称为状态特征, 依赖于当前位置。 $t_{k}$ 和 $s_{l}$ 都依赖于位置, 是局部特征函数。通常都是0-1函数。线性链条件随机场也是对数线性模型(逻辑回归也是)。</p>
<p>【例子】</p>
<p>这里我们给出一个linear-CRF用于词性标注的实例，为了方便，我们简化了词性的种类。假设输入 的都是三个词的句子, 即 $X=\left(X_{1}, \quad, X_{2}, \quad, X_{3}\right),$ 输出的词性标记为 $Y=\left(Y_{1}, \quad, Y_{2}, \quad Y_{3}\right),$ 其中 $Y \in\{1($ 名词 $), 2(动词)\}$。</p>
<p>这里只标记出取值为1的特征函数如下：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920134733.png" alt="v2-1c251241e085fbd3e1b981cb3804c444_720w (1)"></p>
<p>求标记(1,2,2)的非规范化概率。</p>
<p>利用linear-CRF的参数化公式，我们有：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920134810.png" alt="v2-59696a72f607ac385e69256a9a73179d_720w"></p>
<p>带入(1,2,2)有：</p>
<p><img src="https://gitee.com/Godg1000/picture_bed/raw/master/20200920134834.png" alt="v2-4dabf5e5def017a550d62db375407740_720w"></p>
<h4 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h4><p>设有 $K_{1}$ 个转移特征, $K_{2}$ 个状态特征, $K=K_{1}+K_{2},$ 记</p>
<script type="math/tex; mode=display">
f_{k}\left(y_{i-1}, y_{i}, x, i\right)=\left\{\begin{array}{l}
t_{k}\left(y_{i-1}, y_{i}, x, i\right) \quad k=1,2, \cdots, K_{1} \\
s_{l}\left(y_{i}, x, l\right) \quad k=K_{1}+l ; l=1,2, \cdots, K_{2}
\end{array}\right.</script><p>然后, 对转移与状态特征在各个位置i求和, 记作</p>
<script type="math/tex; mode=display">
f_{k}(y, x)=\sum_{i=1}^{n} f_{k}\left(y_{i-1}, y_{i}, x, i\right), \quad k=1,2, \cdots, K</script><p>用w $_{k}$ 表示特征 $f_{k}(y, x)$ 的权值, 即</p>
<script type="math/tex; mode=display">
w_{k}=\left\{\begin{array}{ll}
\lambda_{k}, & k=1,2 \cdots, K_{1} \\
\mu_{l}, & k=K_{1}+l, l=1,2, \cdots, K_{2}
\end{array}\right.</script><p>于是, 条件随机场可以表示为</p>
<script type="math/tex; mode=display">
p(y \mid x)=\frac{1}{Z_{y}(x)} \exp \sum_{k=1}^{K} w_{k} f_{k}(y, x)</script><h4 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h4><p>引进特殊的起点和和终点状态标记 $y_{0}=\operatorname{start}, y_{n+1}=\operatorname{stop}, \quad$ 这是 $P_{w}(y \mid x)$ (简化形式)可以通过矩阵形式表示<br>对观测序列 $x$ 的每一个位置 $i=1,2, \cdots, n+1,$ 定义一个m阶的矩阵(m是标记 $y_{i}$ 取值的个数 $)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
M_{i}(x) &=\left[M_{i}\left(y_{i-1}, y_{i} \mid x\right)\right] \\
M_{i}\left(y_{i-1}, y_{i} \mid x\right) &=\exp \left(W_{i}\left(y_{i+1, y_{i} \mid x}\right)\right) \\
W_{i}\left(y_{i+1}, y_{i} \mid x\right) &=\sum_{k=1}^{K} w_{k} f_{k}\left(y_{i-1}, y_{i}, x, i\right)
\end{aligned}</script><p>这样，给定观测序列 $x,$ 相应标记序列y的非规范化概率可以通过该序列 $n+1$ 个矩阵适当元素的乘积 $\prod_{i=1}^{n+1} M_{i}\left(y_{i-1}, y_{i} \mid x\right)$ 表示, 于 是条件概率 $P_{w}(y \mid x)$ 是</p>
<script type="math/tex; mode=display">
P_{w}(y \mid x)=\frac{1}{Z_{w}(x)} \prod_{i=1}^{n+1} M_{i}\left(y_{i-1}, y_{i} \mid x\right)</script><p>其中, $Z_{w}(x)$ 是规范化因子, 是 $n+1$ 个矩阵的乘积的(start, stop)元素。</p>
<script type="math/tex; mode=display">
Z_{w}(x)=\left(M_{1}(x) M_{2}(x) \cdots M_{n+1}(x)\right)_{\text {start}, \text {stop}}</script><p>注意, $y_{0}=\operatorname{start} 5 y_{n+1}=s t o p$ 表示开始开始状态和终止状态, 规范化因子 $Z_{w}(x)$ 是以start为起点stop为终点通过状态的所有路径 $y_{1} y_{2} \cdots y_{n}$ 的非规范化概率 $\prod_{i=1}^{n+1} M_{i}\left(y_{i-1}, y_{i} \mid x\right)$ 之和</p>
<h3 id="CRF的概率计算问题"><a href="#CRF的概率计算问题" class="headerlink" title="CRF的概率计算问题"></a>CRF的概率计算问题</h3><h4 id="前向-后向算法"><a href="#前向-后向算法" class="headerlink" title="前向-后向算法"></a>前向-后向算法</h4><p>对每个指标$i=0,1,\cdots,n+1$，定义前向向量$\alpha_i(x)$</p>
<script type="math/tex; mode=display">
\alpha_0(y|x)=
\begin{cases}
1， y=start \\
0， 否则
\end{cases}</script><script type="math/tex; mode=display">
\alpha_i^T(x)=\alpha_{i-1}^T(x)M_i(x)</script><p>$\alpha_{i}\left(y_{i} \mid x\right)$ 表示在位置 $i$ 的标记是 $y_{i}$ 并且从 1 到 $i$ 的前 部分标记序列的非规范化概 率， $y_{i}$ 可取的值有 $m$ 个, 所以 $\alpha_{i}(x)$ 是 $m$ 维列向量。 同样，对每个指标 $i=0,1, \cdots, n+1,$ 定义后向向量 $\beta_{i}(x)$ :</p>
<script type="math/tex; mode=display">
\begin{aligned}
\beta_{n+1}\left(y_{n+1} \mid x\right) &=\left\{\begin{array}{ll}
1, & y_{n+1}=\text { stop } \\
0, & \text { 否则 }
\end{array}\right.\\
\beta_{i}\left(y_{i} \mid x\right) &=\left[M_{i+1}\left(y_{i}, y_{i+1} \mid x\right)\right] \beta_{i+1}\left(y_{i+1} \mid x\right)
\end{aligned}</script><p>又可表示为</p>
<script type="math/tex; mode=display">
\beta_{i}(x)=M_{i+1}(x) \beta_{i+1}(x)</script><p>$\beta_{i}\left(y_{i} \mid x\right)$ 表示在位置 $i$ 的标记为 $y_{i}$ 并且从 $i+1$ 到 $n$ 的后部分标记序列的非规范化概率。</p>
<h4 id="概率计算"><a href="#概率计算" class="headerlink" title="概率计算"></a>概率计算</h4><p>按照前向-后向向量的定义，很容易计算标记序列在位置 i 是标记 $y_{i}$ 的条件概率 和在位置 $i-1$ 与 $i$ 是标记 $y_{i-1}$ 和 $y_{i}$ 的条件概率:</p>
<script type="math/tex; mode=display">
P\left(Y_{i}=y_{i} \mid x\right)=\frac{\alpha_{i}^{\mathrm{T}}\left(y_{i} \mid x\right) \beta_{i}\left(y_{i} \mid x\right)}{Z(x)}</script><script type="math/tex; mode=display">
P\left(Y_{i-1}=y_{i-1}, Y_{i}=y_{i} \mid x\right)=\frac{\alpha_{i-1}^{\mathrm{T}}\left(y_{i-1} \mid x\right) M_{i}\left(y_{i-1}, y_{i} \mid x\right) \beta_{i}\left(y_{i} \mid x\right)}{Z(x)}</script><p>其中,</p>
<script type="math/tex; mode=display">
Z(x)=\alpha_{n}^{\mathrm{T}}(x) 1=1 \beta_{1}(x)</script><p>1 是元素均为 1 的 m 维列向量。</p>
<h4 id="期望值的计算"><a href="#期望值的计算" class="headerlink" title="期望值的计算"></a>期望值的计算</h4><p>$P(Y \mid X)$ 的数学期望。<br>特佐聚数 $f_{k}$ 美于条件分布 $P(Y \mid X)$ 的数学期望是</p>
<script type="math/tex; mode=display">
\begin{aligned}
E_{P(Y \mid X)}\left[f_{k}\right]=& \sum_{y} P(y \mid x) f_{k}(y, x) \\
=& \sum_{i=1}^{n+1} \sum_{y_{i-1} y_{i}} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \frac{\alpha_{i-1}^{\mathrm{T}}\left(y_{i-1} \mid x\right) M_{i}\left(y_{i-1}, y_{i} \mid x\right) \beta_{i}\left(y_{i} \mid x\right)}{Z(x)} \\
& \quad \quad k=1,2, \cdots, K
\end{aligned}</script><p>其中 ,</p>
<script type="math/tex; mode=display">
Z(x)=\alpha_{n}^{\mathrm{T}}(x) 1</script><script type="math/tex; mode=display">
\begin{aligned}
E_{P(X, Y)}\left[f_{k}\right] &=\sum_{x, y} P(x, y) \sum_{i=1}^{n+1} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \\
&=\sum_{x} \tilde{P}(x) \sum_{y} P(y \mid x) \sum_{i=1}^{n+1} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \\
&=\sum_{x} \tilde{P}(x) \sum_{i=1}^{n+1} \sum_{y_{i}-1 y_{i}} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \frac{\alpha_{i-1}^{T}\left(y_{i-1} \mid x\right) M_{i}\left(y_{i-1}, y_{i} \mid x\right) \beta_{i}\left(y_{i} \mid x\right)}{Z(x)} \\
& & k=1,2, \cdots, K
\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x)=\alpha_{n}^{\mathrm{T}}(x) 1</script><p>假设经聚分布为 $\tilde{P}(X),$ 特征函数 $f_{k}$ 关于联合分布 $P(X, Y)$ 的数学期望是</p>
<script type="math/tex; mode=display">
\begin{aligned}
E_{P(X, Y)}\left[f_{k}\right] &=\sum_{x, y} P(x, y) \sum_{i=1}^{n+1} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \\
&=\sum_{x} \tilde{P}(x) \sum_{y} P(y \mid x) \sum_{i=1}^{n+1} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \\
&=\sum_{x} \tilde{P}(x) \sum_{i=1}^{n+1} \sum_{y_{i}-1 y_{i}} f_{k}\left(y_{i-1}, y_{i}, x, i\right) \frac{\alpha_{i-1}^{T}\left(y_{i-1} \mid x\right) M_{i}\left(y_{i-1}, y_{i} \mid x\right) \beta_{i}\left(y_{i} \mid x\right)}{Z(x)} \\
& & k=1,2, \cdots, K
\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x)=\alpha_{n}^{\mathrm{T}}(x) 1</script><p>&emsp;&emsp;式 (11.34) 和式 (11.35) 是特征函数数学期望的一般计算公式。对于转移特征 $t_{k}\left(y_{i-1}, y_{i}, x, i\right), k=1,2, \cdots, K_{1},$ 可以将式中的 $f_{k}$ 换成 $t_{k}:$ 对于状态特征，可以将 式中的 $f_{k}$ 换成 $s_{i},$ 表示为 $s_{l}\left(y_{i}, x, i\right), k=K_{1}+l, l=1,2, \cdots, K_{2} $ 。</p>
<p>&emsp;&emsp;有了式 (11.32)$\sim$ 式 $(11.35),$ 对于给定的观测序列 $x$ 与标记序列 $y,$ 可以通过一次 前向扫描计甘 $\alpha_{i}$ 及 $Z(x),$ 通过一次后向扫描计算 $\beta_{i},$ 从而计算所有的概率和特征的 期望。</p>
<h3 id="CRF的学习预测算法"><a href="#CRF的学习预测算法" class="headerlink" title="CRF的学习预测算法"></a>CRF的学习预测算法</h3><p>先占个坑，这章知识太多了！！！。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里定义T为转移矩阵列代表前一个y(ij)代表由状态i转到状态j的概率,Tx矩阵x对应于时间序列</span></span><br><span class="line"><span class="comment">#这里将书上的转移特征转换为如下以时间轴为区别的三个多维列表，维度为输出的维度</span></span><br><span class="line">T1 = [[<span class="number">0.6</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">T2 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0.2</span>]]</span><br><span class="line"><span class="comment">#将书上的状态特征同样转换成列表,第一个是为y1的未规划概率，第二个为y2的未规划概率</span></span><br><span class="line">S0 = [<span class="number">1</span>, <span class="number">0.5</span>]</span><br><span class="line">S1 = [<span class="number">0.8</span>, <span class="number">0.5</span>]</span><br><span class="line">S2 = [<span class="number">0.8</span>, <span class="number">0.5</span>]</span><br><span class="line">Y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]  <span class="comment">#即书上例一需要计算的非规划条件概率的标记序列</span></span><br><span class="line">Y = array(Y) - <span class="number">1</span>  <span class="comment">#这里为了将数与索引相对应即从零开始</span></span><br><span class="line">P = exp(S0[Y[<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(Y)):</span><br><span class="line">    P *= exp((eval(<span class="string">'S%d'</span> % i)[Y[i]]) + eval(<span class="string">'T%d'</span> % i)[Y[i - <span class="number">1</span>]][Y[i]])</span><br><span class="line">print(P)</span><br><span class="line">print(exp(<span class="number">3.2</span>))</span><br></pre></td></tr></table></figure>
<p><strong>Reference:</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/55755fc649b1" target="_blank" rel="noopener">https://www.jianshu.com/p/55755fc649b1</a></li>
<li><a href="https://www.cnblogs.com/weilonghu/p/11924962.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilonghu/p/11924962.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29989121" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29989121</a></li>
</ul>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
